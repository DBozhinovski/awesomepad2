(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* jshint node:true */
"use strict";

var Ractive = require("./../bower_components/ractive/ractive.js");

console.log("hello world");
console.log(Ractive);

},{"./../bower_components/ractive/ractive.js":2}],2:[function(require,module,exports){
/*
	ractive.js v0.5.5
	2014-07-13 - commit 8b1d34ef 

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

( function( global ) {

	'use strict';

	var noConflict = global.Ractive;

	/* config/defaults/options.js */
	var options = function() {

		// These are both the values for Ractive.defaults
		// as well as the determination for whether an option
		// value will be placed on Component.defaults
		// (versus directly on Component) during an extend operation
		var defaultOptions = {
			// render placement:
			el: void 0,
			append: false,
			// template:
			template: {
				v: 1,
				t: []
			},
			// parse:
			preserveWhitespace: false,
			sanitize: false,
			stripComments: true,
			// data & binding:
			data: {},
			computed: {},
			magic: false,
			modifyArrays: true,
			adapt: [],
			isolated: false,
			twoway: true,
			lazy: false,
			// transitions:
			noIntro: false,
			transitionsEnabled: true,
			complete: void 0,
			// css:
			noCssTransform: false,
			// debug:
			debug: false
		};
		return defaultOptions;
	}();

	/* config/defaults/easing.js */
	var easing = {
		linear: function( pos ) {
			return pos;
		},
		easeIn: function( pos ) {
			return Math.pow( pos, 3 );
		},
		easeOut: function( pos ) {
			return Math.pow( pos - 1, 3 ) + 1;
		},
		easeInOut: function( pos ) {
			if ( ( pos /= 0.5 ) < 1 ) {
				return 0.5 * Math.pow( pos, 3 );
			}
			return 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );
		}
	};

	/* circular.js */
	var circular = [];

	/* utils/hasOwnProperty.js */
	var hasOwn = Object.prototype.hasOwnProperty;

	/* utils/isArray.js */
	var isArray = function() {

		var toString = Object.prototype.toString;
		// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
		return function( thing ) {
			return toString.call( thing ) === '[object Array]';
		};
	}();

	/* utils/isObject.js */
	var isObject = function() {

		var toString = Object.prototype.toString;
		return function( thing ) {
			return thing && toString.call( thing ) === '[object Object]';
		};
	}();

	/* utils/isNumeric.js */
	var isNumeric = function( thing ) {
		return !isNaN( parseFloat( thing ) ) && isFinite( thing );
	};

	/* config/defaults/interpolators.js */
	var interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {

		var interpolators, interpolate, cssLengthPattern;
		circular.push( function() {
			interpolate = circular.interpolate;
		} );
		cssLengthPattern = /^([+-]?[0-9]+\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;
		interpolators = {
			number: function( from, to ) {
				var delta;
				if ( !isNumeric( from ) || !isNumeric( to ) ) {
					return null;
				}
				from = +from;
				to = +to;
				delta = to - from;
				if ( !delta ) {
					return function() {
						return from;
					};
				}
				return function( t ) {
					return from + t * delta;
				};
			},
			array: function( from, to ) {
				var intermediate, interpolators, len, i;
				if ( !isArray( from ) || !isArray( to ) ) {
					return null;
				}
				intermediate = [];
				interpolators = [];
				i = len = Math.min( from.length, to.length );
				while ( i-- ) {
					interpolators[ i ] = interpolate( from[ i ], to[ i ] );
				}
				// surplus values - don't interpolate, but don't exclude them either
				for ( i = len; i < from.length; i += 1 ) {
					intermediate[ i ] = from[ i ];
				}
				for ( i = len; i < to.length; i += 1 ) {
					intermediate[ i ] = to[ i ];
				}
				return function( t ) {
					var i = len;
					while ( i-- ) {
						intermediate[ i ] = interpolators[ i ]( t );
					}
					return intermediate;
				};
			},
			object: function( from, to ) {
				var properties, len, interpolators, intermediate, prop;
				if ( !isObject( from ) || !isObject( to ) ) {
					return null;
				}
				properties = [];
				intermediate = {};
				interpolators = {};
				for ( prop in from ) {
					if ( hasOwnProperty.call( from, prop ) ) {
						if ( hasOwnProperty.call( to, prop ) ) {
							properties.push( prop );
							interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );
						} else {
							intermediate[ prop ] = from[ prop ];
						}
					}
				}
				for ( prop in to ) {
					if ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {
						intermediate[ prop ] = to[ prop ];
					}
				}
				len = properties.length;
				return function( t ) {
					var i = len,
						prop;
					while ( i-- ) {
						prop = properties[ i ];
						intermediate[ prop ] = interpolators[ prop ]( t );
					}
					return intermediate;
				};
			},
			cssLength: function( from, to ) {
				var fromMatch, toMatch, fromUnit, toUnit, fromValue, toValue, unit, delta;
				if ( from !== 0 && typeof from !== 'string' || to !== 0 && typeof to !== 'string' ) {
					return null;
				}
				fromMatch = cssLengthPattern.exec( from );
				toMatch = cssLengthPattern.exec( to );
				fromUnit = fromMatch ? fromMatch[ 2 ] : '';
				toUnit = toMatch ? toMatch[ 2 ] : '';
				if ( fromUnit && toUnit && fromUnit !== toUnit ) {
					return null;
				}
				unit = fromUnit || toUnit;
				fromValue = fromMatch ? +fromMatch[ 1 ] : 0;
				toValue = toMatch ? +toMatch[ 1 ] : 0;
				delta = toValue - fromValue;
				if ( !delta ) {
					return function() {
						return fromValue + unit;
					};
				}
				return function( t ) {
					return fromValue + t * delta + unit;
				};
			}
		};
		return interpolators;
	}( circular, hasOwn, isArray, isObject, isNumeric );

	/* config/svg.js */
	var svg = function() {

		var svg;
		if ( typeof document === 'undefined' ) {
			svg = false;
		} else {
			svg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );
		}
		return svg;
	}();

	/* utils/removeFromArray.js */
	var removeFromArray = function( array, member ) {
		var index = array.indexOf( member );
		if ( index !== -1 ) {
			array.splice( index, 1 );
		}
	};

	/* utils/Promise.js */
	var Promise = function() {

		var _Promise, PENDING = {},
			FULFILLED = {},
			REJECTED = {};
		if ( typeof Promise === 'function' ) {
			// use native Promise
			_Promise = Promise;
		} else {
			_Promise = function( callback ) {
				var fulfilledHandlers = [],
					rejectedHandlers = [],
					state = PENDING,
					result, dispatchHandlers, makeResolver, fulfil, reject, promise;
				makeResolver = function( newState ) {
					return function( value ) {
						if ( state !== PENDING ) {
							return;
						}
						result = value;
						state = newState;
						dispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );
						// dispatch onFulfilled and onRejected handlers asynchronously
						wait( dispatchHandlers );
					};
				};
				fulfil = makeResolver( FULFILLED );
				reject = makeResolver( REJECTED );
				try {
					callback( fulfil, reject );
				} catch ( err ) {
					reject( err );
				}
				promise = {
					// `then()` returns a Promise - 2.2.7
					then: function( onFulfilled, onRejected ) {
						var promise2 = new _Promise( function( fulfil, reject ) {
							var processResolutionHandler = function( handler, handlers, forward ) {
								// 2.2.1.1
								if ( typeof handler === 'function' ) {
									handlers.push( function( p1result ) {
										var x;
										try {
											x = handler( p1result );
											resolve( promise2, x, fulfil, reject );
										} catch ( err ) {
											reject( err );
										}
									} );
								} else {
									// Forward the result of promise1 to promise2, if resolution handlers
									// are not given
									handlers.push( forward );
								}
							};
							// 2.2
							processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
							processResolutionHandler( onRejected, rejectedHandlers, reject );
							if ( state !== PENDING ) {
								// If the promise has resolved already, dispatch the appropriate handlers asynchronously
								wait( dispatchHandlers );
							}
						} );
						return promise2;
					}
				};
				promise[ 'catch' ] = function( onRejected ) {
					return this.then( null, onRejected );
				};
				return promise;
			};
			_Promise.all = function( promises ) {
				return new _Promise( function( fulfil, reject ) {
					var result = [],
						pending, i, processPromise;
					if ( !promises.length ) {
						fulfil( result );
						return;
					}
					processPromise = function( i ) {
						promises[ i ].then( function( value ) {
							result[ i ] = value;
							if ( !--pending ) {
								fulfil( result );
							}
						}, reject );
					};
					pending = i = promises.length;
					while ( i-- ) {
						processPromise( i );
					}
				} );
			};
			_Promise.resolve = function( value ) {
				return new _Promise( function( fulfil ) {
					fulfil( value );
				} );
			};
			_Promise.reject = function( reason ) {
				return new _Promise( function( fulfil, reject ) {
					reject( reason );
				} );
			};
		}
		return _Promise;
		// TODO use MutationObservers or something to simulate setImmediate
		function wait( callback ) {
			setTimeout( callback, 0 );
		}

		function makeDispatcher( handlers, result ) {
			return function() {
				var handler;
				while ( handler = handlers.shift() ) {
					handler( result );
				}
			};
		}

		function resolve( promise, x, fulfil, reject ) {
			// Promise Resolution Procedure
			var then;
			// 2.3.1
			if ( x === promise ) {
				throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
			}
			// 2.3.2
			if ( x instanceof _Promise ) {
				x.then( fulfil, reject );
			} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
				try {
					then = x.then;
				} catch ( e ) {
					reject( e );
					// 2.3.3.2
					return;
				}
				// 2.3.3.3
				if ( typeof then === 'function' ) {
					var called, resolvePromise, rejectPromise;
					resolvePromise = function( y ) {
						if ( called ) {
							return;
						}
						called = true;
						resolve( promise, y, fulfil, reject );
					};
					rejectPromise = function( r ) {
						if ( called ) {
							return;
						}
						called = true;
						reject( r );
					};
					try {
						then.call( x, resolvePromise, rejectPromise );
					} catch ( e ) {
						if ( !called ) {
							// 2.3.3.3.4.1
							reject( e );
							// 2.3.3.3.4.2
							called = true;
							return;
						}
					}
				} else {
					fulfil( x );
				}
			} else {
				fulfil( x );
			}
		}
	}();

	/* utils/normaliseRef.js */
	var normaliseRef = function() {

		var regex = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
		return function normaliseRef( ref ) {
			return ( ref || '' ).replace( regex, '.$1' );
		};
	}();

	/* shared/getInnerContext.js */
	var getInnerContext = function( fragment ) {
		do {
			if ( fragment.context ) {
				return fragment.context;
			}
		} while ( fragment = fragment.parent );
		return '';
	};

	/* utils/isEqual.js */
	var isEqual = function( a, b ) {
		if ( a === null && b === null ) {
			return true;
		}
		if ( typeof a === 'object' || typeof b === 'object' ) {
			return false;
		}
		return a === b;
	};

	/* shared/createComponentBinding.js */
	var createComponentBinding = function( circular, isArray, isEqual ) {

		var runloop;
		circular.push( function() {
			return runloop = circular.runloop;
		} );
		var Binding = function( ractive, keypath, otherInstance, otherKeypath, priority ) {
			this.root = ractive;
			this.keypath = keypath;
			this.priority = priority;
			this.otherInstance = otherInstance;
			this.otherKeypath = otherKeypath;
			this.bind();
			this.value = this.root.viewmodel.get( this.keypath );
		};
		Binding.prototype = {
			setValue: function( value ) {
				var this$0 = this;
				// Only *you* can prevent infinite loops
				if ( this.updating || this.counterpart && this.counterpart.updating ) {
					this.value = value;
					return;
				}
				// Is this a smart array update? If so, it'll update on its
				// own, we shouldn't do anything
				if ( isArray( value ) && value._ractive && value._ractive.setting ) {
					return;
				}
				if ( !isEqual( value, this.value ) ) {
					this.updating = true;
					// TODO maybe the case that `value === this.value` - should that result
					// in an update rather than a set?
					runloop.addViewmodel( this.otherInstance.viewmodel );
					this.otherInstance.viewmodel.set( this.otherKeypath, value );
					this.value = value;
					// TODO will the counterpart update after this line, during
					// the runloop end cycle? may be a problem...
					runloop.scheduleTask( function() {
						return this$0.updating = false;
					} );
				}
			},
			bind: function() {
				this.root.viewmodel.register( this.keypath, this );
			},
			rebind: function( newKeypath ) {
				this.unbind();
				this.keypath = newKeypath;
				this.counterpart.otherKeypath = newKeypath;
				this.bind();
			},
			unbind: function() {
				this.root.viewmodel.unregister( this.keypath, this );
			}
		};
		return function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {
			var hash, childInstance, bindings, priority, parentToChildBinding, childToParentBinding;
			hash = parentKeypath + '=' + childKeypath;
			bindings = component.bindings;
			if ( bindings[ hash ] ) {
				// TODO does this ever happen?
				return;
			}
			bindings[ hash ] = true;
			childInstance = component.instance;
			priority = component.parentFragment.priority;
			parentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath, priority );
			bindings.push( parentToChildBinding );
			if ( childInstance.twoway ) {
				childToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath, 1 );
				bindings.push( childToParentBinding );
				parentToChildBinding.counterpart = childToParentBinding;
				childToParentBinding.counterpart = parentToChildBinding;
			}
		};
	}( circular, isArray, isEqual );

	/* shared/resolveRef.js */
	var resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {

		var ancestorErrorMessage, getOptions;
		ancestorErrorMessage = 'Could not resolve reference - too many "../" prefixes';
		getOptions = {
			evaluateWrapped: true
		};
		return function resolveRef( ractive, ref, fragment ) {
			var context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;
			ref = normaliseRef( ref );
			// If a reference begins '~/', it's a top-level reference
			if ( ref.substr( 0, 2 ) === '~/' ) {
				return ref.substring( 2 );
			}
			// If a reference begins with '.', it's either a restricted reference or
			// an ancestor reference...
			if ( ref.charAt( 0 ) === '.' ) {
				return resolveAncestorReference( getInnerContext( fragment ), ref );
			}
			// ...otherwise we need to find the keypath
			key = ref.split( '.' )[ 0 ];
			do {
				context = fragment.context;
				if ( !context ) {
					continue;
				}
				hasContextChain = true;
				parentValue = ractive.viewmodel.get( context, getOptions );
				if ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {
					return context + '.' + ref;
				}
			} while ( fragment = fragment.parent );
			// Root/computed property?
			if ( key in ractive.data || key in ractive.viewmodel.computations ) {
				return ref;
			}
			// If this is an inline component, and it's not isolated, we
			// can try going up the scope chain
			if ( ractive._parent && !ractive.isolated ) {
				fragment = ractive.component.parentFragment;
				// Special case - index refs
				if ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {
					// Create an index ref binding, so that it can be rebound letter if necessary.
					// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`
					ractive.component.indexRefBindings[ ref ] = ref;
					ractive.viewmodel.set( ref, index, true );
					return;
				}
				keypath = resolveRef( ractive._parent, ref, fragment );
				if ( keypath ) {
					// We need to create an inter-component binding
					// If parent keypath is 'one.foo' and child is 'two.foo', we bind
					// 'one' to 'two' as it's more efficient and avoids edge cases
					parentKeys = keypath.split( '.' );
					childKeys = ref.split( '.' );
					while ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {
						parentKeys.pop();
						childKeys.pop();
					}
					parentKeypath = parentKeys.join( '.' );
					childKeypath = childKeys.join( '.' );
					ractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );
					createComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );
					return ref;
				}
			}
			// If there's no context chain, and the instance is either a) isolated or
			// b) an orphan, then we know that the keypath is identical to the reference
			if ( !hasContextChain ) {
				return ref;
			}
			if ( ractive.viewmodel.get( ref ) !== undefined ) {
				return ref;
			}
		};

		function resolveAncestorReference( baseContext, ref ) {
			var contextKeys;
			// {{.}} means 'current context'
			if ( ref === '.' )
				return baseContext;
			contextKeys = baseContext ? baseContext.split( '.' ) : [];
			// ancestor references (starting "../") go up the tree
			if ( ref.substr( 0, 3 ) === '../' ) {
				while ( ref.substr( 0, 3 ) === '../' ) {
					if ( !contextKeys.length ) {
						throw new Error( ancestorErrorMessage );
					}
					contextKeys.pop();
					ref = ref.substring( 3 );
				}
				contextKeys.push( ref );
				return contextKeys.join( '.' );
			}
			// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
			if ( !baseContext ) {
				return ref.replace( /^\.\/?/, '' );
			}
			return baseContext + ref.replace( /^\.\//, '.' );
		}
	}( normaliseRef, getInnerContext, createComponentBinding );

	/* global/TransitionManager.js */
	var TransitionManager = function( removeFromArray ) {

		var TransitionManager = function( callback, parent ) {
			this.callback = callback;
			this.parent = parent;
			this.intros = [];
			this.outros = [];
			this.children = [];
			this.totalChildren = this.outroChildren = 0;
			this.detachQueue = [];
			this.outrosComplete = false;
			if ( parent ) {
				parent.addChild( this );
			}
		};
		TransitionManager.prototype = {
			addChild: function( child ) {
				this.children.push( child );
				this.totalChildren += 1;
				this.outroChildren += 1;
			},
			decrementOutros: function() {
				this.outroChildren -= 1;
				check( this );
			},
			decrementTotal: function() {
				this.totalChildren -= 1;
				check( this );
			},
			add: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				list.push( transition );
			},
			remove: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				removeFromArray( list, transition );
				check( this );
			},
			init: function() {
				this.ready = true;
				check( this );
			},
			detachNodes: function() {
				this.detachQueue.forEach( detach );
				this.children.forEach( detachNodes );
			}
		};

		function detach( element ) {
			element.detach();
		}

		function detachNodes( tm ) {
			tm.detachNodes();
		}

		function check( tm ) {
			if ( !tm.ready || tm.outros.length || tm.outroChildren )
				return;
			// If all outros are complete, and we haven't already done this,
			// we notify the parent if there is one, otherwise
			// start detaching nodes
			if ( !tm.outrosComplete ) {
				if ( tm.parent ) {
					tm.parent.decrementOutros( tm );
				} else {
					tm.detachNodes();
				}
				tm.outrosComplete = true;
			}
			// Once everything is done, we can notify parent transition
			// manager and call the callback
			if ( !tm.intros.length && !tm.totalChildren ) {
				if ( typeof tm.callback === 'function' ) {
					tm.callback();
				}
				if ( tm.parent ) {
					tm.parent.decrementTotal();
				}
			}
		}
		return TransitionManager;
	}( removeFromArray );

	/* global/runloop.js */
	var runloop = function( circular, removeFromArray, Promise, resolveRef, TransitionManager ) {

		var batch, runloop, unresolved = [];
		runloop = {
			start: function( instance, returnPromise ) {
				var promise, fulfilPromise;
				if ( returnPromise ) {
					promise = new Promise( function( f ) {
						return fulfilPromise = f;
					} );
				}
				batch = {
					previousBatch: batch,
					transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
					views: [],
					tasks: [],
					viewmodels: []
				};
				if ( instance ) {
					batch.viewmodels.push( instance.viewmodel );
				}
				return promise;
			},
			end: function() {
				flushChanges();
				batch.transitionManager.init();
				batch = batch.previousBatch;
			},
			addViewmodel: function( viewmodel ) {
				if ( batch ) {
					if ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {
						batch.viewmodels.push( viewmodel );
					}
				} else {
					viewmodel.applyChanges();
				}
			},
			registerTransition: function( transition ) {
				transition._manager = batch.transitionManager;
				batch.transitionManager.add( transition );
			},
			addView: function( view ) {
				batch.views.push( view );
			},
			addUnresolved: function( thing ) {
				unresolved.push( thing );
			},
			removeUnresolved: function( thing ) {
				removeFromArray( unresolved, thing );
			},
			// synchronise node detachments with transition ends
			detachWhenReady: function( thing ) {
				batch.transitionManager.detachQueue.push( thing );
			},
			scheduleTask: function( task ) {
				if ( !batch ) {
					task();
				} else {
					batch.tasks.push( task );
				}
			}
		};
		circular.runloop = runloop;
		return runloop;

		function flushChanges() {
			var i, thing, changeHash;
			for ( i = 0; i < batch.viewmodels.length; i += 1 ) {
				thing = batch.viewmodels[ i ];
				changeHash = thing.applyChanges();
				if ( changeHash ) {
					thing.ractive.fire( 'change', changeHash );
				}
			}
			batch.viewmodels.length = 0;
			attemptKeypathResolution();
			// Now that changes have been fully propagated, we can update the DOM
			// and complete other tasks
			for ( i = 0; i < batch.views.length; i += 1 ) {
				batch.views[ i ].update();
			}
			batch.views.length = 0;
			for ( i = 0; i < batch.tasks.length; i += 1 ) {
				batch.tasks[ i ]();
			}
			batch.tasks.length = 0;
			// If updating the view caused some model blowback - e.g. a triple
			// containing <option> elements caused the binding on the <select>
			// to update - then we start over
			if ( batch.viewmodels.length )
				return flushChanges();
		}

		function attemptKeypathResolution() {
			var array, thing, keypath;
			if ( !unresolved.length ) {
				return;
			}
			// see if we can resolve any unresolved references
			array = unresolved.splice( 0, unresolved.length );
			while ( thing = array.pop() ) {
				if ( thing.keypath ) {
					continue;
				}
				keypath = resolveRef( thing.root, thing.ref, thing.parentFragment );
				if ( keypath !== undefined ) {
					// If we've resolved the keypath, we can initialise this item
					thing.resolve( keypath );
				} else {
					// If we can't resolve the reference, try again next time
					unresolved.push( thing );
				}
			}
		}
	}( circular, removeFromArray, Promise, resolveRef, TransitionManager );

	/* utils/createBranch.js */
	var createBranch = function() {

		var numeric = /^\s*[0-9]+\s*$/;
		return function( key ) {
			return numeric.test( key ) ? [] : {};
		};
	}();

	/* viewmodel/prototype/get/magicAdaptor.js */
	var viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {

		var magicAdaptor, MagicWrapper;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			magicAdaptor = {
				filter: function( object, keypath, ractive ) {
					var keys, key, parentKeypath, parentWrapper, parentValue;
					if ( !keypath ) {
						return false;
					}
					keys = keypath.split( '.' );
					key = keys.pop();
					parentKeypath = keys.join( '.' );
					// If the parent value is a wrapper, other than a magic wrapper,
					// we shouldn't wrap this property
					if ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {
						return false;
					}
					parentValue = ractive.get( parentKeypath );
					// if parentValue is an array that doesn't include this member,
					// we should return false otherwise lengths will get messed up
					if ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {
						return false;
					}
					return parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );
				},
				wrap: function( ractive, property, keypath ) {
					return new MagicWrapper( ractive, property, keypath );
				}
			};
			MagicWrapper = function( ractive, value, keypath ) {
				var keys, objKeypath, template, siblings;
				this.magic = true;
				this.ractive = ractive;
				this.keypath = keypath;
				this.value = value;
				keys = keypath.split( '.' );
				this.prop = keys.pop();
				objKeypath = keys.join( '.' );
				this.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;
				template = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );
				// Has this property already been wrapped?
				if ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {
					// Yes. Register this wrapper to this property, if it hasn't been already
					if ( siblings.indexOf( this ) === -1 ) {
						siblings.push( this );
					}
					return;
				}
				// No, it hasn't been wrapped
				createAccessors( this, value, template );
			};
			MagicWrapper.prototype = {
				get: function() {
					return this.value;
				},
				reset: function( value ) {
					if ( this.updating ) {
						return;
					}
					this.updating = true;
					this.obj[ this.prop ] = value;
					// trigger set() accessor
					runloop.addViewmodel( this.ractive.viewmodel );
					this.ractive.viewmodel.mark( this.keypath );
					this.updating = false;
				},
				set: function( key, value ) {
					if ( this.updating ) {
						return;
					}
					if ( !this.obj[ this.prop ] ) {
						this.updating = true;
						this.obj[ this.prop ] = createBranch( key );
						this.updating = false;
					}
					this.obj[ this.prop ][ key ] = value;
				},
				teardown: function() {
					var template, set, value, wrappers, index;
					// If this method was called because the cache was being cleared as a
					// result of a set()/update() call made by this wrapper, we return false
					// so that it doesn't get torn down
					if ( this.updating ) {
						return false;
					}
					template = Object.getOwnPropertyDescriptor( this.obj, this.prop );
					set = template && template.set;
					if ( !set ) {
						// most likely, this was an array member that was spliced out
						return;
					}
					wrappers = set._ractiveWrappers;
					index = wrappers.indexOf( this );
					if ( index !== -1 ) {
						wrappers.splice( index, 1 );
					}
					// Last one out, turn off the lights
					if ( !wrappers.length ) {
						value = this.obj[ this.prop ];
						Object.defineProperty( this.obj, this.prop, this.originalDescriptor || {
							writable: true,
							enumerable: true,
							configurable: true
						} );
						this.obj[ this.prop ] = value;
					}
				}
			};
		} catch ( err ) {
			magicAdaptor = false;
		}
		return magicAdaptor;

		function createAccessors( originalWrapper, value, template ) {
			var object, property, oldGet, oldSet, get, set;
			object = originalWrapper.obj;
			property = originalWrapper.prop;
			// Is this template configurable?
			if ( template && !template.configurable ) {
				// Special case - array length
				if ( property === 'length' ) {
					return;
				}
				throw new Error( 'Cannot use magic mode with property "' + property + '" - object is not configurable' );
			}
			// Time to wrap this property
			if ( template ) {
				oldGet = template.get;
				oldSet = template.set;
			}
			get = oldGet || function() {
				return value;
			};
			set = function( v ) {
				if ( oldSet ) {
					oldSet( v );
				}
				value = oldGet ? oldGet() : v;
				set._ractiveWrappers.forEach( updateWrapper );
			};

			function updateWrapper( wrapper ) {
				var keypath, ractive;
				wrapper.value = value;
				if ( wrapper.updating ) {
					return;
				}
				ractive = wrapper.ractive;
				keypath = wrapper.keypath;
				wrapper.updating = true;
				runloop.start( ractive );
				ractive.viewmodel.mark( keypath );
				runloop.end();
				wrapper.updating = false;
			}
			// Create an array of wrappers, in case other keypaths/ractives depend on this property.
			// Handily, we can store them as a property of the set function. Yay JavaScript.
			set._ractiveWrappers = [ originalWrapper ];
			Object.defineProperty( object, property, {
				get: get,
				set: set,
				enumerable: true,
				configurable: true
			} );
		}
	}( runloop, createBranch, isArray );

	/* config/magic.js */
	var magic = function( magicAdaptor ) {

		return !!magicAdaptor;
	}( viewmodel$get_magicAdaptor );

	/* config/namespaces.js */
	var namespaces = {
		html: 'http://www.w3.org/1999/xhtml',
		mathml: 'http://www.w3.org/1998/Math/MathML',
		svg: 'http://www.w3.org/2000/svg',
		xlink: 'http://www.w3.org/1999/xlink',
		xml: 'http://www.w3.org/XML/1998/namespace',
		xmlns: 'http://www.w3.org/2000/xmlns/'
	};

	/* utils/createElement.js */
	var createElement = function( svg, namespaces ) {

		var createElement;
		// Test for SVG support
		if ( !svg ) {
			createElement = function( type, ns ) {
				if ( ns && ns !== namespaces.html ) {
					throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
				}
				return document.createElement( type );
			};
		} else {
			createElement = function( type, ns ) {
				if ( !ns || ns === namespaces.html ) {
					return document.createElement( type );
				}
				return document.createElementNS( ns, type );
			};
		}
		return createElement;
	}( svg, namespaces );

	/* config/isClient.js */
	var isClient = function() {

		var isClient = typeof document === 'object';
		return isClient;
	}();

	/* utils/defineProperty.js */
	var defineProperty = function( isClient ) {

		var defineProperty;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			if ( isClient ) {
				Object.defineProperty( document.createElement( 'div' ), 'test', {
					value: 0
				} );
			}
			defineProperty = Object.defineProperty;
		} catch ( err ) {
			// Object.defineProperty doesn't exist, or we're in IE8 where you can
			// only use it with DOM objects (what the fuck were you smoking, MSFT?)
			defineProperty = function( obj, prop, desc ) {
				obj[ prop ] = desc.value;
			};
		}
		return defineProperty;
	}( isClient );

	/* utils/defineProperties.js */
	var defineProperties = function( createElement, defineProperty, isClient ) {

		var defineProperties;
		try {
			try {
				Object.defineProperties( {}, {
					test: {
						value: 0
					}
				} );
			} catch ( err ) {
				// TODO how do we account for this? noMagic = true;
				throw err;
			}
			if ( isClient ) {
				Object.defineProperties( createElement( 'div' ), {
					test: {
						value: 0
					}
				} );
			}
			defineProperties = Object.defineProperties;
		} catch ( err ) {
			defineProperties = function( obj, props ) {
				var prop;
				for ( prop in props ) {
					if ( props.hasOwnProperty( prop ) ) {
						defineProperty( obj, prop, props[ prop ] );
					}
				}
			};
		}
		return defineProperties;
	}( createElement, defineProperty, isClient );

	/* Ractive/prototype/shared/add.js */
	var Ractive$shared_add = function( isNumeric ) {

		return function add( root, keypath, d ) {
			var value;
			if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
				throw new Error( 'Bad arguments' );
			}
			value = +root.get( keypath ) || 0;
			if ( !isNumeric( value ) ) {
				throw new Error( 'Cannot add to a non-numeric value' );
			}
			return root.set( keypath, value + d );
		};
	}( isNumeric );

	/* Ractive/prototype/add.js */
	var Ractive$add = function( add ) {

		return function Ractive$add( keypath, d ) {
			return add( this, keypath, d === undefined ? 1 : +d );
		};
	}( Ractive$shared_add );

	/* utils/normaliseKeypath.js */
	var normaliseKeypath = function( normaliseRef ) {

		var leadingDot = /^\.+/;
		return function normaliseKeypath( keypath ) {
			return normaliseRef( keypath ).replace( leadingDot, '' );
		};
	}( normaliseRef );

	/* config/vendors.js */
	var vendors = [
		'o',
		'ms',
		'moz',
		'webkit'
	];

	/* utils/requestAnimationFrame.js */
	var requestAnimationFrame = function( vendors ) {

		var requestAnimationFrame;
		// If window doesn't exist, we don't need requestAnimationFrame
		if ( typeof window === 'undefined' ) {
			requestAnimationFrame = null;
		} else {
			// https://gist.github.com/paulirish/1579671
			( function( vendors, lastTime, window ) {
				var x, setTimeout;
				if ( window.requestAnimationFrame ) {
					return;
				}
				for ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
					window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
				}
				if ( !window.requestAnimationFrame ) {
					setTimeout = window.setTimeout;
					window.requestAnimationFrame = function( callback ) {
						var currTime, timeToCall, id;
						currTime = Date.now();
						timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
						id = setTimeout( function() {
							callback( currTime + timeToCall );
						}, timeToCall );
						lastTime = currTime + timeToCall;
						return id;
					};
				}
			}( vendors, 0, window ) );
			requestAnimationFrame = window.requestAnimationFrame;
		}
		return requestAnimationFrame;
	}( vendors );

	/* utils/getTime.js */
	var getTime = function() {

		var getTime;
		if ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {
			getTime = function() {
				return window.performance.now();
			};
		} else {
			getTime = function() {
				return Date.now();
			};
		}
		return getTime;
	}();

	/* shared/animations.js */
	var animations = function( rAF, getTime, runloop ) {

		var queue = [];
		var animations = {
			tick: function() {
				var i, animation, now;
				now = getTime();
				runloop.start();
				for ( i = 0; i < queue.length; i += 1 ) {
					animation = queue[ i ];
					if ( !animation.tick( now ) ) {
						// animation is complete, remove it from the stack, and decrement i so we don't miss one
						queue.splice( i--, 1 );
					}
				}
				runloop.end();
				if ( queue.length ) {
					rAF( animations.tick );
				} else {
					animations.running = false;
				}
			},
			add: function( animation ) {
				queue.push( animation );
				if ( !animations.running ) {
					animations.running = true;
					rAF( animations.tick );
				}
			},
			// TODO optimise this
			abort: function( keypath, root ) {
				var i = queue.length,
					animation;
				while ( i-- ) {
					animation = queue[ i ];
					if ( animation.root === root && animation.keypath === keypath ) {
						animation.stop();
					}
				}
			}
		};
		return animations;
	}( requestAnimationFrame, getTime, runloop );

	/* utils/warn.js */
	var warn = function() {

		/* global console */
		var warn, warned = {};
		if ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {
			warn = function( message, allowDuplicates ) {
				if ( !allowDuplicates ) {
					if ( warned[ message ] ) {
						return;
					}
					warned[ message ] = true;
				}
				console.warn( message );
			};
		} else {
			warn = function() {};
		}
		return warn;
	}();

	/* config/options/css/transform.js */
	var transform = function() {

		var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
			commentsPattern = /\/\*.*?\*\//g,
			selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~]+)?\s*[\s\+\>\~]?)\s*/g,
			mediaQueryPattern = /^@media/,
			dataRvcGuidPattern = /\[data-rvcguid="[a-z0-9-]+"]/g;
		return function transformCss( css, guid ) {
			var transformed, addGuid;
			addGuid = function( selector ) {
				var selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];
				selectorUnits = [];
				while ( match = selectorUnitPattern.exec( selector ) ) {
					selectorUnits.push( {
						str: match[ 0 ],
						base: match[ 1 ],
						modifiers: match[ 2 ]
					} );
				}
				// For each simple selector within the selector, we need to create a version
				// that a) combines with the guid, and b) is inside the guid
				dataAttr = '[data-rvcguid="' + guid + '"]';
				base = selectorUnits.map( extractString );
				i = selectorUnits.length;
				while ( i-- ) {
					appended = base.slice();
					// Pseudo-selectors should go after the attribute selector
					unit = selectorUnits[ i ];
					appended[ i ] = unit.base + dataAttr + unit.modifiers || '';
					prepended = base.slice();
					prepended[ i ] = dataAttr + ' ' + prepended[ i ];
					transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
				}
				return transformed.join( ', ' );
			};
			if ( dataRvcGuidPattern.test( css ) ) {
				transformed = css.replace( dataRvcGuidPattern, '[data-rvcguid="' + guid + '"]' );
			} else {
				transformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {
					var selectors, transformed;
					// don't transform media queries!
					if ( mediaQueryPattern.test( $1 ) )
						return match;
					selectors = $1.split( ',' ).map( trim );
					transformed = selectors.map( addGuid ).join( ', ' ) + ' ';
					return match.replace( $1, transformed );
				} );
			}
			return transformed;
		};

		function trim( str ) {
			if ( str.trim ) {
				return str.trim();
			}
			return str.replace( /^\s+/, '' ).replace( /\s+$/, '' );
		}

		function extractString( unit ) {
			return unit.str;
		}
	}();

	/* config/options/css/css.js */
	var css = function( transformCss ) {

		var cssConfig = {
			name: 'css',
			extend: extend,
			init: function() {}
		};

		function extend( Parent, proto, options ) {
			var guid = proto.constructor._guid,
				css;
			if ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {
				proto.constructor.css = css;
			}
		}

		function getCss( css, target, guid ) {
			if ( !css ) {
				return;
			}
			return target.noCssTransform ? css : transformCss( css, guid );
		}
		return cssConfig;
	}( transform );

	/* utils/wrapMethod.js */
	var wrapMethod = function() {

		return function( method, superMethod, force ) {
			if ( force || needsSuper( method, superMethod ) ) {
				return function() {
					var hasSuper = '_super' in this,
						_super = this._super,
						result;
					this._super = superMethod;
					result = method.apply( this, arguments );
					if ( hasSuper ) {
						this._super = _super;
					}
					return result;
				};
			} else {
				return method;
			}
		};

		function needsSuper( method, superMethod ) {
			return typeof superMethod === 'function' && /_super/.test( method );
		}
	}();

	/* config/options/data.js */
	var data = function( wrap ) {

		var dataConfig = {
			name: 'data',
			extend: extend,
			init: init,
			reset: reset
		};
		return dataConfig;

		function combine( Parent, target, options ) {
			var value = options.data || {},
				parentValue = getAddedKeys( Parent.prototype.data );
			return dispatch( parentValue, value );
		}

		function extend( Parent, proto, options ) {
			proto.data = combine( Parent, proto, options );
		}

		function init( Parent, ractive, options ) {
			var value = options.data,
				result = combine( Parent, ractive, options );
			if ( typeof result === 'function' ) {
				result = result.call( ractive, value ) || value;
			}
			return ractive.data = result || {};
		}

		function reset( ractive ) {
			var result = this.init( ractive.constructor, ractive, ractive );
			if ( result ) {
				ractive.data = result;
				return true;
			}
		}

		function getAddedKeys( parent ) {
			// only for functions that had keys added
			if ( typeof parent !== 'function' || !Object.keys( parent ).length ) {
				return parent;
			}
			// copy the added keys to temp 'object', otherwise
			// parent would be interpreted as 'function' by dispatch
			var temp = {};
			copy( parent, temp );
			// roll in added keys
			return dispatch( parent, temp );
		}

		function dispatch( parent, child ) {
			if ( typeof child === 'function' ) {
				return extendFn( child, parent );
			} else if ( typeof parent === 'function' ) {
				return fromFn( child, parent );
			} else {
				return fromProperties( child, parent );
			}
		}

		function copy( from, to, fillOnly ) {
			for ( var key in from ) {
				if ( fillOnly && key in to ) {
					continue;
				}
				to[ key ] = from[ key ];
			}
		}

		function fromProperties( child, parent ) {
			child = child || {};
			if ( !parent ) {
				return child;
			}
			copy( parent, child, true );
			return child;
		}

		function fromFn( child, parentFn ) {
			return function( data ) {
				var keys;
				if ( child ) {
					// Track the keys that our on the child,
					// but not on the data. We'll need to apply these
					// after the parent function returns.
					keys = [];
					for ( var key in child ) {
						if ( !data || !( key in data ) ) {
							keys.push( key );
						}
					}
				}
				// call the parent fn, use data if no return value
				data = parentFn.call( this, data ) || data;
				// Copy child keys back onto data. The child keys
				// should take precedence over whatever the
				// parent did with the data.
				if ( keys && keys.length ) {
					data = data || {};
					keys.forEach( function( key ) {
						data[ key ] = child[ key ];
					} );
				}
				return data;
			};
		}

		function extendFn( childFn, parent ) {
			var parentFn;
			if ( typeof parent !== 'function' ) {
				// copy props to data
				parentFn = function( data ) {
					fromProperties( data, parent );
				};
			} else {
				parentFn = function( data ) {
					// give parent function it's own this._super context,
					// otherwise this._super is from child and
					// causes infinite loop
					parent = wrap( parent, function() {}, true );
					return parent.call( this, data ) || data;
				};
			}
			return wrap( childFn, parentFn );
		}
	}( wrapMethod );

	/* config/errors.js */
	var errors = {
		missingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',
		mergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',
		noComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',
		noTemplateForPartial: 'Could not find template for partial "{name}"',
		noNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',
		evaluationError: 'Error evaluating "{uniqueString}": {err}',
		badArguments: 'Bad arguments "{arguments}". I\'m not allowed to argue unless you\'ve paid.',
		failedComputation: 'Failed to compute "{key}": {err}',
		missingPlugin: 'Missing "{name}" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',
		badRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
		noRegistryFunctionReturn: 'A function was specified for "{name}" {registry}, but no {registry} was returned'
	};

	/* config/types.js */
	var types = {
		TEXT: 1,
		INTERPOLATOR: 2,
		TRIPLE: 3,
		SECTION: 4,
		INVERTED: 5,
		CLOSING: 6,
		ELEMENT: 7,
		PARTIAL: 8,
		COMMENT: 9,
		DELIMCHANGE: 10,
		MUSTACHE: 11,
		TAG: 12,
		ATTRIBUTE: 13,
		CLOSING_TAG: 14,
		COMPONENT: 15,
		NUMBER_LITERAL: 20,
		STRING_LITERAL: 21,
		ARRAY_LITERAL: 22,
		OBJECT_LITERAL: 23,
		BOOLEAN_LITERAL: 24,
		GLOBAL: 26,
		KEY_VALUE_PAIR: 27,
		REFERENCE: 30,
		REFINEMENT: 31,
		MEMBER: 32,
		PREFIX_OPERATOR: 33,
		BRACKETED: 34,
		CONDITIONAL: 35,
		INFIX_OPERATOR: 36,
		INVOCATION: 40,
		SECTION_IF: 50,
		SECTION_UNLESS: 51,
		SECTION_EACH: 52,
		SECTION_WITH: 53
	};

	/* utils/create.js */
	var create = function() {

		var create;
		try {
			Object.create( null );
			create = Object.create;
		} catch ( err ) {
			// sigh
			create = function() {
				var F = function() {};
				return function( proto, props ) {
					var obj;
					if ( proto === null ) {
						return {};
					}
					F.prototype = proto;
					obj = new F();
					if ( props ) {
						Object.defineProperties( obj, props );
					}
					return obj;
				};
			}();
		}
		return create;
	}();

	/* parse/Parser/expressions/shared/errors.js */
	var parse_Parser_expressions_shared_errors = {
		expectedExpression: 'Expected a JavaScript expression',
		expectedParen: 'Expected closing paren'
	};

	/* parse/Parser/expressions/primary/literal/numberLiteral.js */
	var numberLiteral = function( types ) {

		// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330
		var numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		return function( parser ) {
			var result;
			if ( result = parser.matchPattern( numberPattern ) ) {
				return {
					t: types.NUMBER_LITERAL,
					v: result
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/booleanLiteral.js */
	var booleanLiteral = function( types ) {

		return function( parser ) {
			var remaining = parser.remaining();
			if ( remaining.substr( 0, 4 ) === 'true' ) {
				parser.pos += 4;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'true'
				};
			}
			if ( remaining.substr( 0, 5 ) === 'false' ) {
				parser.pos += 5;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'false'
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */
	var makeQuotedStringMatcher = function() {

		var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;
		// Match one or more characters until: ", ', \, or EOL/EOF.
		// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
		stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
		// Match one escape sequence, including the backslash.
		escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
		// Match one ES5 line continuation (backslash + line terminator).
		lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
		// Helper for defining getDoubleQuotedString and getSingleQuotedString.
		return function( okQuote ) {
			return function( parser ) {
				var start, literal, done, next;
				start = parser.pos;
				literal = '"';
				done = false;
				while ( !done ) {
					next = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );
					if ( next ) {
						if ( next === '"' ) {
							literal += '\\"';
						} else if ( next === '\\\'' ) {
							literal += '\'';
						} else {
							literal += next;
						}
					} else {
						next = parser.matchPattern( lineContinuationPattern );
						if ( next ) {
							// convert \(newline-like) into a \u escape, which is allowed in JSON
							literal += '\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );
						} else {
							done = true;
						}
					}
				}
				literal += '"';
				// use JSON.parse to interpret escapes
				return JSON.parse( literal );
			};
		};
	}();

	/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */
	var singleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '"' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */
	var doubleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '\'' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */
	var stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {

		return function( parser ) {
			var start, string;
			start = parser.pos;
			if ( parser.matchString( '"' ) ) {
				string = getDoubleQuotedString( parser );
				if ( !parser.matchString( '"' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			if ( parser.matchString( '\'' ) ) {
				string = getSingleQuotedString( parser );
				if ( !parser.matchString( '\'' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			return null;
		};
	}( types, singleQuotedString, doubleQuotedString );

	/* parse/Parser/expressions/shared/patterns.js */
	var patterns = {
		name: /^[a-zA-Z_$][a-zA-Z_$0-9]*/
	};

	/* parse/Parser/expressions/shared/key.js */
	var key = function( getStringLiteral, getNumberLiteral, patterns ) {

		var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		// http://mathiasbynens.be/notes/javascript-properties
		// can be any name, string literal, or number literal
		return function( parser ) {
			var token;
			if ( token = getStringLiteral( parser ) ) {
				return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
			}
			if ( token = getNumberLiteral( parser ) ) {
				return token.v;
			}
			if ( token = parser.matchPattern( patterns.name ) ) {
				return token;
			}
		};
	}( stringLiteral, numberLiteral, patterns );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */
	var keyValuePair = function( types, getKey ) {

		return function( parser ) {
			var start, key, value;
			start = parser.pos;
			// allow whitespace between '{' and key
			parser.allowWhitespace();
			key = getKey( parser );
			if ( key === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between key and ':'
			parser.allowWhitespace();
			// next character must be ':'
			if ( !parser.matchString( ':' ) ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between ':' and value
			parser.allowWhitespace();
			// next expression must be a, well... expression
			value = parser.readExpression();
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.KEY_VALUE_PAIR,
				k: key,
				v: value
			};
		};
	}( types, key );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */
	var keyValuePairs = function( getKeyValuePair ) {

		return function getKeyValuePairs( parser ) {
			var start, pairs, pair, keyValuePairs;
			start = parser.pos;
			pair = getKeyValuePair( parser );
			if ( pair === null ) {
				return null;
			}
			pairs = [ pair ];
			if ( parser.matchString( ',' ) ) {
				keyValuePairs = getKeyValuePairs( parser );
				if ( !keyValuePairs ) {
					parser.pos = start;
					return null;
				}
				return pairs.concat( keyValuePairs );
			}
			return pairs;
		};
	}( keyValuePair );

	/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */
	var objectLiteral = function( types, getKeyValuePairs ) {

		return function( parser ) {
			var start, keyValuePairs;
			start = parser.pos;
			// allow whitespace
			parser.allowWhitespace();
			if ( !parser.matchString( '{' ) ) {
				parser.pos = start;
				return null;
			}
			keyValuePairs = getKeyValuePairs( parser );
			// allow whitespace between final value and '}'
			parser.allowWhitespace();
			if ( !parser.matchString( '}' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.OBJECT_LITERAL,
				m: keyValuePairs
			};
		};
	}( types, keyValuePairs );

	/* parse/Parser/expressions/shared/expressionList.js */
	var expressionList = function( errors ) {

		return function getExpressionList( parser ) {
			var start, expressions, expr, next;
			start = parser.pos;
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( expr === null ) {
				return null;
			}
			expressions = [ expr ];
			// allow whitespace between expression and ','
			parser.allowWhitespace();
			if ( parser.matchString( ',' ) ) {
				next = getExpressionList( parser );
				if ( next === null ) {
					parser.error( errors.expectedExpression );
				}
				next.forEach( append );
			}

			function append( expression ) {
				expressions.push( expression );
			}
			return expressions;
		};
	}( parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/literal/arrayLiteral.js */
	var arrayLiteral = function( types, getExpressionList ) {

		return function( parser ) {
			var start, expressionList;
			start = parser.pos;
			// allow whitespace before '['
			parser.allowWhitespace();
			if ( !parser.matchString( '[' ) ) {
				parser.pos = start;
				return null;
			}
			expressionList = getExpressionList( parser );
			if ( !parser.matchString( ']' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.ARRAY_LITERAL,
				m: expressionList
			};
		};
	}( types, expressionList );

	/* parse/Parser/expressions/primary/literal/_literal.js */
	var literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {

		return function( parser ) {
			var literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );
			return literal;
		};
	}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );

	/* parse/Parser/expressions/primary/reference.js */
	var reference = function( types, patterns ) {

		var dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;
		dotRefinementPattern = /^\.[a-zA-Z_$0-9]+/;
		getArrayRefinement = function( parser ) {
			var num = parser.matchPattern( arrayMemberPattern );
			if ( num ) {
				return '.' + num;
			}
			return null;
		};
		arrayMemberPattern = /^\[(0|[1-9][0-9]*)\]/;
		// if a reference is a browser global, we don't deference it later, so it needs special treatment
		globals = /^(?:Array|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;
		// keywords are not valid references, with the exception of `this`
		keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
		return function( parser ) {
			var startPos, ancestor, name, dot, combo, refinement, lastDotIndex;
			startPos = parser.pos;
			// we might have a root-level reference
			if ( parser.matchString( '~/' ) ) {
				ancestor = '~/';
			} else {
				// we might have ancestor refs...
				ancestor = '';
				while ( parser.matchString( '../' ) ) {
					ancestor += '../';
				}
			}
			if ( !ancestor ) {
				// we might have an implicit iterator or a restricted reference
				dot = parser.matchString( '.' ) || '';
			}
			name = parser.matchPattern( /^@(?:index|key)/ ) || parser.matchPattern( patterns.name ) || '';
			// bug out if it's a keyword
			if ( keywords.test( name ) ) {
				parser.pos = startPos;
				return null;
			}
			// if this is a browser global, stop here
			if ( !ancestor && !dot && globals.test( name ) ) {
				return {
					t: types.GLOBAL,
					v: name
				};
			}
			combo = ( ancestor || dot ) + name;
			if ( !combo ) {
				return null;
			}
			while ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {
				combo += refinement;
			}
			if ( parser.matchString( '(' ) ) {
				// if this is a method invocation (as opposed to a function) we need
				// to strip the method name from the reference combo, else the context
				// will be wrong
				lastDotIndex = combo.lastIndexOf( '.' );
				if ( lastDotIndex !== -1 ) {
					combo = combo.substr( 0, lastDotIndex );
					parser.pos = startPos + combo.length;
				} else {
					parser.pos -= 1;
				}
			}
			return {
				t: types.REFERENCE,
				n: combo.replace( /^this\./, './' ).replace( /^this$/, '.' )
			};
		};
	}( types, patterns );

	/* parse/Parser/expressions/primary/bracketedExpression.js */
	var bracketedExpression = function( types, errors ) {

		return function( parser ) {
			var start, expr;
			start = parser.pos;
			if ( !parser.matchString( '(' ) ) {
				return null;
			}
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( !expr ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ')' ) ) {
				parser.error( errors.expectedParen );
			}
			return {
				t: types.BRACKETED,
				x: expr
			};
		};
	}( types, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/_primary.js */
	var primary = function( getLiteral, getReference, getBracketedExpression ) {

		return function( parser ) {
			return getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );
		};
	}( literal, reference, bracketedExpression );

	/* parse/Parser/expressions/shared/refinement.js */
	var refinement = function( types, errors, patterns ) {

		return function getRefinement( parser ) {
			var start, name, expr;
			start = parser.pos;
			parser.allowWhitespace();
			// "." name
			if ( parser.matchString( '.' ) ) {
				parser.allowWhitespace();
				if ( name = parser.matchPattern( patterns.name ) ) {
					return {
						t: types.REFINEMENT,
						n: name
					};
				}
				parser.error( 'Expected a property name' );
			}
			// "[" expression "]"
			if ( parser.matchString( '[' ) ) {
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( !expr ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ']' ) ) {
					parser.error( 'Expected \']\'' );
				}
				return {
					t: types.REFINEMENT,
					x: expr
				};
			}
			return null;
		};
	}( types, parse_Parser_expressions_shared_errors, patterns );

	/* parse/Parser/expressions/memberOrInvocation.js */
	var memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {

		return function( parser ) {
			var current, expression, refinement, expressionList;
			expression = getPrimary( parser );
			if ( !expression ) {
				return null;
			}
			while ( expression ) {
				current = parser.pos;
				if ( refinement = getRefinement( parser ) ) {
					expression = {
						t: types.MEMBER,
						x: expression,
						r: refinement
					};
				} else if ( parser.matchString( '(' ) ) {
					parser.allowWhitespace();
					expressionList = getExpressionList( parser );
					parser.allowWhitespace();
					if ( !parser.matchString( ')' ) ) {
						parser.error( errors.expectedParen );
					}
					expression = {
						t: types.INVOCATION,
						x: expression
					};
					if ( expressionList ) {
						expression.o = expressionList;
					}
				} else {
					break;
				}
			}
			return expression;
		};
	}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/typeof.js */
	var _typeof = function( types, errors, getMemberOrInvocation ) {

		var getTypeof, makePrefixSequenceMatcher;
		makePrefixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var expression;
				if ( expression = fallthrough( parser ) ) {
					return expression;
				}
				if ( !parser.matchString( symbol ) ) {
					return null;
				}
				parser.allowWhitespace();
				expression = parser.readExpression();
				if ( !expression ) {
					parser.error( errors.expectedExpression );
				}
				return {
					s: symbol,
					o: expression,
					t: types.PREFIX_OPERATOR
				};
			};
		};
		// create all prefix sequence matchers, return getTypeof
		( function() {
			var i, len, matcher, prefixOperators, fallthrough;
			prefixOperators = '! ~ + - typeof'.split( ' ' );
			fallthrough = getMemberOrInvocation;
			for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
				matcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// typeof operator is higher precedence than multiplication, so provides the
			// fallthrough for the multiplication sequence matcher we're about to create
			// (we're skipping void and delete)
			getTypeof = fallthrough;
		}() );
		return getTypeof;
	}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );

	/* parse/Parser/expressions/logicalOr.js */
	var logicalOr = function( types, getTypeof ) {

		var getLogicalOr, makeInfixSequenceMatcher;
		makeInfixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var start, left, right;
				left = fallthrough( parser );
				if ( !left ) {
					return null;
				}
				// Loop to handle left-recursion in a case like `a * b * c` and produce
				// left association, i.e. `(a * b) * c`.  The matcher can't call itself
				// to parse `left` because that would be infinite regress.
				while ( true ) {
					start = parser.pos;
					parser.allowWhitespace();
					if ( !parser.matchString( symbol ) ) {
						parser.pos = start;
						return left;
					}
					// special case - in operator must not be followed by [a-zA-Z_$0-9]
					if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
						parser.pos = start;
						return left;
					}
					parser.allowWhitespace();
					// right operand must also consist of only higher-precedence operators
					right = fallthrough( parser );
					if ( !right ) {
						parser.pos = start;
						return left;
					}
					left = {
						t: types.INFIX_OPERATOR,
						s: symbol,
						o: [
							left,
							right
						]
					};
				}
			};
		};
		// create all infix sequence matchers, and return getLogicalOr
		( function() {
			var i, len, matcher, infixOperators, fallthrough;
			// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
			// Each sequence matcher will initially fall through to its higher precedence
			// neighbour, and only attempt to match if one of the higher precedence operators
			// (or, ultimately, a literal, reference, or bracketed expression) already matched
			infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
			// A typeof operator is higher precedence than multiplication
			fallthrough = getTypeof;
			for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
				matcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// Logical OR is the fallthrough for the conditional matcher
			getLogicalOr = fallthrough;
		}() );
		return getLogicalOr;
	}( types, _typeof );

	/* parse/Parser/expressions/conditional.js */
	var conditional = function( types, getLogicalOr, errors ) {

		// The conditional operator is the lowest precedence operator, so we start here
		return function( parser ) {
			var start, expression, ifTrue, ifFalse;
			expression = getLogicalOr( parser );
			if ( !expression ) {
				return null;
			}
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '?' ) ) {
				parser.pos = start;
				return expression;
			}
			parser.allowWhitespace();
			ifTrue = parser.readExpression();
			if ( !ifTrue ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				parser.error( 'Expected ":"' );
			}
			parser.allowWhitespace();
			ifFalse = parser.readExpression();
			if ( !ifFalse ) {
				parser.error( errors.expectedExpression );
			}
			return {
				t: types.CONDITIONAL,
				o: [
					expression,
					ifTrue,
					ifFalse
				]
			};
		};
	}( types, logicalOr, parse_Parser_expressions_shared_errors );

	/* parse/Parser/utils/flattenExpression.js */
	var flattenExpression = function( types, isObject ) {

		return function( expression ) {
			var refs = [],
				flattened;
			extractRefs( expression, refs );
			flattened = {
				r: refs,
				s: stringify( this, expression, refs )
			};
			return flattened;
		};

		function quoteStringLiteral( str ) {
			return JSON.stringify( String( str ) );
		}
		// TODO maybe refactor this?
		function extractRefs( node, refs ) {
			var i, list;
			if ( node.t === types.REFERENCE ) {
				if ( refs.indexOf( node.n ) === -1 ) {
					refs.unshift( node.n );
				}
			}
			list = node.o || node.m;
			if ( list ) {
				if ( isObject( list ) ) {
					extractRefs( list, refs );
				} else {
					i = list.length;
					while ( i-- ) {
						extractRefs( list[ i ], refs );
					}
				}
			}
			if ( node.x ) {
				extractRefs( node.x, refs );
			}
			if ( node.r ) {
				extractRefs( node.r, refs );
			}
			if ( node.v ) {
				extractRefs( node.v, refs );
			}
		}

		function stringify( parser, node, refs ) {
			var stringifyAll = function( item ) {
				return stringify( parser, item, refs );
			};
			switch ( node.t ) {
				case types.BOOLEAN_LITERAL:
				case types.GLOBAL:
				case types.NUMBER_LITERAL:
					return node.v;
				case types.STRING_LITERAL:
					return quoteStringLiteral( node.v );
				case types.ARRAY_LITERAL:
					return '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';
				case types.OBJECT_LITERAL:
					return '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';
				case types.KEY_VALUE_PAIR:
					return node.k + ':' + stringify( parser, node.v, refs );
				case types.PREFIX_OPERATOR:
					return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );
				case types.INFIX_OPERATOR:
					return stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );
				case types.INVOCATION:
					return stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';
				case types.BRACKETED:
					return '(' + stringify( parser, node.x, refs ) + ')';
				case types.MEMBER:
					return stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );
				case types.REFINEMENT:
					return node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';
				case types.CONDITIONAL:
					return stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );
				case types.REFERENCE:
					return '${' + refs.indexOf( node.n ) + '}';
				default:
					parser.error( 'Expected legal JavaScript' );
			}
		}
	}( types, isObject );

	/* parse/Parser/_Parser.js */
	var Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {

		var Parser, ParseError, leadingWhitespace = /^\s+/;
		ParseError = function( message ) {
			this.name = 'ParseError';
			this.message = message;
			try {
				throw new Error( message );
			} catch ( e ) {
				this.stack = e.stack;
			}
		};
		ParseError.prototype = Error.prototype;
		Parser = function( str, options ) {
			var items, item;
			this.str = str;
			this.options = options || {};
			this.pos = 0;
			// Custom init logic
			if ( this.init )
				this.init( str, options );
			items = [];
			while ( this.pos < this.str.length && ( item = this.read() ) ) {
				items.push( item );
			}
			this.leftover = this.remaining();
			this.result = this.postProcess ? this.postProcess( items, options ) : items;
		};
		Parser.prototype = {
			read: function( converters ) {
				var pos, i, len, item;
				if ( !converters )
					converters = this.converters;
				pos = this.pos;
				len = converters.length;
				for ( i = 0; i < len; i += 1 ) {
					this.pos = pos;
					// reset for each attempt
					if ( item = converters[ i ]( this ) ) {
						return item;
					}
				}
				return null;
			},
			readExpression: function() {
				// The conditional operator is the lowest precedence operator (except yield,
				// assignment operators, and commas, none of which are supported), so we
				// start there. If it doesn't match, it 'falls through' to progressively
				// higher precedence operators, until it eventually matches (or fails to
				// match) a 'primary' - a literal or a reference. This way, the abstract syntax
				// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
				return getConditional( this );
			},
			flattenExpression: flattenExpression,
			getLinePos: function() {
				var lines, currentLine, currentLineEnd, nextLineEnd, lineNum, columnNum;
				lines = this.str.split( '\n' );
				lineNum = -1;
				nextLineEnd = 0;
				do {
					currentLineEnd = nextLineEnd;
					lineNum++;
					currentLine = lines[ lineNum ];
					nextLineEnd += currentLine.length + 1;
				} while ( nextLineEnd <= this.pos );
				columnNum = this.pos - currentLineEnd;
				return {
					line: lineNum + 1,
					ch: columnNum + 1,
					text: currentLine,
					toJSON: function() {
						return [
							this.line,
							this.ch
						];
					},
					toString: function() {
						return 'line ' + this.line + ' character ' + this.ch + ':\n' + this.text + '\n' + this.text.substr( 0, this.ch - 1 ).replace( /[\S]/g, ' ' ) + '^----';
					}
				};
			},
			error: function( err ) {
				var pos, message;
				pos = this.getLinePos();
				message = err + ' at ' + pos;
				throw new ParseError( message );
			},
			matchString: function( string ) {
				if ( this.str.substr( this.pos, string.length ) === string ) {
					this.pos += string.length;
					return string;
				}
			},
			matchPattern: function( pattern ) {
				var match;
				if ( match = pattern.exec( this.remaining() ) ) {
					this.pos += match[ 0 ].length;
					return match[ 1 ] || match[ 0 ];
				}
			},
			allowWhitespace: function() {
				this.matchPattern( leadingWhitespace );
			},
			remaining: function() {
				return this.str.substring( this.pos );
			},
			nextChar: function() {
				return this.str.charAt( this.pos );
			}
		};
		Parser.extend = function( proto ) {
			var Parent = this,
				Child, key;
			Child = function( str, options ) {
				Parser.call( this, str, options );
			};
			Child.prototype = create( Parent.prototype );
			for ( key in proto ) {
				if ( hasOwnProperty.call( proto, key ) ) {
					Child.prototype[ key ] = proto[ key ];
				}
			}
			Child.extend = Parser.extend;
			return Child;
		};
		circular.Parser = Parser;
		return Parser;
	}( circular, create, hasOwn, conditional, flattenExpression );

	/* parse/converters/mustache/delimiterChange.js */
	var delimiterChange = function() {

		var delimiterChangePattern = /^[^\s=]+/,
			whitespacePattern = /^\s+/;
		return function( parser ) {
			var start, opening, closing;
			if ( !parser.matchString( '=' ) ) {
				return null;
			}
			start = parser.pos;
			// allow whitespace before new opening delimiter
			parser.allowWhitespace();
			opening = parser.matchPattern( delimiterChangePattern );
			if ( !opening ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace (in fact, it's necessary...)
			if ( !parser.matchPattern( whitespacePattern ) ) {
				return null;
			}
			closing = parser.matchPattern( delimiterChangePattern );
			if ( !closing ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing '='
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			return [
				opening,
				closing
			];
		};
	}();

	/* parse/converters/mustache/delimiterTypes.js */
	var delimiterTypes = [ {
		delimiters: 'delimiters',
		isTriple: false,
		isStatic: false
	}, {
		delimiters: 'tripleDelimiters',
		isTriple: true,
		isStatic: false
	}, {
		delimiters: 'staticDelimiters',
		isTriple: false,
		isStatic: true
	}, {
		delimiters: 'staticTripleDelimiters',
		isTriple: true,
		isStatic: true
	} ];

	/* parse/converters/mustache/type.js */
	var type = function( types ) {

		var mustacheTypes = {
			'#': types.SECTION,
			'^': types.INVERTED,
			'/': types.CLOSING,
			'>': types.PARTIAL,
			'!': types.COMMENT,
			'&': types.TRIPLE
		};
		return function( parser ) {
			var type = mustacheTypes[ parser.str.charAt( parser.pos ) ];
			if ( !type ) {
				return null;
			}
			parser.pos += 1;
			return type;
		};
	}( types );

	/* parse/converters/mustache/handlebarsBlockCodes.js */
	var handlebarsBlockCodes = function( types ) {

		return {
			'if': types.SECTION_IF,
			'unless': types.SECTION_UNLESS,
			'with': types.SECTION_WITH,
			'each': types.SECTION_EACH
		};
	}( types );

	/* empty/legacy.js */
	var legacy = null;

	/* parse/converters/mustache/content.js */
	var content = function( types, mustacheType, handlebarsBlockCodes ) {

		var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
			arrayMemberPattern = /^[0-9][1-9]*$/,
			handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' ),
			legalReference;
		legalReference = /^[a-zA-Z$_0-9]+(?:(\.[a-zA-Z$_0-9]+)|(\[[a-zA-Z$_0-9]+\]))*$/;
		return function( parser, delimiterType ) {
			var start, pos, mustache, type, block, expression, i, remaining, index, delimiters, referenceExpression;
			start = parser.pos;
			mustache = {};
			delimiters = parser[ delimiterType.delimiters ];
			if ( delimiterType.isStatic ) {
				mustache.s = true;
			}
			// Determine mustache type
			if ( delimiterType.isTriple ) {
				mustache.t = types.TRIPLE;
			} else {
				// We need to test for expressions before we test for mustache type, because
				// an expression that begins '!' looks a lot like a comment
				if ( parser.remaining()[ 0 ] === '!' && ( expression = parser.readExpression() ) ) {
					mustache.t = types.INTERPOLATOR;
					// Was it actually an expression, or a comment block in disguise?
					parser.allowWhitespace();
					if ( parser.matchString( delimiters[ 1 ] ) ) {
						// expression
						parser.pos -= delimiters[ 1 ].length;
					} else {
						// comment block
						parser.pos = start;
						expression = null;
					}
				}
				if ( !expression ) {
					type = mustacheType( parser );
					mustache.t = type || types.INTERPOLATOR;
					// default
					// See if there's an explicit section type e.g. {{#with}}...{{/with}}
					if ( type === types.SECTION ) {
						if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
							mustache.n = block;
						}
						parser.allowWhitespace();
					} else if ( type === types.COMMENT || type === types.CLOSING ) {
						remaining = parser.remaining();
						index = remaining.indexOf( delimiters[ 1 ] );
						if ( index !== -1 ) {
							mustache.r = remaining.substr( 0, index );
							parser.pos += index;
							return mustache;
						}
					}
				}
			}
			if ( !expression ) {
				// allow whitespace
				parser.allowWhitespace();
				// get expression
				expression = parser.readExpression();
				// With certain valid references that aren't valid expressions,
				// e.g. {{1.foo}}, we have a problem: it looks like we've got an
				// expression, but the expression didn't consume the entire
				// reference. So we need to check that the mustache delimiters
				// appear next, unless there's an index reference (i.e. a colon)
				remaining = parser.remaining();
				if ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {
					pos = parser.pos;
					parser.pos = start;
					remaining = parser.remaining();
					index = remaining.indexOf( delimiters[ 1 ] );
					if ( index !== -1 ) {
						mustache.r = remaining.substr( 0, index ).trim();
						// Check it's a legal reference
						if ( !legalReference.test( mustache.r ) ) {
							parser.error( 'Expected a legal Mustache reference' );
						}
						parser.pos += index;
						return mustache;
					}
					parser.pos = pos;
				}
			}
			if ( expression ) {
				while ( expression.t === types.BRACKETED && expression.x ) {
					expression = expression.x;
				}
				// special case - integers should be treated as array members references,
				// rather than as expressions in their own right
				if ( expression.t === types.REFERENCE ) {
					mustache.r = expression.n;
				} else {
					if ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {
						mustache.r = expression.v;
					} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {
						mustache.rx = referenceExpression;
					} else {
						mustache.x = parser.flattenExpression( expression );
					}
				}
			}
			// optional index reference
			if ( i = parser.matchPattern( indexRefPattern ) ) {
				mustache.i = i;
			}
			return mustache;
		};
		// TODO refactor this! it's bewildering
		function getReferenceExpression( parser, expression ) {
			var members = [],
				refinement;
			while ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {
				refinement = expression.r;
				if ( refinement.x ) {
					if ( refinement.x.t === types.REFERENCE ) {
						members.unshift( refinement.x );
					} else {
						members.unshift( parser.flattenExpression( refinement.x ) );
					}
				} else {
					members.unshift( refinement.n );
				}
				expression = expression.x;
			}
			if ( expression.t !== types.REFERENCE ) {
				return null;
			}
			return {
				r: expression.n,
				m: members
			};
		}
	}( types, type, handlebarsBlockCodes, legacy );

	/* parse/converters/mustache.js */
	var mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {

		var delimiterChangeToken = {
				t: types.DELIMCHANGE,
				exclude: true
			},
			handlebarsIndexRefPattern = /^@(?:index|key)$/;
		return getMustache;

		function getMustache( parser ) {
			var types;
			types = delimiterTypes.slice().sort( function compare( a, b ) {
				// Sort in order of descending opening delimiter length (longer first),
				// to protect against opening delimiters being substrings of each other
				return parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;
			} );
			return function r( type ) {
				if ( !type ) {
					return null;
				} else {
					return getMustacheOfType( parser, type ) || r( types.shift() );
				}
			}( types.shift() );
		}

		function getMustacheOfType( parser, delimiterType ) {
			var start, startPos, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child, indexRef;
			start = parser.pos;
			startPos = parser.getLinePos();
			delimiters = parser[ delimiterType.delimiters ];
			if ( !parser.matchString( delimiters[ 0 ] ) ) {
				return null;
			}
			// delimiter change?
			if ( mustache = delimiterChange( parser ) ) {
				// find closing delimiter or abort...
				if ( !parser.matchString( delimiters[ 1 ] ) ) {
					return null;
				}
				// ...then make the switch
				parser[ delimiterType.delimiters ] = mustache;
				return delimiterChangeToken;
			}
			parser.allowWhitespace();
			mustache = mustacheContent( parser, delimiterType );
			if ( mustache === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing delimiter
			parser.allowWhitespace();
			if ( !parser.matchString( delimiters[ 1 ] ) ) {
				parser.error( 'Expected closing delimiter \'' + delimiters[ 1 ] + '\' after reference' );
			}
			if ( mustache.t === types.COMMENT ) {
				mustache.exclude = true;
			}
			if ( mustache.t === types.CLOSING ) {
				parser.sectionDepth -= 1;
				if ( parser.sectionDepth < 0 ) {
					parser.pos = start;
					parser.error( 'Attempted to close a section that wasn\'t open' );
				}
			}
			// section children
			if ( isSection( mustache ) ) {
				parser.sectionDepth += 1;
				children = [];
				currentChildren = children;
				expectedClose = mustache.n;
				while ( child = parser.read() ) {
					if ( child.t === types.CLOSING ) {
						if ( expectedClose && child.r !== expectedClose ) {
							parser.error( 'Expected {{/' + expectedClose + '}}' );
						}
						break;
					}
					// {{else}} tags require special treatment
					if ( child.t === types.INTERPOLATOR && child.r === 'else' ) {
						switch ( mustache.n ) {
							case 'unless':
								parser.error( '{{else}} not allowed in {{#unless}}' );
								break;
							case 'with':
								parser.error( '{{else}} not allowed in {{#with}}' );
								break;
							default:
								currentChildren = elseChildren = [];
								continue;
						}
					}
					currentChildren.push( child );
				}
				if ( children.length ) {
					mustache.f = children;
					// If this is an 'each' section, and it contains an {{@index}} or {{@key}},
					// we need to set the index reference accordingly
					if ( !mustache.i && mustache.n === 'each' && ( indexRef = handlebarsIndexRef( mustache.f ) ) ) {
						mustache.i = indexRef;
					}
				}
				if ( elseChildren && elseChildren.length ) {
					mustache.l = elseChildren;
				}
			}
			if ( parser.includeLinePositions ) {
				mustache.p = startPos.toJSON();
			}
			// Replace block name with code
			if ( mustache.n ) {
				mustache.n = handlebarsBlockCodes[ mustache.n ];
			} else if ( mustache.t === types.INVERTED ) {
				mustache.t = types.SECTION;
				mustache.n = types.SECTION_UNLESS;
			}
			return mustache;
		}

		function handlebarsIndexRef( fragment ) {
			var i, child, indexRef;
			i = fragment.length;
			while ( i-- ) {
				child = fragment[ i ];
				// Recurse into elements (but not sections)
				if ( child.t === types.ELEMENT && child.f && ( indexRef = handlebarsIndexRef( child.f ) ) ) {
					return indexRef;
				}
				// Mustache?
				if ( child.t === types.INTERPOLATOR || child.t === types.TRIPLE || child.t === types.SECTION ) {
					// Normal reference?
					if ( child.r && handlebarsIndexRefPattern.test( child.r ) ) {
						return child.r;
					}
					// Expression?
					if ( child.x && ( indexRef = indexRefContainedInExpression( child.x ) ) ) {
						return indexRef;
					}
					// Reference expression?
					if ( child.rx && ( indexRef = indexRefContainedInReferenceExpression( child.rx ) ) ) {
						return indexRef;
					}
				}
			}
		}

		function indexRefContainedInExpression( expression ) {
			var i;
			i = expression.r.length;
			while ( i-- ) {
				if ( handlebarsIndexRefPattern.test( expression.r[ i ] ) ) {
					return expression.r[ i ];
				}
			}
		}

		function indexRefContainedInReferenceExpression( referenceExpression ) {
			var i, indexRef, member;
			i = referenceExpression.m.length;
			while ( i-- ) {
				member = referenceExpression.m[ i ];
				if ( member.r && ( indexRef = indexRefContainedInExpression( member ) ) ) {
					return indexRef;
				}
				if ( member.t === types.REFERENCE && handlebarsIndexRefPattern.test( member.n ) ) {
					return member.n;
				}
			}
		}

		function isSection( mustache ) {
			return mustache.t === types.SECTION || mustache.t === types.INVERTED;
		}
	}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );

	/* parse/converters/comment.js */
	var comment = function( types ) {

		var OPEN_COMMENT = '<!--',
			CLOSE_COMMENT = '-->';
		return function( parser ) {
			var startPos, content, remaining, endIndex, comment;
			startPos = parser.getLinePos();
			if ( !parser.matchString( OPEN_COMMENT ) ) {
				return null;
			}
			remaining = parser.remaining();
			endIndex = remaining.indexOf( CLOSE_COMMENT );
			if ( endIndex === -1 ) {
				parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
			}
			content = remaining.substr( 0, endIndex );
			parser.pos += endIndex + 3;
			comment = {
				t: types.COMMENT,
				c: content
			};
			if ( parser.includeLinePositions ) {
				comment.p = startPos.toJSON();
			}
			return comment;
		};
	}( types );

	/* config/voidElementNames.js */
	var voidElementNames = function() {

		var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
		return voidElementNames;
	}();

	/* parse/converters/utils/getLowestIndex.js */
	var getLowestIndex = function( haystack, needles ) {
		var i, index, lowest;
		i = needles.length;
		while ( i-- ) {
			index = haystack.indexOf( needles[ i ] );
			// short circuit
			if ( !index ) {
				return 0;
			}
			if ( index === -1 ) {
				continue;
			}
			if ( !lowest || index < lowest ) {
				lowest = index;
			}
		}
		return lowest || -1;
	};

	/* parse/converters/utils/decodeCharacterReferences.js */
	var decodeCharacterReferences = function() {

		var htmlEntities, controlCharacters, namedEntityPattern, hexEntityPattern, decimalEntityPattern;
		htmlEntities = {
			quot: 34,
			amp: 38,
			apos: 39,
			lt: 60,
			gt: 62,
			nbsp: 160,
			iexcl: 161,
			cent: 162,
			pound: 163,
			curren: 164,
			yen: 165,
			brvbar: 166,
			sect: 167,
			uml: 168,
			copy: 169,
			ordf: 170,
			laquo: 171,
			not: 172,
			shy: 173,
			reg: 174,
			macr: 175,
			deg: 176,
			plusmn: 177,
			sup2: 178,
			sup3: 179,
			acute: 180,
			micro: 181,
			para: 182,
			middot: 183,
			cedil: 184,
			sup1: 185,
			ordm: 186,
			raquo: 187,
			frac14: 188,
			frac12: 189,
			frac34: 190,
			iquest: 191,
			Agrave: 192,
			Aacute: 193,
			Acirc: 194,
			Atilde: 195,
			Auml: 196,
			Aring: 197,
			AElig: 198,
			Ccedil: 199,
			Egrave: 200,
			Eacute: 201,
			Ecirc: 202,
			Euml: 203,
			Igrave: 204,
			Iacute: 205,
			Icirc: 206,
			Iuml: 207,
			ETH: 208,
			Ntilde: 209,
			Ograve: 210,
			Oacute: 211,
			Ocirc: 212,
			Otilde: 213,
			Ouml: 214,
			times: 215,
			Oslash: 216,
			Ugrave: 217,
			Uacute: 218,
			Ucirc: 219,
			Uuml: 220,
			Yacute: 221,
			THORN: 222,
			szlig: 223,
			agrave: 224,
			aacute: 225,
			acirc: 226,
			atilde: 227,
			auml: 228,
			aring: 229,
			aelig: 230,
			ccedil: 231,
			egrave: 232,
			eacute: 233,
			ecirc: 234,
			euml: 235,
			igrave: 236,
			iacute: 237,
			icirc: 238,
			iuml: 239,
			eth: 240,
			ntilde: 241,
			ograve: 242,
			oacute: 243,
			ocirc: 244,
			otilde: 245,
			ouml: 246,
			divide: 247,
			oslash: 248,
			ugrave: 249,
			uacute: 250,
			ucirc: 251,
			uuml: 252,
			yacute: 253,
			thorn: 254,
			yuml: 255,
			OElig: 338,
			oelig: 339,
			Scaron: 352,
			scaron: 353,
			Yuml: 376,
			fnof: 402,
			circ: 710,
			tilde: 732,
			Alpha: 913,
			Beta: 914,
			Gamma: 915,
			Delta: 916,
			Epsilon: 917,
			Zeta: 918,
			Eta: 919,
			Theta: 920,
			Iota: 921,
			Kappa: 922,
			Lambda: 923,
			Mu: 924,
			Nu: 925,
			Xi: 926,
			Omicron: 927,
			Pi: 928,
			Rho: 929,
			Sigma: 931,
			Tau: 932,
			Upsilon: 933,
			Phi: 934,
			Chi: 935,
			Psi: 936,
			Omega: 937,
			alpha: 945,
			beta: 946,
			gamma: 947,
			delta: 948,
			epsilon: 949,
			zeta: 950,
			eta: 951,
			theta: 952,
			iota: 953,
			kappa: 954,
			lambda: 955,
			mu: 956,
			nu: 957,
			xi: 958,
			omicron: 959,
			pi: 960,
			rho: 961,
			sigmaf: 962,
			sigma: 963,
			tau: 964,
			upsilon: 965,
			phi: 966,
			chi: 967,
			psi: 968,
			omega: 969,
			thetasym: 977,
			upsih: 978,
			piv: 982,
			ensp: 8194,
			emsp: 8195,
			thinsp: 8201,
			zwnj: 8204,
			zwj: 8205,
			lrm: 8206,
			rlm: 8207,
			ndash: 8211,
			mdash: 8212,
			lsquo: 8216,
			rsquo: 8217,
			sbquo: 8218,
			ldquo: 8220,
			rdquo: 8221,
			bdquo: 8222,
			dagger: 8224,
			Dagger: 8225,
			bull: 8226,
			hellip: 8230,
			permil: 8240,
			prime: 8242,
			Prime: 8243,
			lsaquo: 8249,
			rsaquo: 8250,
			oline: 8254,
			frasl: 8260,
			euro: 8364,
			image: 8465,
			weierp: 8472,
			real: 8476,
			trade: 8482,
			alefsym: 8501,
			larr: 8592,
			uarr: 8593,
			rarr: 8594,
			darr: 8595,
			harr: 8596,
			crarr: 8629,
			lArr: 8656,
			uArr: 8657,
			rArr: 8658,
			dArr: 8659,
			hArr: 8660,
			forall: 8704,
			part: 8706,
			exist: 8707,
			empty: 8709,
			nabla: 8711,
			isin: 8712,
			notin: 8713,
			ni: 8715,
			prod: 8719,
			sum: 8721,
			minus: 8722,
			lowast: 8727,
			radic: 8730,
			prop: 8733,
			infin: 8734,
			ang: 8736,
			and: 8743,
			or: 8744,
			cap: 8745,
			cup: 8746,
			'int': 8747,
			there4: 8756,
			sim: 8764,
			cong: 8773,
			asymp: 8776,
			ne: 8800,
			equiv: 8801,
			le: 8804,
			ge: 8805,
			sub: 8834,
			sup: 8835,
			nsub: 8836,
			sube: 8838,
			supe: 8839,
			oplus: 8853,
			otimes: 8855,
			perp: 8869,
			sdot: 8901,
			lceil: 8968,
			rceil: 8969,
			lfloor: 8970,
			rfloor: 8971,
			lang: 9001,
			rang: 9002,
			loz: 9674,
			spades: 9824,
			clubs: 9827,
			hearts: 9829,
			diams: 9830
		};
		controlCharacters = [
			8364,
			129,
			8218,
			402,
			8222,
			8230,
			8224,
			8225,
			710,
			8240,
			352,
			8249,
			338,
			141,
			381,
			143,
			144,
			8216,
			8217,
			8220,
			8221,
			8226,
			8211,
			8212,
			732,
			8482,
			353,
			8250,
			339,
			157,
			382,
			376
		];
		namedEntityPattern = new RegExp( '&(' + Object.keys( htmlEntities ).join( '|' ) + ');?', 'g' );
		hexEntityPattern = /&#x([0-9]+);?/g;
		decimalEntityPattern = /&#([0-9]+);?/g;
		return function decodeCharacterReferences( html ) {
			var result;
			// named entities
			result = html.replace( namedEntityPattern, function( match, name ) {
				if ( htmlEntities[ name ] ) {
					return String.fromCharCode( htmlEntities[ name ] );
				}
				return match;
			} );
			// hex references
			result = result.replace( hexEntityPattern, function( match, hex ) {
				return String.fromCharCode( validateCode( parseInt( hex, 16 ) ) );
			} );
			// decimal references
			result = result.replace( decimalEntityPattern, function( match, charCode ) {
				return String.fromCharCode( validateCode( charCode ) );
			} );
			return result;
		};
		// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
		// code points with alternatives in some cases - since we're bypassing that mechanism, we need
		// to replace them ourselves
		//
		// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
		function validateCode( code ) {
			if ( !code ) {
				return 65533;
			}
			// line feed becomes generic whitespace
			if ( code === 10 ) {
				return 32;
			}
			// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
			if ( code < 128 ) {
				return code;
			}
			// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
			// to correct the mistake or we'll end up with missing € signs and so on
			if ( code <= 159 ) {
				return controlCharacters[ code - 128 ];
			}
			// basic multilingual plane
			if ( code < 55296 ) {
				return code;
			}
			// UTF-16 surrogate halves
			if ( code <= 57343 ) {
				return 65533;
			}
			// rest of the basic multilingual plane
			if ( code <= 65535 ) {
				return code;
			}
			return 65533;
		}
	}( legacy );

	/* parse/converters/text.js */
	var text = function( getLowestIndex, decodeCharacterReferences ) {

		return function( parser ) {
			var index, remaining, disallowed, barrier;
			remaining = parser.remaining();
			barrier = parser.inside ? '</' + parser.inside : '<';
			if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
				index = remaining.indexOf( barrier );
			} else {
				disallowed = [
					barrier,
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				// http://developers.whatwg.org/syntax.html#syntax-attributes
				if ( parser.inAttribute === true ) {
					// we're inside an unquoted attribute value
					disallowed.push( '"', '\'', '=', '>', '`' );
				} else if ( parser.inAttribute ) {
					disallowed.push( parser.inAttribute );
				}
				index = getLowestIndex( remaining, disallowed );
			}
			if ( !index ) {
				return null;
			}
			if ( index === -1 ) {
				index = remaining.length;
			}
			parser.pos += index;
			return decodeCharacterReferences( remaining.substr( 0, index ) );
		};
	}( getLowestIndex, decodeCharacterReferences );

	/* parse/converters/element/closingTag.js */
	var closingTag = function( types ) {

		var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
		return function( parser ) {
			var tag;
			// are we looking at a closing tag?
			if ( !parser.matchString( '</' ) ) {
				return null;
			}
			if ( tag = parser.matchPattern( closingTagPattern ) ) {
				return {
					t: types.CLOSING_TAG,
					e: tag
				};
			}
			// We have an illegal closing tag, report it
			parser.pos -= 2;
			parser.error( 'Illegal closing tag' );
		};
	}( types );

	/* parse/converters/element/attribute.js */
	var attribute = function( getLowestIndex, getMustache ) {

		var attributeNamePattern = /^[^\s"'>\/=]+/,
			unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
		return getAttribute;

		function getAttribute( parser ) {
			var attr, name, value;
			parser.allowWhitespace();
			name = parser.matchPattern( attributeNamePattern );
			if ( !name ) {
				return null;
			}
			attr = {
				name: name
			};
			value = getAttributeValue( parser );
			if ( value ) {
				attr.value = value;
			}
			return attr;
		}

		function getAttributeValue( parser ) {
			var start, valueStart, startDepth, value;
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			parser.allowWhitespace();
			valueStart = parser.pos;
			startDepth = parser.sectionDepth;
			value = getQuotedAttributeValue( parser, '\'' ) || getQuotedAttributeValue( parser, '"' ) || getUnquotedAttributeValue( parser );
			if ( parser.sectionDepth !== startDepth ) {
				parser.pos = valueStart;
				parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
			}
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			if ( value.length === 1 && typeof value[ 0 ] === 'string' ) {
				return value[ 0 ];
			}
			return value;
		}

		function getUnquotedAttributeValueToken( parser ) {
			var start, text, index;
			start = parser.pos;
			text = parser.matchPattern( unquotedAttributeValueTextPattern );
			if ( !text ) {
				return null;
			}
			if ( ( index = text.indexOf( parser.delimiters[ 0 ] ) ) !== -1 ) {
				text = text.substr( 0, index );
				parser.pos = start + text.length;
			}
			return text;
		}

		function getUnquotedAttributeValue( parser ) {
			var tokens, token;
			parser.inAttribute = true;
			tokens = [];
			token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			}
			if ( !tokens.length ) {
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedAttributeValue( parser, quoteMark ) {
			var start, tokens, token;
			start = parser.pos;
			if ( !parser.matchString( quoteMark ) ) {
				return null;
			}
			parser.inAttribute = quoteMark;
			tokens = [];
			token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			}
			if ( !parser.matchString( quoteMark ) ) {
				parser.pos = start;
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedStringToken( parser, quoteMark ) {
			var start, index, remaining;
			start = parser.pos;
			remaining = parser.remaining();
			index = getLowestIndex( remaining, [
				quoteMark,
				parser.delimiters[ 0 ],
				parser.delimiters[ 1 ]
			] );
			if ( index === -1 ) {
				parser.error( 'Quoted attribute value must have a closing quote' );
			}
			if ( !index ) {
				return null;
			}
			parser.pos += index;
			return remaining.substr( 0, index );
		}
	}( getLowestIndex, mustache );

	/* utils/parseJSON.js */
	var parseJSON = function( Parser, getStringLiteral, getKey ) {

		// simple JSON parser, without the restrictions of JSON parse
		// (i.e. having to double-quote keys).
		//
		// If passed a hash of values as the second argument, ${placeholders}
		// will be replaced with those values
		var JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;
		specials = {
			'true': true,
			'false': false,
			'undefined': undefined,
			'null': null
		};
		specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
		numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		placeholderPattern = /\$\{([^\}]+)\}/g;
		placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
		onlyWhitespace = /^\s*$/;
		JsonParser = Parser.extend( {
			init: function( str, options ) {
				this.values = options.values;
			},
			postProcess: function( result ) {
				if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
					return null;
				}
				return {
					value: result[ 0 ].v
				};
			},
			converters: [

				function getPlaceholder( parser ) {
					var placeholder;
					if ( !parser.values ) {
						return null;
					}
					placeholder = parser.matchPattern( placeholderAtStartPattern );
					if ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {
						return {
							v: parser.values[ placeholder ]
						};
					}
				},
				function getSpecial( parser ) {
					var special;
					if ( special = parser.matchPattern( specialsPattern ) ) {
						return {
							v: specials[ special ]
						};
					}
				},
				function getNumber( parser ) {
					var number;
					if ( number = parser.matchPattern( numberPattern ) ) {
						return {
							v: +number
						};
					}
				},
				function getString( parser ) {
					var stringLiteral = getStringLiteral( parser ),
						values;
					if ( stringLiteral && ( values = parser.values ) ) {
						return {
							v: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {
								return $1 in values ? values[ $1 ] : $1;
							} )
						};
					}
					return stringLiteral;
				},
				function getObject( parser ) {
					var result, pair;
					if ( !parser.matchString( '{' ) ) {
						return null;
					}
					result = {};
					parser.allowWhitespace();
					if ( parser.matchString( '}' ) ) {
						return {
							v: result
						};
					}
					while ( pair = getKeyValuePair( parser ) ) {
						result[ pair.key ] = pair.value;
						parser.allowWhitespace();
						if ( parser.matchString( '}' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
					}
					return null;
				},
				function getArray( parser ) {
					var result, valueToken;
					if ( !parser.matchString( '[' ) ) {
						return null;
					}
					result = [];
					parser.allowWhitespace();
					if ( parser.matchString( ']' ) ) {
						return {
							v: result
						};
					}
					while ( valueToken = parser.read() ) {
						result.push( valueToken.v );
						parser.allowWhitespace();
						if ( parser.matchString( ']' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
						parser.allowWhitespace();
					}
					return null;
				}
			]
		} );

		function getKeyValuePair( parser ) {
			var key, valueToken, pair;
			parser.allowWhitespace();
			key = getKey( parser );
			if ( !key ) {
				return null;
			}
			pair = {
				key: key
			};
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				return null;
			}
			parser.allowWhitespace();
			valueToken = parser.read();
			if ( !valueToken ) {
				return null;
			}
			pair.value = valueToken.v;
			return pair;
		}
		return function( str, values ) {
			var parser = new JsonParser( str, {
				values: values
			} );
			return parser.result;
		};
	}( Parser, stringLiteral, key );

	/* parse/converters/element/processDirective.js */
	var processDirective = function( parseJSON ) {

		// TODO clean this up, it's shocking
		return function( tokens ) {
			var result, token, colonIndex, directiveName, directiveArgs, parsed;
			if ( typeof tokens === 'string' ) {
				if ( tokens.indexOf( ':' ) === -1 ) {
					return tokens.trim();
				}
				tokens = [ tokens ];
			}
			result = {};
			directiveName = [];
			directiveArgs = [];
			while ( tokens.length ) {
				token = tokens.shift();
				if ( typeof token === 'string' ) {
					colonIndex = token.indexOf( ':' );
					if ( colonIndex === -1 ) {
						directiveName.push( token );
					} else {
						// is the colon the first character?
						if ( colonIndex ) {
							// no
							directiveName.push( token.substr( 0, colonIndex ) );
						}
						// if there is anything after the colon in this token, treat
						// it as the first token of the directiveArgs fragment
						if ( token.length > colonIndex + 1 ) {
							directiveArgs[ 0 ] = token.substring( colonIndex + 1 );
						}
						break;
					}
				} else {
					directiveName.push( token );
				}
			}
			directiveArgs = directiveArgs.concat( tokens );
			if ( directiveArgs.length || typeof directiveName !== 'string' ) {
				result = {
					// TODO is this really necessary? just use the array
					n: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName
				};
				if ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {
					parsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );
					result.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();
				} else {
					result.d = directiveArgs;
				}
			} else {
				result = directiveName;
			}
			return result;
		};
	}( parseJSON );

	/* parse/converters/element.js */
	var element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {

		var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
			validTagNameFollower = /^[\s\n\/>]/,
			onPattern = /^on/,
			proxyEventPattern = /^on-([a-zA-Z$_][a-zA-Z$_0-9\-]+)$/,
			reservedEventNames = /^(?:change|reset|teardown|update)$/,
			directives = {
				'intro-outro': 't0',
				intro: 't1',
				outro: 't2',
				decorator: 'o'
			},
			exclude = {
				exclude: true
			},
			converters;
		// Different set of converters, because this time we're looking for closing tags
		converters = [
			getMustache,
			getComment,
			getElement,
			getText,
			getClosingTag
		];
		return getElement;

		function getElement( parser ) {
			var start, startPos, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;
			start = parser.pos;
			startPos = parser.getLinePos();
			if ( parser.inside ) {
				return null;
			}
			if ( !parser.matchString( '<' ) ) {
				return null;
			}
			// if this is a closing tag, abort straight away
			if ( parser.nextChar() === '/' ) {
				return null;
			}
			element = {
				t: types.ELEMENT
			};
			if ( parser.includeLinePositions ) {
				element.p = startPos.toJSON();
			}
			if ( parser.matchString( '!' ) ) {
				element.y = 1;
			}
			// element name
			element.e = parser.matchPattern( tagNamePattern );
			if ( !element.e ) {
				return null;
			}
			// next character must be whitespace, closing solidus or '>'
			if ( !validTagNameFollower.test( parser.nextChar() ) ) {
				parser.error( 'Illegal tag name' );
			}
			addProxyEvent = function( name, directive ) {
				var directiveName = directive.n || directive;
				if ( reservedEventNames.test( directiveName ) ) {
					parser.pos -= directiveName.length;
					parser.error( 'Cannot use reserved event names (change, reset, teardown, update)' );
				}
				element.v[ name ] = directive;
			};
			// directives and attributes
			while ( attribute = getAttribute( parser ) ) {
				// intro, outro, decorator
				if ( directiveName = directives[ attribute.name ] ) {
					element[ directiveName ] = processDirective( attribute.value );
				} else if ( match = proxyEventPattern.exec( attribute.name ) ) {
					if ( !element.v )
						element.v = {};
					directive = processDirective( attribute.value );
					addProxyEvent( match[ 1 ], directive );
				} else {
					if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
						if ( !element.a )
							element.a = {};
						element.a[ attribute.name ] = attribute.value || 0;
					}
				}
			}
			// allow whitespace before closing solidus
			parser.allowWhitespace();
			// self-closing solidus?
			if ( parser.matchString( '/' ) ) {
				selfClosing = true;
			}
			// closing angle bracket
			if ( !parser.matchString( '>' ) ) {
				return null;
			}
			lowerCaseName = element.e.toLowerCase();
			if ( !selfClosing && !voidElementNames.test( element.e ) ) {
				// Special case - if we open a script element, further tags should
				// be ignored unless they're a closing script element
				if ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {
					parser.inside = lowerCaseName;
				}
				children = [];
				while ( child = parser.read( converters ) ) {
					// Special case - closing section tag
					if ( child.t === types.CLOSING ) {
						break;
					}
					if ( child.t === types.CLOSING_TAG ) {
						break;
					}
					children.push( child );
				}
				if ( children.length ) {
					element.f = children;
				}
			}
			parser.inside = null;
			if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
				return exclude;
			}
			return element;
		}
	}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );

	/* parse/utils/trimWhitespace.js */
	var trimWhitespace = function() {

		var leadingWhitespace = /^[ \t\f\r\n]+/,
			trailingWhitespace = /[ \t\f\r\n]+$/;
		return function( items, leading, trailing ) {
			var item;
			if ( leading ) {
				item = items[ 0 ];
				if ( typeof item === 'string' ) {
					item = item.replace( leadingWhitespace, '' );
					if ( !item ) {
						items.shift();
					} else {
						items[ 0 ] = item;
					}
				}
			}
			if ( trailing ) {
				item = items[ items.length - 1 ];
				if ( typeof item === 'string' ) {
					item = item.replace( trailingWhitespace, '' );
					if ( !item ) {
						items.pop();
					} else {
						items[ items.length - 1 ] = item;
					}
				}
			}
		};
	}();

	/* parse/utils/stripStandalones.js */
	var stripStandalones = function( types ) {

		var leadingLinebreak = /^\s*\r?\n/,
			trailingLinebreak = /\r?\n\s*$/;
		return function( items ) {
			var i, current, backOne, backTwo, lastSectionItem;
			for ( i = 1; i < items.length; i += 1 ) {
				current = items[ i ];
				backOne = items[ i - 1 ];
				backTwo = items[ i - 2 ];
				// if we're at the end of a [text][comment][text] sequence...
				if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
					// ... and the comment is a standalone (i.e. line breaks either side)...
					if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
						// ... then we want to remove the whitespace after the first line break
						items[ i - 2 ] = backTwo.replace( trailingLinebreak, '\n' );
						// and the leading line break of the second text token
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
				// if the current item is a section, and it is preceded by a linebreak, and
				// its first item is a linebreak...
				if ( isSection( current ) && isString( backOne ) ) {
					if ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {
						items[ i - 1 ] = backOne.replace( trailingLinebreak, '\n' );
						current.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );
					}
				}
				// if the last item was a section, and it is followed by a linebreak, and
				// its last item is a linebreak...
				if ( isString( current ) && isSection( backOne ) ) {
					lastSectionItem = backOne.f[ backOne.f.length - 1 ];
					if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
						backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
			}
			return items;
		};

		function isString( item ) {
			return typeof item === 'string';
		}

		function isComment( item ) {
			return item.t === types.COMMENT || item.t === types.DELIMCHANGE;
		}

		function isSection( item ) {
			return ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;
		}
	}( types );

	/* parse/_parse.js */
	var parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones ) {

		// Ractive.parse
		// ===============
		//
		// Takes in a string, and returns an object representing the parsed template.
		// A parsed template is an array of 1 or more 'templates', which in some
		// cases have children.
		//
		// The format is optimised for size, not readability, however for reference the
		// keys for each template are as follows:
		//
		// * r - Reference, e.g. 'mustache' in {{mustache}}
		// * t - Type code (e.g. 1 is text, 2 is interpolator...)
		// * f - Fragment. Contains a template's children
		// * l - eLse fragment. Contains a template's children in the else case
		// * e - Element name
		// * a - map of element Attributes, or proxy event/transition Arguments
		// * d - Dynamic proxy event/transition arguments
		// * n - indicates an iNverted section
		// * i - Index reference, e.g. 'num' in {{#section:num}}content{{/section}}
		// * v - eVent proxies (i.e. when user e.g. clicks on a node, fire proxy event)
		// * x - eXpressions
		// * s - String representation of an expression function
		// * t0 - intro/outro Transition
		// * t1 - intro Transition
		// * t2 - outro Transition
		// * o - decOrator
		// * y - is doctYpe
		// * c - is Content (e.g. of a comment node)
		// * p - line Position information - array with line number and character position of each node
		var StandardParser, parse, contiguousWhitespace = /[ \t\f\r\n]+/g,
			inlinePartialStart = /<!--\s*\{\{\s*>\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*}\}\s*-->/,
			inlinePartialEnd = /<!--\s*\{\{\s*\/\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*}\}\s*-->/,
			preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,
			leadingWhitespace = /^\s+/,
			trailingWhitespace = /\s+$/;
		StandardParser = Parser.extend( {
			init: function( str, options ) {
				// config
				this.delimiters = options.delimiters || [
					'{{',
					'}}'
				];
				this.tripleDelimiters = options.tripleDelimiters || [
					'{{{',
					'}}}'
				];
				this.staticDelimiters = options.staticDelimiters || [
					'[[',
					']]'
				];
				this.staticTripleDelimiters = options.staticTripleDelimiters || [
					'[[[',
					']]]'
				];
				this.sectionDepth = 0;
				this.interpolate = {
					script: !options.interpolate || options.interpolate.script !== false,
					style: !options.interpolate || options.interpolate.style !== false
				};
				if ( options.sanitize === true ) {
					options.sanitize = {
						// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
						elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
						eventAttributes: true
					};
				}
				this.sanitizeElements = options.sanitize && options.sanitize.elements;
				this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
				this.includeLinePositions = options.includeLinePositions;
			},
			postProcess: function( items, options ) {
				if ( this.sectionDepth > 0 ) {
					this.error( 'A section was left open' );
				}
				cleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );
				return items;
			},
			converters: [
				mustache,
				comment,
				element,
				text
			]
		} );
		parse = function( template ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var result, remaining, partials, name, startMatch, endMatch;
			result = {
				v: 1
			};
			if ( inlinePartialStart.test( template ) ) {
				remaining = template;
				template = '';
				while ( startMatch = inlinePartialStart.exec( remaining ) ) {
					name = startMatch[ 1 ];
					template += remaining.substr( 0, startMatch.index );
					remaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );
					endMatch = inlinePartialEnd.exec( remaining );
					if ( !endMatch || endMatch[ 1 ] !== name ) {
						throw new Error( 'Inline partials must have a closing delimiter, and cannot be nested' );
					}
					( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;
					remaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );
				}
				result.p = partials;
			}
			result.t = new StandardParser( template, options ).result;
			return result;
		};
		return parse;

		function cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {
			var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;
			// First pass - remove standalones and comments etc
			stripStandalones( items );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Remove delimiter changes, unsafe elements etc
				if ( item.exclude ) {
					items.splice( i, 1 );
				} else if ( stripComments && item.t === types.COMMENT ) {
					items.splice( i, 1 );
				}
			}
			// If necessary, remove leading and trailing whitespace
			trimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Recurse
				if ( item.f ) {
					preserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );
					if ( !preserveWhitespaceInsideFragment ) {
						previousItem = items[ i - 1 ];
						nextItem = items[ i + 1 ];
						// if the previous item was a text item with trailing whitespace,
						// remove leading whitespace inside the fragment
						if ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {
							removeLeadingWhitespaceInsideFragment = true;
						}
						// and vice versa
						if ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {
							removeTrailingWhitespaceInsideFragment = true;
						}
					}
					cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
					// Split if-else blocks into two (an if, and an unless)
					if ( item.l ) {
						cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
						if ( rewriteElse ) {
							unlessBlock = {
								t: 4,
								n: types.SECTION_UNLESS,
								f: item.l
							};
							// copy the conditional based on its type
							if ( item.r ) {
								unlessBlock.r = item.r;
							}
							if ( item.x ) {
								unlessBlock.x = item.x;
							}
							if ( item.rx ) {
								unlessBlock.rx = item.rx;
							}
							items.splice( i + 1, 0, unlessBlock );
							delete item.l;
						}
					}
				}
				// Clean up element attributes
				if ( item.a ) {
					for ( key in item.a ) {
						if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
							cleanup( item.a[ key ], stripComments, preserveWhitespace, rewriteElse );
						}
					}
				}
			}
			// final pass - fuse text nodes together
			i = items.length;
			while ( i-- ) {
				if ( typeof items[ i ] === 'string' ) {
					if ( typeof items[ i + 1 ] === 'string' ) {
						items[ i ] = items[ i ] + items[ i + 1 ];
						items.splice( i + 1, 1 );
					}
					if ( !preserveWhitespace ) {
						items[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );
					}
					if ( items[ i ] === '' ) {
						items.splice( i, 1 );
					}
				}
			}
		}
	}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones );

	/* config/options/groups/optionGroup.js */
	var optionGroup = function() {

		return function createOptionGroup( keys, config ) {
			var group = keys.map( config );
			keys.forEach( function( key, i ) {
				group[ key ] = group[ i ];
			} );
			return group;
		};
	}( legacy );

	/* config/options/groups/parseOptions.js */
	var parseOptions = function( optionGroup ) {

		var keys, parseOptions;
		keys = [
			'preserveWhitespace',
			'sanitize',
			'stripComments',
			'delimiters',
			'tripleDelimiters'
		];
		parseOptions = optionGroup( keys, function( key ) {
			return key;
		} );
		return parseOptions;
	}( optionGroup );

	/* config/options/template/parser.js */
	var parser = function( errors, isClient, parse, create, parseOptions ) {

		var parser = {
			parse: doParse,
			fromId: fromId,
			isHashedId: isHashedId,
			isParsed: isParsed,
			getParseOptions: getParseOptions,
			createHelper: createHelper
		};

		function createHelper( parseOptions ) {
			var helper = create( parser );
			helper.parse = function( template, options ) {
				return doParse( template, options || parseOptions );
			};
			return helper;
		}

		function doParse( template, parseOptions ) {
			if ( !parse ) {
				throw new Error( errors.missingParser );
			}
			return parse( template, parseOptions || this.options );
		}

		function fromId( id, options ) {
			var template;
			if ( !isClient ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );
			}
			if ( isHashedId( id ) ) {
				id = id.substring( 1 );
			}
			if ( !( template = document.getElementById( id ) ) ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Could not find template element with id #' + id );
			}
			// Do we want to turn this on?
			/*
            	if ( template.tagName.toUpperCase() !== 'SCRIPT' )) {
            		if ( options && options.noThrow ) { return; }
            		throw new Error( 'Template element with id #' + id + ', must be a <script> element' );
            	}
            	*/
			return template.innerHTML;
		}

		function isHashedId( id ) {
			return id.charAt( 0 ) === '#';
		}

		function isParsed( template ) {
			return !( typeof template === 'string' );
		}

		function getParseOptions( ractive ) {
			// Could be Ractive or a Component
			if ( ractive.defaults ) {
				ractive = ractive.defaults;
			}
			return parseOptions.reduce( function( val, key ) {
				val[ key ] = ractive[ key ];
				return val;
			}, {} );
		}
		return parser;
	}( errors, isClient, parse, create, parseOptions );

	/* config/options/template/template.js */
	var template = function( parser, parse ) {

		var templateConfig = {
			name: 'template',
			extend: function extend( Parent, proto, options ) {
				var template;
				// only assign if exists
				if ( 'template' in options ) {
					template = options.template;
					if ( typeof template === 'function' ) {
						proto.template = template;
					} else {
						proto.template = parseIfString( template, proto );
					}
				}
			},
			init: function init( Parent, ractive, options ) {
				var template, fn;
				// TODO because of prototypal inheritance, we might just be able to use
				// ractive.template, and not bother passing through the Parent object.
				// At present that breaks the test mocks' expectations
				template = 'template' in options ? options.template : Parent.prototype.template;
				if ( typeof template === 'function' ) {
					fn = template;
					template = getDynamicTemplate( ractive, fn );
					ractive._config.template = {
						fn: fn,
						result: template
					};
				}
				template = parseIfString( template, ractive );
				// TODO the naming of this is confusing - ractive.template refers to [...],
				// but Component.prototype.template refers to {v:1,t:[],p:[]}...
				// it's unnecessary, because the developer never needs to access
				// ractive.template
				ractive.template = template.t;
				if ( template.p ) {
					extendPartials( ractive.partials, template.p );
				}
			},
			reset: function( ractive ) {
				var result = resetValue( ractive ),
					parsed;
				if ( result ) {
					parsed = parseIfString( result, ractive );
					ractive.template = parsed.t;
					extendPartials( ractive.partials, parsed.p, true );
					return true;
				}
			}
		};

		function resetValue( ractive ) {
			var initial = ractive._config.template,
				result;
			// If this isn't a dynamic template, there's nothing to do
			if ( !initial || !initial.fn ) {
				return;
			}
			result = getDynamicTemplate( ractive, initial.fn );
			// TODO deep equality check to prevent unnecessary re-rendering
			// in the case of already-parsed templates
			if ( result !== initial.result ) {
				initial.result = result;
				result = parseIfString( result, ractive );
				return result;
			}
		}

		function getDynamicTemplate( ractive, fn ) {
			var helper = parser.createHelper( parser.getParseOptions( ractive ) );
			return fn.call( ractive, ractive.data, helper );
		}

		function parseIfString( template, ractive ) {
			if ( typeof template === 'string' ) {
				// ID of an element containing the template?
				if ( template[ 0 ] === '#' ) {
					template = parser.fromId( template );
				}
				template = parse( template, parser.getParseOptions( ractive ) );
			} else if ( template.v !== 1 ) {
				throw new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );
			}
			return template;
		}

		function extendPartials( existingPartials, newPartials, overwrite ) {
			if ( !newPartials )
				return;
			// TODO there's an ambiguity here - we need to overwrite in the `reset()`
			// case, but not initially...
			for ( var key in newPartials ) {
				if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
					existingPartials[ key ] = newPartials[ key ];
				}
			}
		}
		return templateConfig;
	}( parser, parse );

	/* config/options/Registry.js */
	var Registry = function( create ) {

		function Registry( name, useDefaults ) {
			this.name = name;
			this.useDefaults = useDefaults;
		}
		Registry.prototype = {
			constructor: Registry,
			extend: function( Parent, proto, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );
			},
			init: function( Parent, ractive, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );
			},
			configure: function( Parent, target, options ) {
				var name = this.name,
					option = options[ name ],
					registry;
				registry = create( Parent[ name ] );
				for ( var key in option ) {
					registry[ key ] = option[ key ];
				}
				target[ name ] = registry;
			},
			reset: function( ractive ) {
				var registry = ractive[ this.name ];
				var changed = false;
				Object.keys( registry ).forEach( function( key ) {
					var item = registry[ key ];
					if ( item._fn ) {
						if ( item._fn.isOwner ) {
							registry[ key ] = item._fn;
						} else {
							delete registry[ key ];
						}
						changed = true;
					}
				} );
				return changed;
			},
			findOwner: function( ractive, key ) {
				return ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );
			},
			findConstructor: function( constructor, key ) {
				if ( !constructor ) {
					return;
				}
				return constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );
			},
			find: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ];
				} );
			},
			findInstance: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ] ? r : void 0;
				} );
			}
		};

		function recurseFind( ractive, fn ) {
			var find, parent;
			if ( find = fn( ractive ) ) {
				return find;
			}
			if ( !ractive.isolated && ( parent = ractive._parent ) ) {
				return recurseFind( parent, fn );
			}
		}
		return Registry;
	}( create, legacy );

	/* config/options/groups/registries.js */
	var registries = function( optionGroup, Registry ) {

		var keys = [
				'adaptors',
				'components',
				'computed',
				'decorators',
				'easing',
				'events',
				'interpolators',
				'partials',
				'transitions'
			],
			registries = optionGroup( keys, function( key ) {
				return new Registry( key, key === 'computed' );
			} );
		return registries;
	}( optionGroup, Registry );

	/* utils/noop.js */
	var noop = function() {};

	/* utils/wrapPrototypeMethod.js */
	var wrapPrototypeMethod = function( noop ) {

		return function wrap( parent, name, method ) {
			if ( !/_super/.test( method ) ) {
				return method;
			}
			var wrapper = function wrapSuper() {
				var superMethod = getSuperMethod( wrapper._parent, name ),
					hasSuper = '_super' in this,
					oldSuper = this._super,
					result;
				this._super = superMethod;
				result = method.apply( this, arguments );
				if ( hasSuper ) {
					this._super = oldSuper;
				} else {
					delete this._super;
				}
				return result;
			};
			wrapper._parent = parent;
			wrapper._method = method;
			return wrapper;
		};

		function getSuperMethod( parent, name ) {
			var method;
			if ( name in parent ) {
				var value = parent[ name ];
				if ( typeof value === 'function' ) {
					method = value;
				} else {
					method = function returnValue() {
						return value;
					};
				}
			} else {
				method = noop;
			}
			return method;
		}
	}( noop );

	/* config/deprecate.js */
	var deprecate = function( warn, isArray ) {

		function deprecate( options, deprecated, correct ) {
			if ( deprecated in options ) {
				if ( !( correct in options ) ) {
					warn( getMessage( deprecated, correct ) );
					options[ correct ] = options[ deprecated ];
				} else {
					throw new Error( getMessage( deprecated, correct, true ) );
				}
			}
		}

		function getMessage( deprecated, correct, isError ) {
			return 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );
		}

		function deprecateEventDefinitions( options ) {
			deprecate( options, 'eventDefinitions', 'events' );
		}

		function deprecateAdaptors( options ) {
			// Using extend with Component instead of options,
			// like Human.extend( Spider ) means adaptors as a registry
			// gets copied to options. So we have to check if actually an array
			if ( isArray( options.adaptors ) ) {
				deprecate( options, 'adaptors', 'adapt' );
			}
		}
		return function deprecateOptions( options ) {
			deprecateEventDefinitions( options );
			deprecateAdaptors( options );
		};
	}( warn, isArray );

	/* config/config.js */
	var config = function( css, data, defaults, template, parseOptions, registries, wrap, deprecate ) {

		var custom, options, config;
		custom = {
			data: data,
			template: template,
			css: css
		};
		options = Object.keys( defaults ).filter( function( key ) {
			return !registries[ key ] && !custom[ key ] && !parseOptions[ key ];
		} );
		// this defines the order:
		config = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );
		for ( var key in custom ) {
			config[ key ] = custom[ key ];
		}
		// for iteration
		config.keys = Object.keys( defaults ).concat( registries.map( function( r ) {
			return r.name;
		} ) ).concat( [ 'css' ] );
		config.parseOptions = parseOptions;
		config.registries = registries;

		function customConfig( method, key, Parent, instance, options ) {
			custom[ key ][ method ]( Parent, instance, options );
		}
		config.extend = function( Parent, proto, options ) {
			configure( 'extend', Parent, proto, options );
		};
		config.init = function( Parent, ractive, options ) {
			configure( 'init', Parent, ractive, options );
			if ( ractive._config ) {
				ractive._config.options = options;
			}
		};

		function configure( method, Parent, instance, options ) {
			deprecate( options );
			customConfig( method, 'data', Parent, instance, options );
			config.parseOptions.forEach( function( key ) {
				if ( key in options ) {
					instance[ key ] = options[ key ];
				}
			} );
			for ( var key in options ) {
				if ( key in defaults && !( key in config.parseOptions ) && !( key in custom ) ) {
					var value = options[ key ];
					instance[ key ] = typeof value === 'function' ? wrap( Parent.prototype, key, value ) : value;
				}
			}
			config.registries.forEach( function( registry ) {
				registry[ method ]( Parent, instance, options );
			} );
			customConfig( method, 'template', Parent, instance, options );
			customConfig( method, 'css', Parent, instance, options );
		}
		config.reset = function( ractive ) {
			return config.filter( function( c ) {
				return c.reset && c.reset( ractive );
			} ).map( function( c ) {
				return c.name;
			} );
		};
		return config;
	}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );

	/* shared/interpolate.js */
	var interpolate = function( circular, warn, interpolators, config ) {

		var interpolate = function( from, to, ractive, type ) {
			if ( from === to ) {
				return snap( to );
			}
			if ( type ) {
				var interpol = config.registries.interpolators.find( ractive, type );
				if ( interpol ) {
					return interpol( from, to ) || snap( to );
				}
				warn( 'Missing "' + type + '" interpolator. You may need to download a plugin from [TODO]' );
			}
			return interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || interpolators.cssLength( from, to ) || snap( to );
		};
		circular.interpolate = interpolate;
		return interpolate;

		function snap( to ) {
			return function() {
				return to;
			};
		}
	}( circular, warn, interpolators, config );

	/* Ractive/prototype/animate/Animation.js */
	var Ractive$animate_Animation = function( warn, runloop, interpolate ) {

		var Animation = function( options ) {
			var key;
			this.startTime = Date.now();
			// from and to
			for ( key in options ) {
				if ( options.hasOwnProperty( key ) ) {
					this[ key ] = options[ key ];
				}
			}
			this.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );
			this.running = true;
		};
		Animation.prototype = {
			tick: function() {
				var elapsed, t, value, timeNow, index, keypath;
				keypath = this.keypath;
				if ( this.running ) {
					timeNow = Date.now();
					elapsed = timeNow - this.startTime;
					if ( elapsed >= this.duration ) {
						if ( keypath !== null ) {
							runloop.start( this.root );
							this.root.viewmodel.set( keypath, this.to );
							runloop.end();
						}
						if ( this.step ) {
							this.step( 1, this.to );
						}
						this.complete( this.to );
						index = this.root._animations.indexOf( this );
						// TODO investigate why this happens
						if ( index === -1 ) {
							warn( 'Animation was not found' );
						}
						this.root._animations.splice( index, 1 );
						this.running = false;
						return false;
					}
					t = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;
					if ( keypath !== null ) {
						value = this.interpolator( t );
						runloop.start( this.root );
						this.root.viewmodel.set( keypath, value );
						runloop.end();
					}
					if ( this.step ) {
						this.step( t, value );
					}
					return true;
				}
				return false;
			},
			stop: function() {
				var index;
				this.running = false;
				index = this.root._animations.indexOf( this );
				// TODO investigate why this happens
				if ( index === -1 ) {
					warn( 'Animation was not found' );
				}
				this.root._animations.splice( index, 1 );
			}
		};
		return Animation;
	}( warn, runloop, interpolate );

	/* Ractive/prototype/animate.js */
	var Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {

		var noop = function() {},
			noAnimation = {
				stop: noop
			};
		return function Ractive$animate( keypath, to, options ) {
			var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;
			promise = new Promise( function( fulfil ) {
				fulfilPromise = fulfil;
			} );
			// animate multiple keypaths
			if ( typeof keypath === 'object' ) {
				options = to || {};
				easing = options.easing;
				duration = options.duration;
				animations = [];
				// we don't want to pass the `step` and `complete` handlers, as they will
				// run for each animation! So instead we'll store the handlers and create
				// our own...
				step = options.step;
				complete = options.complete;
				if ( step || complete ) {
					currentValues = {};
					options.step = null;
					options.complete = null;
					makeValueCollector = function( keypath ) {
						return function( t, value ) {
							currentValues[ keypath ] = value;
						};
					};
				}
				for ( k in keypath ) {
					if ( keypath.hasOwnProperty( k ) ) {
						if ( step || complete ) {
							collectValue = makeValueCollector( k );
							options = {
								easing: easing,
								duration: duration
							};
							if ( step ) {
								options.step = collectValue;
							}
						}
						options.complete = complete ? collectValue : noop;
						animations.push( animate( this, k, keypath[ k ], options ) );
					}
				}
				if ( step || complete ) {
					dummyOptions = {
						easing: easing,
						duration: duration
					};
					if ( step ) {
						dummyOptions.step = function( t ) {
							step( t, currentValues );
						};
					}
					if ( complete ) {
						promise.then( function( t ) {
							complete( t, currentValues );
						} );
					}
					dummyOptions.complete = fulfilPromise;
					dummy = animate( this, null, null, dummyOptions );
					animations.push( dummy );
				}
				return {
					stop: function() {
						var animation;
						while ( animation = animations.pop() ) {
							animation.stop();
						}
						if ( dummy ) {
							dummy.stop();
						}
					}
				};
			}
			// animate a single keypath
			options = options || {};
			if ( options.complete ) {
				promise.then( options.complete );
			}
			options.complete = fulfilPromise;
			animation = animate( this, keypath, to, options );
			promise.stop = function() {
				animation.stop();
			};
			return promise;
		};

		function animate( root, keypath, to, options ) {
			var easing, duration, animation, from;
			if ( keypath ) {
				keypath = normaliseKeypath( keypath );
			}
			if ( keypath !== null ) {
				from = root.viewmodel.get( keypath );
			}
			// cancel any existing animation
			// TODO what about upstream/downstream keypaths?
			animations.abort( keypath, root );
			// don't bother animating values that stay the same
			if ( isEqual( from, to ) ) {
				if ( options.complete ) {
					options.complete( options.to );
				}
				return noAnimation;
			}
			// easing function
			if ( options.easing ) {
				if ( typeof options.easing === 'function' ) {
					easing = options.easing;
				} else {
					easing = root.easing[ options.easing ];
				}
				if ( typeof easing !== 'function' ) {
					easing = null;
				}
			}
			// duration
			duration = options.duration === undefined ? 400 : options.duration;
			// TODO store keys, use an internal set method
			animation = new Animation( {
				keypath: keypath,
				from: from,
				to: to,
				root: root,
				duration: duration,
				easing: easing,
				interpolator: options.interpolator,
				// TODO wrap callbacks if necessary, to use instance as context
				step: options.step,
				complete: options.complete
			} );
			animations.add( animation );
			root._animations.push( animation );
			return animation;
		}
	}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );

	/* Ractive/prototype/detach.js */
	var Ractive$detach = function( removeFromArray ) {

		return function Ractive$detach() {
			if ( this.el ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			return this.fragment.detach();
		};
	}( removeFromArray );

	/* Ractive/prototype/find.js */
	var Ractive$find = function Ractive$find( selector ) {
		if ( !this.el ) {
			return null;
		}
		return this.fragment.find( selector );
	};

	/* utils/matches.js */
	var matches = function( isClient, vendors, createElement ) {

		var matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;
		if ( !isClient ) {
			matches = null;
		} else {
			div = createElement( 'div' );
			methodNames = [
				'matches',
				'matchesSelector'
			];
			makeFunction = function( methodName ) {
				return function( node, selector ) {
					return node[ methodName ]( selector );
				};
			};
			i = methodNames.length;
			while ( i-- && !matches ) {
				unprefixed = methodNames[ i ];
				if ( div[ unprefixed ] ) {
					matches = makeFunction( unprefixed );
				} else {
					j = vendors.length;
					while ( j-- ) {
						prefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
						if ( div[ prefixed ] ) {
							matches = makeFunction( prefixed );
							break;
						}
					}
				}
			}
			// IE8...
			if ( !matches ) {
				matches = function( node, selector ) {
					var nodes, parentNode, i;
					parentNode = node.parentNode;
					if ( !parentNode ) {
						// empty dummy <div>
						div.innerHTML = '';
						parentNode = div;
						node = node.cloneNode();
						div.appendChild( node );
					}
					nodes = parentNode.querySelectorAll( selector );
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] === node ) {
							return true;
						}
					}
					return false;
				};
			}
		}
		return matches;
	}( isClient, vendors, createElement );

	/* Ractive/prototype/shared/makeQuery/test.js */
	var Ractive$shared_makeQuery_test = function( matches ) {

		return function( item, noDirty ) {
			var itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );
			if ( itemMatches ) {
				this.push( item.node || item.instance );
				if ( !noDirty ) {
					this._makeDirty();
				}
				return true;
			}
		};
	}( matches );

	/* Ractive/prototype/shared/makeQuery/cancel.js */
	var Ractive$shared_makeQuery_cancel = function() {
		var liveQueries, selector, index;
		liveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
		selector = this.selector;
		index = liveQueries.indexOf( selector );
		if ( index !== -1 ) {
			liveQueries.splice( index, 1 );
			liveQueries[ selector ] = null;
		}
	};

	/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */
	var Ractive$shared_makeQuery_sortByItemPosition = function() {

		return function( a, b ) {
			var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;
			ancestryA = getAncestry( a.component || a._ractive.proxy );
			ancestryB = getAncestry( b.component || b._ractive.proxy );
			oldestA = ancestryA[ ancestryA.length - 1 ];
			oldestB = ancestryB[ ancestryB.length - 1 ];
			// remove items from the end of both ancestries as long as they are identical
			// - the final one removed is the closest mutual ancestor
			while ( oldestA && oldestA === oldestB ) {
				ancestryA.pop();
				ancestryB.pop();
				mutualAncestor = oldestA;
				oldestA = ancestryA[ ancestryA.length - 1 ];
				oldestB = ancestryB[ ancestryB.length - 1 ];
			}
			// now that we have the mutual ancestor, we can find which is earliest
			oldestA = oldestA.component || oldestA;
			oldestB = oldestB.component || oldestB;
			fragmentA = oldestA.parentFragment;
			fragmentB = oldestB.parentFragment;
			// if both items share a parent fragment, our job is easy
			if ( fragmentA === fragmentB ) {
				indexA = fragmentA.items.indexOf( oldestA );
				indexB = fragmentB.items.indexOf( oldestB );
				// if it's the same index, it means one contains the other,
				// so we see which has the longest ancestry
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			// if mutual ancestor is a section, we first test to see which section
			// fragment comes first
			if ( fragments = mutualAncestor.fragments ) {
				indexA = fragments.indexOf( fragmentA );
				indexB = fragments.indexOf( fragmentB );
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );
		};

		function getParent( item ) {
			var parentFragment;
			if ( parentFragment = item.parentFragment ) {
				return parentFragment.owner;
			}
			if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
				return parentFragment.owner;
			}
		}

		function getAncestry( item ) {
			var ancestry, ancestor;
			ancestry = [ item ];
			ancestor = getParent( item );
			while ( ancestor ) {
				ancestry.push( ancestor );
				ancestor = getParent( ancestor );
			}
			return ancestry;
		}
	}();

	/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */
	var Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {

		return function( node, otherNode ) {
			var bitmask;
			if ( node.compareDocumentPosition ) {
				bitmask = node.compareDocumentPosition( otherNode );
				return bitmask & 2 ? 1 : -1;
			}
			// In old IE, we can piggy back on the mechanism for
			// comparing component positions
			return sortByItemPosition( node, otherNode );
		};
	}( Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/sort.js */
	var Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {

		return function() {
			this.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
			this._dirty = false;
		};
	}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/dirty.js */
	var Ractive$shared_makeQuery_dirty = function( runloop ) {

		return function() {
			var this$0 = this;
			if ( !this._dirty ) {
				this._dirty = true;
				// Once the DOM has been updated, ensure the query
				// is correctly ordered
				runloop.scheduleTask( function() {
					this$0._sort();
				} );
			}
		};
	}( runloop );

	/* Ractive/prototype/shared/makeQuery/remove.js */
	var Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {
		var index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
		if ( index !== -1 ) {
			this.splice( index, 1 );
		}
	};

	/* Ractive/prototype/shared/makeQuery/_makeQuery.js */
	var Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {

		return function makeQuery( ractive, selector, live, isComponentQuery ) {
			var query = [];
			defineProperties( query, {
				selector: {
					value: selector
				},
				live: {
					value: live
				},
				_isComponentQuery: {
					value: isComponentQuery
				},
				_test: {
					value: test
				}
			} );
			if ( !live ) {
				return query;
			}
			defineProperties( query, {
				cancel: {
					value: cancel
				},
				_root: {
					value: ractive
				},
				_sort: {
					value: sort
				},
				_makeDirty: {
					value: dirty
				},
				_remove: {
					value: remove
				},
				_dirty: {
					value: false,
					writable: true
				}
			} );
			return query;
		};
	}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );

	/* Ractive/prototype/findAll.js */
	var Ractive$findAll = function( makeQuery ) {

		return function Ractive$findAll( selector, options ) {
			var liveQueries, query;
			if ( !this.el ) {
				return [];
			}
			options = options || {};
			liveQueries = this._liveQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, false );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAll( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findAllComponents.js */
	var Ractive$findAllComponents = function( makeQuery ) {

		return function Ractive$findAllComponents( selector, options ) {
			var liveQueries, query;
			options = options || {};
			liveQueries = this._liveComponentQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, true );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAllComponents( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findComponent.js */
	var Ractive$findComponent = function Ractive$findComponent( selector ) {
		return this.fragment.findComponent( selector );
	};

	/* Ractive/prototype/fire.js */
	var Ractive$fire = function Ractive$fire( eventName ) {
		var args, i, len, subscribers = this._subs[ eventName ];
		if ( !subscribers ) {
			return;
		}
		args = Array.prototype.slice.call( arguments, 1 );
		for ( i = 0, len = subscribers.length; i < len; i += 1 ) {
			subscribers[ i ].apply( this, args );
		}
	};

	/* Ractive/prototype/get.js */
	var Ractive$get = function( normaliseKeypath ) {

		var options = {
			capture: true
		};
		// top-level calls should be intercepted
		return function Ractive$get( keypath ) {
			keypath = normaliseKeypath( keypath );
			return this.viewmodel.get( keypath, options );
		};
	}( normaliseKeypath );

	/* utils/getElement.js */
	var getElement = function getElement( input ) {
		var output;
		if ( !input || typeof input === 'boolean' ) {
			return;
		}
		if ( typeof window === 'undefined' || !document || !input ) {
			return null;
		}
		// We already have a DOM node - no work to do. (Duck typing alert!)
		if ( input.nodeType ) {
			return input;
		}
		// Get node from string
		if ( typeof input === 'string' ) {
			// try ID first
			output = document.getElementById( input );
			// then as selector, if possible
			if ( !output && document.querySelector ) {
				output = document.querySelector( input );
			}
			// did it work?
			if ( output && output.nodeType ) {
				return output;
			}
		}
		// If we've been given a collection (jQuery, Zepto etc), extract the first item
		if ( input[ 0 ] && input[ 0 ].nodeType ) {
			return input[ 0 ];
		}
		return null;
	};

	/* Ractive/prototype/insert.js */
	var Ractive$insert = function( getElement ) {

		return function Ractive$insert( target, anchor ) {
			if ( !this.rendered ) {
				// TODO create, and link to, documentation explaining this
				throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
			}
			target = getElement( target );
			anchor = getElement( anchor ) || null;
			if ( !target ) {
				throw new Error( 'You must specify a valid target to insert into' );
			}
			target.insertBefore( this.detach(), anchor );
			this.el = target;
			( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
		};
	}( getElement );

	/* Ractive/prototype/merge.js */
	var Ractive$merge = function( runloop, isArray, normaliseKeypath ) {

		return function Ractive$merge( keypath, array, options ) {
			var currentArray, promise;
			keypath = normaliseKeypath( keypath );
			currentArray = this.viewmodel.get( keypath );
			// If either the existing value or the new value isn't an
			// array, just do a regular set
			if ( !isArray( currentArray ) || !isArray( array ) ) {
				return this.set( keypath, array, options && options.complete );
			}
			// Manage transitions
			promise = runloop.start( this, true );
			this.viewmodel.merge( keypath, currentArray, array, options );
			runloop.end();
			// attach callback as fulfilment handler, if specified
			if ( options && options.complete ) {
				promise.then( options.complete );
			}
			return promise;
		};
	}( runloop, isArray, normaliseKeypath );

	/* Ractive/prototype/observe/Observer.js */
	var Ractive$observe_Observer = function( runloop, isEqual ) {

		var Observer = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.keypath = keypath;
			this.callback = callback;
			this.defer = options.defer;
			// Observers are notified before any DOM changes take place (though
			// they can defer execution until afterwards)
			this.priority = 0;
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		Observer.prototype = {
			init: function( immediate ) {
				this.value = this.root.viewmodel.get( this.keypath );
				if ( immediate !== false ) {
					this.update();
				}
			},
			setValue: function( value ) {
				var this$0 = this;
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					if ( this.defer && this.ready ) {
						runloop.scheduleTask( function() {
							return this$0.update();
						} );
					} else {
						this.update();
					}
				}
			},
			update: function() {
				// Prevent infinite loops
				if ( this.updating ) {
					return;
				}
				this.updating = true;
				this.callback.call( this.context, this.value, this.oldValue, this.keypath );
				this.oldValue = this.value;
				this.updating = false;
			}
		};
		return Observer;
	}( runloop, isEqual );

	/* shared/getMatchingKeypaths.js */
	var getMatchingKeypaths = function( isArray ) {

		return function getMatchingKeypaths( ractive, pattern ) {
			var keys, key, matchingKeypaths;
			keys = pattern.split( '.' );
			matchingKeypaths = [ '' ];
			while ( key = keys.shift() ) {
				if ( key === '*' ) {
					// expand to find all valid child keypaths
					matchingKeypaths = matchingKeypaths.reduce( expand, [] );
				} else {
					if ( matchingKeypaths[ 0 ] === '' ) {
						// first key
						matchingKeypaths[ 0 ] = key;
					} else {
						matchingKeypaths = matchingKeypaths.map( concatenate( key ) );
					}
				}
			}
			return matchingKeypaths;

			function expand( matchingKeypaths, keypath ) {
				var value, key, childKeypath;
				value = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );
				for ( key in value ) {
					if ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {
						// for benefit of IE8
						childKeypath = keypath ? keypath + '.' + key : key;
						matchingKeypaths.push( childKeypath );
					}
				}
				return matchingKeypaths;
			}

			function concatenate( key ) {
				return function( keypath ) {
					return keypath ? keypath + '.' + key : key;
				};
			}
		};
	}( isArray );

	/* Ractive/prototype/observe/getPattern.js */
	var Ractive$observe_getPattern = function( getMatchingKeypaths ) {

		return function getPattern( ractive, pattern ) {
			var matchingKeypaths, values;
			matchingKeypaths = getMatchingKeypaths( ractive, pattern );
			values = {};
			matchingKeypaths.forEach( function( keypath ) {
				values[ keypath ] = ractive.get( keypath );
			} );
			return values;
		};
	}( getMatchingKeypaths );

	/* Ractive/prototype/observe/PatternObserver.js */
	var Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {

		var PatternObserver, wildcard = /\*/,
			slice = Array.prototype.slice;
		PatternObserver = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.callback = callback;
			this.defer = options.defer;
			this.keypath = keypath;
			this.regex = new RegExp( '^' + keypath.replace( /\./g, '\\.' ).replace( /\*/g, '([^\\.]+)' ) + '$' );
			this.values = {};
			if ( this.defer ) {
				this.proxies = [];
			}
			// Observers are notified before any DOM changes take place (though
			// they can defer execution until afterwards)
			this.priority = 'pattern';
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		PatternObserver.prototype = {
			init: function( immediate ) {
				var values, keypath;
				values = getPattern( this.root, this.keypath );
				if ( immediate !== false ) {
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
				} else {
					this.values = values;
				}
			},
			update: function( keypath ) {
				var values;
				if ( wildcard.test( keypath ) ) {
					values = getPattern( this.root, keypath );
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
					return;
				}
				// special case - array mutation should not trigger `array.*`
				// pattern observer with `array.length`
				if ( this.root.viewmodel.implicitChanges[ keypath ] ) {
					return;
				}
				if ( this.defer && this.ready ) {
					runloop.addObserver( this.getProxy( keypath ) );
					return;
				}
				this.reallyUpdate( keypath );
			},
			reallyUpdate: function( keypath ) {
				var value, keys, args;
				value = this.root.viewmodel.get( keypath );
				// Prevent infinite loops
				if ( this.updating ) {
					this.values[ keypath ] = value;
					return;
				}
				this.updating = true;
				if ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {
					keys = slice.call( this.regex.exec( keypath ), 1 );
					args = [
						value,
						this.values[ keypath ],
						keypath
					].concat( keys );
					this.callback.apply( this.context, args );
					this.values[ keypath ] = value;
				}
				this.updating = false;
			},
			getProxy: function( keypath ) {
				var self = this;
				if ( !this.proxies[ keypath ] ) {
					this.proxies[ keypath ] = {
						update: function() {
							self.reallyUpdate( keypath );
						}
					};
				}
				return this.proxies[ keypath ];
			}
		};
		return PatternObserver;
	}( runloop, isEqual, Ractive$observe_getPattern );

	/* Ractive/prototype/observe/getObserverFacade.js */
	var Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {

		var wildcard = /\*/,
			emptyObject = {};
		return function getObserverFacade( ractive, keypath, callback, options ) {
			var observer, isPatternObserver, cancelled;
			keypath = normaliseKeypath( keypath );
			options = options || emptyObject;
			// pattern observers are treated differently
			if ( wildcard.test( keypath ) ) {
				observer = new PatternObserver( ractive, keypath, callback, options );
				ractive.viewmodel.patternObservers.push( observer );
				isPatternObserver = true;
			} else {
				observer = new Observer( ractive, keypath, callback, options );
			}
			ractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );
			observer.init( options.init );
			// This flag allows observers to initialise even with undefined values
			observer.ready = true;
			return {
				cancel: function() {
					var index;
					if ( cancelled ) {
						return;
					}
					if ( isPatternObserver ) {
						index = ractive.viewmodel.patternObservers.indexOf( observer );
						ractive.viewmodel.patternObservers.splice( index, 1 );
						ractive.viewmodel.unregister( keypath, observer, 'patternObservers' );
					}
					ractive.viewmodel.unregister( keypath, observer, 'observers' );
					cancelled = true;
				}
			};
		};
	}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );

	/* Ractive/prototype/observe.js */
	var Ractive$observe = function( isObject, getObserverFacade ) {

		return function Ractive$observe( keypath, callback, options ) {
			var observers, map, keypaths, i;
			// Allow a map of keypaths to handlers
			if ( isObject( keypath ) ) {
				options = callback;
				map = keypath;
				observers = [];
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						callback = map[ keypath ];
						observers.push( this.observe( keypath, callback, options ) );
					}
				}
				return {
					cancel: function() {
						while ( observers.length ) {
							observers.pop().cancel();
						}
					}
				};
			}
			// Allow `ractive.observe( callback )` - i.e. observe entire model
			if ( typeof keypath === 'function' ) {
				options = callback;
				callback = keypath;
				keypath = '';
				return getObserverFacade( this, keypath, callback, options );
			}
			keypaths = keypath.split( ' ' );
			// Single keypath
			if ( keypaths.length === 1 ) {
				return getObserverFacade( this, keypath, callback, options );
			}
			// Multiple space-separated keypaths
			observers = [];
			i = keypaths.length;
			while ( i-- ) {
				keypath = keypaths[ i ];
				if ( keypath ) {
					observers.push( getObserverFacade( this, keypath, callback, options ) );
				}
			}
			return {
				cancel: function() {
					while ( observers.length ) {
						observers.pop().cancel();
					}
				}
			};
		};
	}( isObject, Ractive$observe_getObserverFacade );

	/* Ractive/prototype/shared/trim.js */
	var Ractive$shared_trim = function( str ) {
		return str.trim();
	};

	/* Ractive/prototype/shared/notEmptyString.js */
	var Ractive$shared_notEmptyString = function( str ) {
		return str !== '';
	};

	/* Ractive/prototype/off.js */
	var Ractive$off = function( trim, notEmptyString ) {

		return function Ractive$off( eventName, callback ) {
			var this$0 = this;
			var eventNames;
			// if no arguments specified, remove all callbacks
			if ( !eventName ) {
				// TODO use this code instead, once the following issue has been resolved
				// in PhantomJS (tests are unpassable otherwise!)
				// https://github.com/ariya/phantomjs/issues/11856
				// defineProperty( this, '_subs', { value: create( null ), configurable: true });
				for ( eventName in this._subs ) {
					delete this._subs[ eventName ];
				}
			} else {
				// Handle multiple space-separated event names
				eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
				eventNames.forEach( function( eventName ) {
					var subscribers, index;
					// If we have subscribers for this event...
					if ( subscribers = this$0._subs[ eventName ] ) {
						// ...if a callback was specified, only remove that
						if ( callback ) {
							index = subscribers.indexOf( callback );
							if ( index !== -1 ) {
								subscribers.splice( index, 1 );
							}
						} else {
							this$0._subs[ eventName ] = [];
						}
					}
				} );
			}
			return this;
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* Ractive/prototype/on.js */
	var Ractive$on = function( trim, notEmptyString ) {

		return function Ractive$on( eventName, callback ) {
			var this$0 = this;
			var self = this,
				listeners, n, eventNames;
			// allow mutliple listeners to be bound in one go
			if ( typeof eventName === 'object' ) {
				listeners = [];
				for ( n in eventName ) {
					if ( eventName.hasOwnProperty( n ) ) {
						listeners.push( this.on( n, eventName[ n ] ) );
					}
				}
				return {
					cancel: function() {
						var listener;
						while ( listener = listeners.pop() ) {
							listener.cancel();
						}
					}
				};
			}
			// Handle multiple space-separated event names
			eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
			eventNames.forEach( function( eventName ) {
				( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );
			} );
			return {
				cancel: function() {
					self.off( eventName, callback );
				}
			};
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* shared/getSpliceEquivalent.js */
	var getSpliceEquivalent = function( array, methodName, args ) {
		switch ( methodName ) {
			case 'splice':
				return args;
			case 'sort':
			case 'reverse':
				return null;
			case 'pop':
				if ( array.length ) {
					return [ -1 ];
				}
				return null;
			case 'push':
				return [
					array.length,
					0
				].concat( args );
			case 'shift':
				return [
					0,
					1
				];
			case 'unshift':
				return [
					0,
					0
				].concat( args );
		}
	};

	/* shared/summariseSpliceOperation.js */
	var summariseSpliceOperation = function( array, args ) {
		var rangeStart, rangeEnd, newLength, addedItems, removedItems, balance;
		if ( !args ) {
			return null;
		}
		// figure out where the changes started...
		rangeStart = +( args[ 0 ] < 0 ? array.length + args[ 0 ] : args[ 0 ] );
		// ...and how many items were added to or removed from the array
		addedItems = Math.max( 0, args.length - 2 );
		removedItems = args[ 1 ] !== undefined ? args[ 1 ] : array.length - rangeStart;
		// It's possible to do e.g. [ 1, 2, 3 ].splice( 2, 2 ) - i.e. the second argument
		// means removing more items from the end of the array than there are. In these
		// cases we need to curb JavaScript's enthusiasm or we'll get out of sync
		removedItems = Math.min( removedItems, array.length - rangeStart );
		balance = addedItems - removedItems;
		newLength = array.length + balance;
		// We need to find the end of the range affected by the splice
		if ( !balance ) {
			rangeEnd = rangeStart + addedItems;
		} else {
			rangeEnd = Math.max( array.length, newLength );
		}
		return {
			rangeStart: rangeStart,
			rangeEnd: rangeEnd,
			balance: balance,
			added: addedItems,
			removed: removedItems
		};
	};

	/* Ractive/prototype/shared/makeArrayMethod.js */
	var Ractive$shared_makeArrayMethod = function( isArray, runloop, getSpliceEquivalent, summariseSpliceOperation ) {

		var arrayProto = Array.prototype;
		return function( methodName ) {
			return function( keypath ) {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 1 );
				var array, spliceEquivalent, spliceSummary, promise;
				array = this.get( keypath );
				if ( !isArray( array ) ) {
					throw new Error( 'Called ractive.' + methodName + '(\'' + keypath + '\'), but \'' + keypath + '\' does not refer to an array' );
				}
				spliceEquivalent = getSpliceEquivalent( array, methodName, args );
				spliceSummary = summariseSpliceOperation( array, spliceEquivalent );
				arrayProto[ methodName ].apply( array, args );
				promise = runloop.start( this, true );
				if ( spliceSummary ) {
					this.viewmodel.splice( keypath, spliceSummary );
				} else {
					this.viewmodel.mark( keypath );
				}
				runloop.end();
				return promise;
			};
		};
	}( isArray, runloop, getSpliceEquivalent, summariseSpliceOperation );

	/* Ractive/prototype/pop.js */
	var Ractive$pop = function( makeArrayMethod ) {

		return makeArrayMethod( 'pop' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/push.js */
	var Ractive$push = function( makeArrayMethod ) {

		return makeArrayMethod( 'push' );
	}( Ractive$shared_makeArrayMethod );

	/* global/css.js */
	var global_css = function( circular, isClient, removeFromArray ) {

		var css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\n',
			componentsInPage = {},
			styles = [];
		if ( !isClient ) {
			css = null;
		} else {
			circular.push( function() {
				runloop = circular.runloop;
			} );
			styleElement = document.createElement( 'style' );
			styleElement.type = 'text/css';
			head = document.getElementsByTagName( 'head' )[ 0 ];
			inDom = false;
			// Internet Exploder won't let you use styleSheet.innerHTML - we have to
			// use styleSheet.cssText instead
			styleSheet = styleElement.styleSheet;
			update = function() {
				var css;
				if ( styles.length ) {
					css = prefix + styles.join( ' ' );
					if ( styleSheet ) {
						styleSheet.cssText = css;
					} else {
						styleElement.innerHTML = css;
					}
					if ( !inDom ) {
						head.appendChild( styleElement );
						inDom = true;
					}
				} else if ( inDom ) {
					head.removeChild( styleElement );
					inDom = false;
				}
			};
			css = {
				add: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					if ( !componentsInPage[ Component._guid ] ) {
						// we create this counter so that we can in/decrement it as
						// instances are added and removed. When all components are
						// removed, the style is too
						componentsInPage[ Component._guid ] = 0;
						styles.push( Component.css );
						runloop.scheduleTask( update );
					}
					componentsInPage[ Component._guid ] += 1;
				},
				remove: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					componentsInPage[ Component._guid ] -= 1;
					if ( !componentsInPage[ Component._guid ] ) {
						removeFromArray( styles, Component.css );
						runloop.scheduleTask( update );
					}
				}
			};
		}
		return css;
	}( circular, isClient, removeFromArray );

	/* Ractive/prototype/render.js */
	var Ractive$render = function( runloop, css, getElement ) {

		var queues = {},
			rendering = {};
		return function Ractive$render( target, anchor ) {
			var this$0 = this;
			var promise, instances;
			rendering[ this._guid ] = true;
			promise = runloop.start( this, true );
			if ( this.rendered ) {
				throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
			}
			target = getElement( target ) || this.el;
			anchor = getElement( anchor ) || this.anchor;
			this.el = target;
			this.anchor = anchor;
			// Add CSS, if applicable
			if ( this.constructor.css ) {
				css.add( this.constructor );
			}
			if ( target ) {
				if ( !( instances = target.__ractive_instances__ ) ) {
					target.__ractive_instances__ = [ this ];
				} else {
					instances.push( this );
				}
				if ( anchor ) {
					target.insertBefore( this.fragment.render(), anchor );
				} else {
					target.appendChild( this.fragment.render() );
				}
			}
			// Only init once, until we rework lifecycle events
			if ( !this._hasInited ) {
				this._hasInited = true;
				// If this is *isn't* a child of a component that's in the process of rendering,
				// it should call any `init()` methods at this point
				if ( !this._parent || !rendering[ this._parent._guid ] ) {
					init( this );
				} else {
					getChildInitQueue( this._parent ).push( this );
				}
			}
			rendering[ this._guid ] = false;
			runloop.end();
			this.rendered = true;
			if ( this.complete ) {
				promise.then( function() {
					return this$0.complete();
				} );
			}
			return promise;
		};

		function init( instance ) {
			if ( instance.init ) {
				instance.init( instance._config.options );
			}
			getChildInitQueue( instance ).forEach( init );
			queues[ instance._guid ] = null;
		}

		function getChildInitQueue( instance ) {
			return queues[ instance._guid ] || ( queues[ instance._guid ] = [] );
		}
	}( runloop, global_css, getElement );

	/* virtualdom/Fragment/prototype/bubble.js */
	var virtualdom_Fragment$bubble = function Fragment$bubble() {
		this.dirtyValue = this.dirtyArgs = true;
		if ( this.inited && this.owner.bubble ) {
			this.owner.bubble();
		}
	};

	/* virtualdom/Fragment/prototype/detach.js */
	var virtualdom_Fragment$detach = function Fragment$detach() {
		var docFrag;
		if ( this.items.length === 1 ) {
			return this.items[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.items.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/Fragment/prototype/find.js */
	var virtualdom_Fragment$find = function Fragment$find( selector ) {
		var i, len, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.find && ( queryResult = item.find( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findAll.js */
	var virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAll ) {
					item.findAll( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findAllComponents.js */
	var virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAllComponents ) {
					item.findAllComponents( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findComponent.js */
	var virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {
		var len, i, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findNextNode.js */
	var virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {
		var index = item.index,
			node;
		if ( this.items[ index + 1 ] ) {
			node = this.items[ index + 1 ].firstNode();
		} else if ( this.owner === this.root ) {
			if ( !this.owner.component ) {
				// TODO but something else could have been appended to
				// this.root.el, no?
				node = null;
			} else {
				node = this.owner.component.findNextNode();
			}
		} else {
			node = this.owner.findNextNode( this );
		}
		return node;
	};

	/* virtualdom/Fragment/prototype/firstNode.js */
	var virtualdom_Fragment$firstNode = function Fragment$firstNode() {
		if ( this.items && this.items[ 0 ] ) {
			return this.items[ 0 ].firstNode();
		}
		return null;
	};

	/* virtualdom/Fragment/prototype/getNode.js */
	var virtualdom_Fragment$getNode = function Fragment$getNode() {
		var fragment = this;
		do {
			if ( fragment.pElement ) {
				return fragment.pElement.node;
			}
		} while ( fragment = fragment.parent );
		return this.root.el;
	};

	/* virtualdom/Fragment/prototype/getValue.js */
	var virtualdom_Fragment$getValue = function( parseJSON ) {

		var empty = {};
		return function Fragment$getValue() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = empty;
			var asArgs, values, source, parsed, cachedResult, dirtyFlag, result;
			asArgs = options.args;
			cachedResult = asArgs ? 'argsList' : 'value';
			dirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';
			if ( this[ dirtyFlag ] ) {
				source = processItems( this.items, values = {}, this.root._guid );
				parsed = parseJSON( asArgs ? '[' + source + ']' : source, values );
				if ( !parsed ) {
					result = asArgs ? [ this.toString() ] : this.toString();
				} else {
					result = parsed.value;
				}
				this[ cachedResult ] = result;
				this[ dirtyFlag ] = false;
			}
			return this[ cachedResult ];
		};

		function processItems( items, values, guid, counter ) {
			counter = counter || 0;
			return items.map( function( item ) {
				var placeholderId, wrapped, value;
				if ( item.text ) {
					return item.text;
				}
				if ( item.fragments ) {
					return item.fragments.map( function( fragment ) {
						return processItems( fragment.items, values, guid, counter );
					} ).join( '' );
				}
				placeholderId = guid + '-' + counter++;
				if ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {
					value = wrapped.value;
				} else {
					value = item.getValue();
				}
				values[ placeholderId ] = value;
				return '${' + placeholderId + '}';
			} ).join( '' );
		}
	}( parseJSON );

	/* utils/escapeHtml.js */
	var escapeHtml = function() {

		var lessThan = /</g,
			greaterThan = />/g;
		return function escapeHtml( str ) {
			return str.replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );
		};
	}();

	/* utils/detachNode.js */
	var detachNode = function detachNode( node ) {
		if ( node && node.parentNode ) {
			node.parentNode.removeChild( node );
		}
		return node;
	};

	/* virtualdom/items/shared/detach.js */
	var detach = function( detachNode ) {

		return function() {
			return detachNode( this.node );
		};
	}( detachNode );

	/* virtualdom/items/Text.js */
	var Text = function( types, escapeHtml, detach ) {

		var Text = function( options ) {
			this.type = types.TEXT;
			this.text = options.template;
		};
		Text.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.text );
				}
				return this.node;
			},
			toString: function( escape ) {
				return escape ? escapeHtml( this.text ) : this.text;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					return this.detach();
				}
			}
		};
		return Text;
	}( types, escapeHtml, detach );

	/* virtualdom/items/shared/unbind.js */
	var unbind = function( runloop ) {

		return function unbind() {
			if ( !this.keypath ) {
				// this was on the 'unresolved' list, we need to remove it
				runloop.removeUnresolved( this );
			} else {
				// this was registered as a dependant
				this.root.viewmodel.unregister( this.keypath, this );
			}
			if ( this.resolver ) {
				this.resolver.teardown();
			}
		};
	}( runloop );

	/* virtualdom/items/shared/Mustache/getValue.js */
	var getValue = function Mustache$getValue() {
		return this.value;
	};

	/* shared/Unresolved.js */
	var Unresolved = function( runloop ) {

		var Unresolved = function( ractive, ref, parentFragment, callback ) {
			this.root = ractive;
			this.ref = ref;
			this.parentFragment = parentFragment;
			this.resolve = callback;
			runloop.addUnresolved( this );
		};
		Unresolved.prototype = {
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return Unresolved;
	}( runloop );

	/* virtualdom/items/shared/utils/startsWithKeypath.js */
	var startsWithKeypath = function startsWithKeypath( target, keypath ) {
		return target.substr( 0, keypath.length + 1 ) === keypath + '.';
	};

	/* virtualdom/items/shared/utils/getNewKeypath.js */
	var getNewKeypath = function( startsWithKeypath ) {

		return function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {
			// exact match
			if ( targetKeypath === oldKeypath ) {
				return newKeypath;
			}
			// partial match based on leading keypath segments
			if ( startsWithKeypath( targetKeypath, oldKeypath ) ) {
				return targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );
			}
		};
	}( startsWithKeypath );

	/* utils/log.js */
	var log = function( consolewarn, errors ) {

		var log = {
			warn: function( options, passthru ) {
				if ( !options.debug && !passthru ) {
					return;
				}
				this.logger( getMessage( options ), options.allowDuplicates );
			},
			error: function( options ) {
				this.errorOnly( options );
				if ( !options.debug ) {
					this.warn( options, true );
				}
			},
			errorOnly: function( options ) {
				if ( options.debug ) {
					this.critical( options );
				}
			},
			critical: function( options ) {
				var err = options.err || new Error( getMessage( options ) );
				this.thrower( err );
			},
			logger: consolewarn,
			thrower: function( err ) {
				throw err;
			}
		};

		function getMessage( options ) {
			var message = errors[ options.message ] || options.message || '';
			return interpolate( message, options.args );
		}
		// simple interpolation. probably quicker (and better) out there,
		// but log is not in golden path of execution, only exceptions
		function interpolate( message, args ) {
			return message.replace( /{([^{}]*)}/g, function( a, b ) {
				return args[ b ];
			} );
		}
		return log;
	}( warn, errors );

	/* viewmodel/Computation/diff.js */
	var diff = function diff( computation, dependencies, newDependencies ) {
		var i, keypath;
		// remove dependencies that are no longer used
		i = dependencies.length;
		while ( i-- ) {
			keypath = dependencies[ i ];
			if ( newDependencies.indexOf( keypath ) === -1 ) {
				computation.viewmodel.unregister( keypath, computation, 'computed' );
			}
		}
		// create references for any new dependencies
		i = newDependencies.length;
		while ( i-- ) {
			keypath = newDependencies[ i ];
			if ( dependencies.indexOf( keypath ) === -1 ) {
				computation.viewmodel.register( keypath, computation, 'computed' );
			}
		}
		computation.dependencies = newDependencies.slice();
	};

	/* virtualdom/items/shared/Evaluator/Evaluator.js */
	var Evaluator = function( log, isEqual, defineProperty, diff ) {

		// TODO this is a red flag... should be treated the same?
		var Evaluator, cache = {};
		Evaluator = function( root, keypath, uniqueString, functionStr, args, priority ) {
			var evaluator = this,
				viewmodel = root.viewmodel;
			evaluator.root = root;
			evaluator.viewmodel = viewmodel;
			evaluator.uniqueString = uniqueString;
			evaluator.keypath = keypath;
			evaluator.priority = priority;
			evaluator.fn = getFunctionFromString( functionStr, args.length );
			evaluator.explicitDependencies = [];
			evaluator.dependencies = [];
			// created by `this.get()` within functions
			evaluator.argumentGetters = args.map( function( arg ) {
				var keypath, index;
				if ( !arg ) {
					return void 0;
				}
				if ( arg.indexRef ) {
					index = arg.value;
					return index;
				}
				keypath = arg.keypath;
				evaluator.explicitDependencies.push( keypath );
				viewmodel.register( keypath, evaluator, 'computed' );
				return function() {
					var value = viewmodel.get( keypath );
					return typeof value === 'function' ? wrap( value, root ) : value;
				};
			} );
		};
		Evaluator.prototype = {
			wake: function() {
				this.awake = true;
			},
			sleep: function() {
				this.awake = false;
			},
			getValue: function() {
				var args, value, newImplicitDependencies;
				args = this.argumentGetters.map( call );
				if ( this.updating ) {
					// Prevent infinite loops caused by e.g. in-place array mutations
					return;
				}
				this.updating = true;
				this.viewmodel.capture();
				try {
					value = this.fn.apply( null, args );
				} catch ( err ) {
					if ( this.root.debug ) {
						log.warn( {
							debug: this.root.debug,
							message: 'evaluationError',
							args: {
								uniqueString: this.uniqueString,
								err: err.message || err
							}
						} );
					}
					value = undefined;
				}
				newImplicitDependencies = this.viewmodel.release();
				diff( this, this.dependencies, newImplicitDependencies );
				this.updating = false;
				return value;
			},
			update: function() {
				var value = this.getValue();
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					this.root.viewmodel.mark( this.keypath );
				}
				return this;
			},
			// TODO should evaluators ever get torn down? At present, they don't...
			teardown: function() {
				var this$0 = this;
				this.explicitDependencies.concat( this.dependencies ).forEach( function( keypath ) {
					return this$0.viewmodel.unregister( keypath, this$0, 'computed' );
				} );
				this.root.viewmodel.evaluators[ this.keypath ] = null;
			}
		};
		return Evaluator;

		function getFunctionFromString( str, i ) {
			var fn, args;
			str = str.replace( /\$\{([0-9]+)\}/g, '_$1' );
			if ( cache[ str ] ) {
				return cache[ str ];
			}
			args = [];
			while ( i-- ) {
				args[ i ] = '_' + i;
			}
			fn = new Function( args.join( ',' ), 'return(' + str + ')' );
			cache[ str ] = fn;
			return fn;
		}

		function wrap( fn, ractive ) {
			var wrapped, prop;
			if ( fn._noWrap ) {
				return fn;
			}
			prop = '__ractive_' + ractive._guid;
			wrapped = fn[ prop ];
			if ( wrapped ) {
				return wrapped;
			} else if ( /this/.test( fn.toString() ) ) {
				defineProperty( fn, prop, {
					value: fn.bind( ractive )
				} );
				return fn[ prop ];
			}
			defineProperty( fn, '__ractive_nowrap', {
				value: fn
			} );
			return fn.__ractive_nowrap;
		}

		function call( arg ) {
			return typeof arg === 'function' ? arg() : arg;
		}
	}( log, isEqual, defineProperty, diff );

	/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */
	var ExpressionResolver = function( removeFromArray, resolveRef, Unresolved, Evaluator, getNewKeypath ) {

		var ExpressionResolver = function( owner, parentFragment, expression, callback ) {
			var expressionResolver = this,
				ractive, indexRefs, args;
			ractive = owner.root;
			this.root = ractive;
			this.callback = callback;
			this.owner = owner;
			this.str = expression.s;
			this.args = args = [];
			this.unresolved = [];
			this.pending = 0;
			indexRefs = parentFragment.indexRefs;
			// some expressions don't have references. edge case, but, yeah.
			if ( !expression.r || !expression.r.length ) {
				this.resolved = this.ready = true;
				this.bubble();
				return;
			}
			// Create resolvers for each reference
			expression.r.forEach( function( reference, i ) {
				var index, keypath, unresolved;
				// Is this an index reference?
				if ( indexRefs && ( index = indexRefs[ reference ] ) !== undefined ) {
					args[ i ] = {
						indexRef: reference,
						value: index
					};
					return;
				}
				// Can we resolve it immediately?
				if ( keypath = resolveRef( ractive, reference, parentFragment ) ) {
					args[ i ] = {
						keypath: keypath
					};
					return;
				}
				// Couldn't resolve yet
				args[ i ] = null;
				expressionResolver.pending += 1;
				unresolved = new Unresolved( ractive, reference, parentFragment, function( keypath ) {
					expressionResolver.resolve( i, keypath );
					removeFromArray( expressionResolver.unresolved, unresolved );
				} );
				expressionResolver.unresolved.push( unresolved );
			} );
			this.ready = true;
			this.bubble();
		};
		ExpressionResolver.prototype = {
			bubble: function() {
				if ( !this.ready ) {
					return;
				}
				this.uniqueString = getUniqueString( this.str, this.args );
				this.keypath = getKeypath( this.uniqueString );
				this.createEvaluator();
				this.callback( this.keypath );
			},
			teardown: function() {
				var unresolved;
				while ( unresolved = this.unresolved.pop() ) {
					unresolved.teardown();
				}
			},
			resolve: function( index, keypath ) {
				this.args[ index ] = {
					keypath: keypath
				};
				this.bubble();
				// when all references have been resolved, we can flag the entire expression
				// as having been resolved
				this.resolved = !--this.pending;
			},
			createEvaluator: function() {
				var evaluator = this.root.viewmodel.evaluators[ this.keypath ];
				// only if it doesn't exist yet!
				if ( !evaluator ) {
					evaluator = new Evaluator( this.root, this.keypath, this.uniqueString, this.str, this.args, this.owner.priority );
					this.root.viewmodel.evaluators[ this.keypath ] = evaluator;
				}
				evaluator.update();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.args.forEach( function( arg ) {
					var changedKeypath;
					if ( !arg )
						return;
					if ( arg.keypath && ( changedKeypath = getNewKeypath( arg.keypath, oldKeypath, newKeypath ) ) ) {
						arg.keypath = changedKeypath;
						changed = true;
					} else if ( arg.indexRef && arg.indexRef === indexRef ) {
						arg.value = newIndex;
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			}
		};
		return ExpressionResolver;

		function getUniqueString( str, args ) {
			// get string that is unique to this expression
			return str.replace( /\$\{([0-9]+)\}/g, function( match, $1 ) {
				var arg = args[ $1 ];
				if ( !arg )
					return 'undefined';
				if ( arg.indexRef )
					return arg.value;
				return arg.keypath;
			} );
		}

		function getKeypath( uniqueString ) {
			// Sanitize by removing any periods or square brackets. Otherwise
			// we can't split the keypath into keys!
			return '${' + uniqueString.replace( /[\.\[\]]/g, '-' ) + '}';
		}
	}( removeFromArray, resolveRef, Unresolved, Evaluator, getNewKeypath );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */
	var MemberResolver = function( types, resolveRef, Unresolved, getNewKeypath, ExpressionResolver ) {

		var MemberResolver = function( template, resolver, parentFragment ) {
			var member = this,
				ref, indexRefs, index, ractive, keypath;
			member.resolver = resolver;
			member.root = resolver.root;
			member.viewmodel = resolver.root.viewmodel;
			if ( typeof template === 'string' ) {
				member.value = template;
			} else if ( template.t === types.REFERENCE ) {
				ref = member.ref = template.n;
				// If it's an index reference, our job is simple
				if ( ( indexRefs = parentFragment.indexRefs ) && ( index = indexRefs[ ref ] ) !== undefined ) {
					member.indexRef = ref;
					member.value = index;
				} else {
					ractive = resolver.root;
					// Can we resolve the reference immediately?
					if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
						member.resolve( keypath );
					} else {
						// Couldn't resolve yet
						member.unresolved = new Unresolved( ractive, ref, parentFragment, function( keypath ) {
							member.unresolved = null;
							member.resolve( keypath );
						} );
					}
				}
			} else {
				new ExpressionResolver( resolver, parentFragment, template, function( keypath ) {
					member.resolve( keypath );
				} );
			}
		};
		MemberResolver.prototype = {
			resolve: function( keypath ) {
				this.keypath = keypath;
				this.value = this.viewmodel.get( keypath );
				this.bind();
				this.resolver.bubble();
			},
			bind: function() {
				this.viewmodel.register( this.keypath, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var keypath;
				if ( indexRef && this.indexRef === indexRef ) {
					if ( newIndex !== this.value ) {
						this.value = newIndex;
						return true;
					}
				} else if ( this.keypath && ( keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath ) ) ) {
					this.unbind();
					this.keypath = keypath;
					this.value = this.root.viewmodel.get( keypath );
					this.bind();
					return true;
				}
			},
			setValue: function( value ) {
				this.value = value;
				this.resolver.bubble();
			},
			unbind: function() {
				if ( this.keypath ) {
					this.root.viewmodel.unregister( this.keypath, this );
				}
			},
			teardown: function() {
				this.unbind();
				if ( this.unresolved ) {
					this.unresolved.teardown();
				}
			},
			forceResolution: function() {
				if ( this.unresolved ) {
					this.unresolved.teardown();
					this.unresolved = null;
					this.keypath = this.ref;
					this.value = this.viewmodel.get( this.ref );
					this.bind();
				}
			}
		};
		return MemberResolver;
	}( types, resolveRef, Unresolved, getNewKeypath, ExpressionResolver );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */
	var ReferenceExpressionResolver = function( resolveRef, Unresolved, MemberResolver ) {

		var ReferenceExpressionResolver = function( mustache, template, callback ) {
			var this$0 = this;
			var resolver = this,
				ractive, ref, keypath, parentFragment;
			parentFragment = mustache.parentFragment;
			resolver.root = ractive = mustache.root;
			resolver.mustache = mustache;
			resolver.priority = mustache.priority;
			resolver.ref = ref = template.r;
			resolver.callback = callback;
			resolver.unresolved = [];
			// Find base keypath
			if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
				resolver.base = keypath;
			} else {
				resolver.baseResolver = new Unresolved( ractive, ref, parentFragment, function( keypath ) {
					resolver.base = keypath;
					resolver.baseResolver = null;
					resolver.bubble();
				} );
			}
			// Find values for members, or mark them as unresolved
			resolver.members = template.m.map( function( template ) {
				return new MemberResolver( template, this$0, parentFragment );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ReferenceExpressionResolver.prototype = {
			getKeypath: function() {
				var values = this.members.map( getValue );
				if ( !values.every( isDefined ) || this.baseResolver ) {
					return;
				}
				return this.base + '.' + values.join( '.' );
			},
			bubble: function() {
				if ( !this.ready || this.baseResolver ) {
					return;
				}
				this.callback( this.getKeypath() );
			},
			teardown: function() {
				this.members.forEach( unbind );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.members.forEach( function( members ) {
					if ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			},
			forceResolution: function() {
				if ( this.baseResolver ) {
					this.base = this.ref;
					this.baseResolver.teardown();
					this.baseResolver = null;
				}
				this.members.forEach( function( m ) {
					return m.forceResolution();
				} );
				this.bubble();
			}
		};

		function getValue( member ) {
			return member.value;
		}

		function isDefined( value ) {
			return value != undefined;
		}

		function unbind( member ) {
			member.unbind();
		}
		return ReferenceExpressionResolver;
	}( resolveRef, Unresolved, MemberResolver );

	/* virtualdom/items/shared/Mustache/initialise.js */
	var initialise = function( types, runloop, resolveRef, ReferenceExpressionResolver, ExpressionResolver ) {

		return function Mustache$init( mustache, options ) {
			var ref, keypath, indexRefs, index, parentFragment, template;
			parentFragment = options.parentFragment;
			template = options.template;
			mustache.root = parentFragment.root;
			mustache.parentFragment = parentFragment;
			mustache.pElement = parentFragment.pElement;
			mustache.template = options.template;
			mustache.index = options.index || 0;
			mustache.priority = parentFragment.priority;
			mustache.isStatic = options.template.s;
			mustache.type = options.template.t;
			// if this is a simple mustache, with a reference, we just need to resolve
			// the reference to a keypath
			if ( ref = template.r ) {
				indexRefs = parentFragment.indexRefs;
				if ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {
					mustache.indexRef = ref;
					mustache.setValue( index );
					return;
				}
				keypath = resolveRef( mustache.root, ref, mustache.parentFragment );
				if ( keypath !== undefined ) {
					mustache.resolve( keypath );
				} else {
					mustache.ref = ref;
					runloop.addUnresolved( mustache );
				}
			}
			// if it's an expression, we have a bit more work to do
			if ( options.template.x ) {
				mustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );
			}
			if ( options.template.rx ) {
				mustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );
			}
			// Special case - inverted sections
			if ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {
				mustache.setValue( undefined );
			}

			function resolveAndRebindChildren( newKeypath ) {
				var oldKeypath = mustache.keypath;
				if ( newKeypath !== oldKeypath ) {
					mustache.resolve( newKeypath );
					if ( oldKeypath !== undefined ) {
						mustache.fragments && mustache.fragments.forEach( function( f ) {
							f.rebind( null, null, oldKeypath, newKeypath );
						} );
					}
				}
			}
		};
	}( types, runloop, resolveRef, ReferenceExpressionResolver, ExpressionResolver );

	/* virtualdom/items/shared/Mustache/resolve.js */
	var resolve = function Mustache$resolve( keypath ) {
		var wasResolved, value, twowayBinding;
		// If we resolved previously, we need to unregister
		if ( this.keypath !== undefined ) {
			this.root.viewmodel.unregister( this.keypath, this );
			wasResolved = true;
		}
		this.keypath = keypath;
		// If the new keypath exists, we need to register
		// with the viewmodel
		if ( keypath !== undefined ) {
			value = this.root.viewmodel.get( keypath );
			this.root.viewmodel.register( keypath, this );
		}
		// Either way we need to queue up a render (`value`
		// will be `undefined` if there's no keypath)
		this.setValue( value );
		// Two-way bindings need to point to their new target keypath
		if ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {
			twowayBinding.rebound();
		}
	};

	/* virtualdom/items/shared/Mustache/rebind.js */
	var rebind = function( getNewKeypath ) {

		return function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var keypath;
			// Children first
			if ( this.fragments ) {
				this.fragments.forEach( function( f ) {
					return f.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				} );
			}
			// Expression mustache?
			if ( this.resolver ) {
				this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
			// Normal keypath mustache or reference expression?
			if ( this.keypath ) {
				// was a new keypath created?
				if ( keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath ) ) {
					// resolve it
					this.resolve( keypath );
				}
			} else if ( indexRef !== undefined && this.indexRef === indexRef ) {
				this.setValue( newIndex );
			}
		};
	}( getNewKeypath );

	/* virtualdom/items/shared/Mustache/_Mustache.js */
	var Mustache = function( getValue, init, resolve, rebind ) {

		return {
			getValue: getValue,
			init: init,
			resolve: resolve,
			rebind: rebind
		};
	}( getValue, initialise, resolve, rebind );

	/* virtualdom/items/Interpolator.js */
	var Interpolator = function( types, runloop, escapeHtml, detachNode, unbind, Mustache, detach ) {

		var Interpolator = function( options ) {
			this.type = types.INTERPOLATOR;
			Mustache.init( this, options );
		};
		Interpolator.prototype = {
			update: function() {
				this.node.data = this.value == undefined ? '' : this.value;
			},
			resolve: Mustache.resolve,
			rebind: Mustache.rebind,
			detach: detach,
			unbind: unbind,
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.value != undefined ? this.value : '' );
				}
				return this.node;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					detachNode( this.node );
				}
			},
			getValue: Mustache.getValue,
			// TEMP
			setValue: function( value ) {
				var wrapper;
				// TODO is there a better way to approach this?
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				if ( value !== this.value ) {
					this.value = value;
					this.parentFragment.bubble();
					if ( this.node ) {
						runloop.addView( this );
					}
				}
			},
			firstNode: function() {
				return this.node;
			},
			toString: function( escape ) {
				var string = this.value != undefined ? '' + this.value : '';
				return escape ? escapeHtml( string ) : string;
			}
		};
		return Interpolator;
	}( types, runloop, escapeHtml, detachNode, unbind, Mustache, detach );

	/* virtualdom/items/Section/prototype/bubble.js */
	var virtualdom_items_Section$bubble = function Section$bubble() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Section/prototype/detach.js */
	var virtualdom_items_Section$detach = function Section$detach() {
		var docFrag;
		if ( this.fragments.length === 1 ) {
			return this.fragments[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.fragments.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/find.js */
	var virtualdom_items_Section$find = function Section$find( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].find( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findAll.js */
	var virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAll( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findAllComponents.js */
	var virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findComponent.js */
	var virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].findComponent( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findNextNode.js */
	var virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {
		if ( this.fragments[ fragment.index + 1 ] ) {
			return this.fragments[ fragment.index + 1 ].firstNode();
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/firstNode.js */
	var virtualdom_items_Section$firstNode = function Section$firstNode() {
		var len, i, node;
		if ( len = this.fragments.length ) {
			for ( i = 0; i < len; i += 1 ) {
				if ( node = this.fragments[ i ].firstNode() ) {
					return node;
				}
			}
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/merge.js */
	var virtualdom_items_Section$merge = function( runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$merge( newIndices ) {
			var section = this,
				parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment, nextNode;
			if ( this.unbound ) {
				return;
			}
			parentFragment = this.parentFragment;
			reboundFragments = [];
			// first, rebind existing fragments
			newIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {
				var fragment, by, oldKeypath, newKeypath;
				if ( newIndex === oldIndex ) {
					reboundFragments[ newIndex ] = section.fragments[ oldIndex ];
					return;
				}
				fragment = section.fragments[ oldIndex ];
				if ( firstChange === undefined ) {
					firstChange = oldIndex;
				}
				// does this fragment need to be torn down?
				if ( newIndex === -1 ) {
					section.fragmentsToUnrender.push( fragment );
					fragment.unbind();
					return;
				}
				// Otherwise, it needs to be rebound to a new index
				by = newIndex - oldIndex;
				oldKeypath = section.keypath + '.' + oldIndex;
				newKeypath = section.keypath + '.' + newIndex;
				fragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );
				reboundFragments[ newIndex ] = fragment;
			} );
			newLength = this.root.get( this.keypath ).length;
			// If nothing changed with the existing fragments, then we start adding
			// new fragments at the end...
			if ( firstChange === undefined ) {
				// ...unless there are no new fragments to add
				if ( this.length === newLength ) {
					return;
				}
				firstChange = this.length;
			}
			this.length = this.fragments.length = newLength;
			runloop.addView( this );
			// Prepare new fragment options
			fragmentOptions = {
				template: this.template.f,
				root: this.root,
				owner: this
			};
			if ( this.template.i ) {
				fragmentOptions.indexRef = this.template.i;
			}
			// Add as many new fragments as we need to, or add back existing
			// (detached) fragments
			for ( i = firstChange; i < newLength; i += 1 ) {
				// is this an existing fragment?
				if ( fragment = reboundFragments[ i ] ) {
					this.docFrag.appendChild( fragment.detach( false ) );
				} else {
					// Fragment will be created when changes are applied
					// by the runloop
					this.fragmentsToCreate.push( i );
				}
				this.fragments[ i ] = fragment;
			}
			// reinsert fragment
			nextNode = parentFragment.findNextNode( this );
			this.parentFragment.getNode().insertBefore( this.docFrag, nextNode );
		};
	}( runloop, circular );

	/* virtualdom/items/Section/prototype/render.js */
	var virtualdom_items_Section$render = function Section$render() {
		var docFrag;
		docFrag = this.docFrag = document.createDocumentFragment();
		this.update();
		this.rendered = true;
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/setValue.js */
	var virtualdom_items_Section$setValue = function( types, isArray, isObject, runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$setValue( value ) {
			var this$0 = this;
			var wrapper, fragmentOptions;
			if ( this.updating ) {
				// If a child of this section causes a re-evaluation - for example, an
				// expression refers to a function that mutates the array that this
				// section depends on - we'll end up with a double rendering bug (see
				// https://github.com/ractivejs/ractive/issues/748). This prevents it.
				return;
			}
			this.updating = true;
			// with sections, we need to get the fake value if we have a wrapped object
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			// If any fragments are awaiting creation after a splice,
			// this is the place to do it
			if ( this.fragmentsToCreate.length ) {
				fragmentOptions = {
					template: this.template.f,
					root: this.root,
					pElement: this.pElement,
					owner: this,
					indexRef: this.template.i
				};
				this.fragmentsToCreate.forEach( function( index ) {
					var fragment;
					fragmentOptions.context = this$0.keypath + '.' + index;
					fragmentOptions.index = index;
					fragment = new Fragment( fragmentOptions );
					this$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );
				} );
				this.fragmentsToCreate.length = 0;
			} else if ( reevaluateSection( this, value ) ) {
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
			this.value = value;
			this.updating = false;
		};

		function reevaluateSection( section, value ) {
			var fragmentOptions = {
				template: section.template.f,
				root: section.root,
				pElement: section.parentFragment.pElement,
				owner: section
			};
			// If we already know the section type, great
			// TODO can this be optimised? i.e. pick an reevaluateSection function during init
			// and avoid doing this each time?
			if ( section.subtype ) {
				switch ( section.subtype ) {
					case types.SECTION_IF:
						return reevaluateConditionalSection( section, value, false, fragmentOptions );
					case types.SECTION_UNLESS:
						return reevaluateConditionalSection( section, value, true, fragmentOptions );
					case types.SECTION_WITH:
						return reevaluateContextSection( section, fragmentOptions );
					case types.SECTION_EACH:
						if ( isObject( value ) ) {
							return reevaluateListObjectSection( section, value, fragmentOptions );
						}
				}
			}
			// Otherwise we need to work out what sort of section we're dealing with
			section.ordered = !!isArray( value );
			// Ordered list section
			if ( section.ordered ) {
				return reevaluateListSection( section, value, fragmentOptions );
			}
			// Unordered list, or context
			if ( isObject( value ) || typeof value === 'function' ) {
				// Index reference indicates section should be treated as a list
				if ( section.template.i ) {
					return reevaluateListObjectSection( section, value, fragmentOptions );
				}
				// Otherwise, object provides context for contents
				return reevaluateContextSection( section, fragmentOptions );
			}
			// Conditional section
			return reevaluateConditionalSection( section, value, false, fragmentOptions );
		}

		function reevaluateListSection( section, value, fragmentOptions ) {
			var i, length, fragment;
			length = value.length;
			if ( length === section.length ) {
				// Nothing to do
				return false;
			}
			// if the array is shorter than it was previously, remove items
			if ( length < section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( length, section.length - length );
				section.fragmentsToUnrender.forEach( unbind );
			} else {
				if ( length > section.length ) {
					// add any new ones
					for ( i = section.length; i < length; i += 1 ) {
						// append list item to context stack
						fragmentOptions.context = section.keypath + '.' + i;
						fragmentOptions.index = i;
						if ( section.template.i ) {
							fragmentOptions.indexRef = section.template.i;
						}
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( section.fragments[ i ] = fragment );
					}
				}
			}
			section.length = length;
			return true;
		}

		function reevaluateListObjectSection( section, value, fragmentOptions ) {
			var id, i, hasKey, fragment, changed;
			hasKey = section.hasKey || ( section.hasKey = {} );
			// remove any fragments that should no longer exist
			i = section.fragments.length;
			while ( i-- ) {
				fragment = section.fragments[ i ];
				if ( !( fragment.index in value ) ) {
					changed = true;
					fragment.unbind();
					section.fragmentsToUnrender.push( fragment );
					section.fragments.splice( i, 1 );
					hasKey[ fragment.index ] = false;
				}
			}
			// add any that haven't been created yet
			for ( id in value ) {
				if ( !hasKey[ id ] ) {
					changed = true;
					fragmentOptions.context = section.keypath + '.' + id;
					fragmentOptions.index = id;
					if ( section.template.i ) {
						fragmentOptions.indexRef = section.template.i;
					}
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( fragment );
					section.fragments.push( fragment );
					hasKey[ id ] = true;
				}
			}
			section.length = section.fragments.length;
			return changed;
		}

		function reevaluateContextSection( section, fragmentOptions ) {
			var fragment;
			// ...then if it isn't rendered, render it, adding section.keypath to the context stack
			// (if it is already rendered, then any children dependent on the context stack
			// will update themselves without any prompting)
			if ( !section.length ) {
				// append this section to the context stack
				fragmentOptions.context = section.keypath;
				fragmentOptions.index = 0;
				fragment = new Fragment( fragmentOptions );
				section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
				section.length = 1;
				return true;
			}
		}

		function reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {
			var doRender, emptyArray, fragment;
			emptyArray = isArray( value ) && value.length === 0;
			if ( inverted ) {
				doRender = emptyArray || !value;
			} else {
				doRender = value && !emptyArray;
			}
			if ( doRender ) {
				if ( !section.length ) {
					// no change to context stack
					fragmentOptions.index = 0;
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
					section.length = 1;
					return true;
				}
				if ( section.length > 1 ) {
					section.fragmentsToUnrender = section.fragments.splice( 1 );
					section.fragmentsToUnrender.forEach( unbind );
					return true;
				}
			} else if ( section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length );
				section.fragmentsToUnrender.forEach( unbind );
				section.length = 0;
				return true;
			}
		}

		function unbind( fragment ) {
			fragment.unbind();
		}
	}( types, isArray, isObject, runloop, circular );

	/* virtualdom/items/Section/prototype/splice.js */
	var virtualdom_items_Section$splice = function( runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$splice( spliceSummary ) {
			var section = this,
				balance, start, insertStart, insertEnd, spliceArgs;
			// In rare cases, a section will receive a splice instruction after it has
			// been unbound (see https://github.com/ractivejs/ractive/issues/967). This
			// prevents errors arising from those situations
			if ( this.unbound ) {
				return;
			}
			balance = spliceSummary.balance;
			if ( !balance ) {
				// The array length hasn't changed - we don't need to add or remove anything
				return;
			}
			// Register with the runloop, so we can (un)render with the
			// next batch of DOM changes
			runloop.addView( section );
			start = spliceSummary.rangeStart;
			section.length += balance;
			// If more items were removed from the array than added, we tear down
			// the excess fragments and remove them...
			if ( balance < 0 ) {
				section.fragmentsToUnrender = section.fragments.splice( start, -balance );
				section.fragmentsToUnrender.forEach( unbind );
				// Reassign fragments after the ones we've just removed
				rebindFragments( section, start, section.length, balance );
				// Nothing more to do
				return;
			}
			// ...otherwise we need to add some things to the DOM.
			insertStart = start + spliceSummary.removed;
			insertEnd = start + spliceSummary.added;
			// Make room for the new fragments by doing a splice that simulates
			// what happened to the data array
			spliceArgs = [
				insertStart,
				0
			];
			spliceArgs.length += balance;
			section.fragments.splice.apply( section.fragments, spliceArgs );
			// Rebind existing fragments at the end of the array
			rebindFragments( section, insertEnd, section.length, balance );
			// Schedule new fragments to be created
			section.fragmentsToCreate = range( insertStart, insertEnd );
		};

		function unbind( fragment ) {
			fragment.unbind();
		}

		function range( start, end ) {
			var array = [],
				i;
			for ( i = start; i < end; i += 1 ) {
				array.push( i );
			}
			return array;
		}

		function rebindFragments( section, start, end, by ) {
			var i, fragment, indexRef, oldKeypath, newKeypath;
			indexRef = section.template.i;
			for ( i = start; i < end; i += 1 ) {
				fragment = section.fragments[ i ];
				oldKeypath = section.keypath + '.' + ( i - by );
				newKeypath = section.keypath + '.' + i;
				// change the fragment index
				fragment.index = i;
				fragment.rebind( indexRef, i, oldKeypath, newKeypath );
			}
		}
	}( runloop, circular );

	/* virtualdom/items/Section/prototype/toString.js */
	var virtualdom_items_Section$toString = function Section$toString( escape ) {
		var str, i, len;
		str = '';
		i = 0;
		len = this.length;
		for ( i = 0; i < len; i += 1 ) {
			str += this.fragments[ i ].toString( escape );
		}
		return str;
	};

	/* virtualdom/items/Section/prototype/unbind.js */
	var virtualdom_items_Section$unbind = function( unbind ) {

		return function Section$unbind() {
			this.fragments.forEach( unbindFragment );
			unbind.call( this );
			this.length = 0;
			this.unbound = true;
		};

		function unbindFragment( fragment ) {
			fragment.unbind();
		}
	}( unbind );

	/* virtualdom/items/Section/prototype/unrender.js */
	var virtualdom_items_Section$unrender = function() {

		return function Section$unrender( shouldDestroy ) {
			this.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
		};

		function unrenderAndDestroy( fragment ) {
			fragment.unrender( true );
		}

		function unrender( fragment ) {
			fragment.unrender( false );
		}
	}();

	/* virtualdom/items/Section/prototype/update.js */
	var virtualdom_items_Section$update = function Section$update() {
		var fragment, rendered, nextFragment, anchor, target;
		while ( fragment = this.fragmentsToUnrender.pop() ) {
			fragment.unrender( true );
		}
		// If we have no new nodes to insert (i.e. the section length stayed the
		// same, or shrank), we don't need to go any further
		if ( !this.fragmentsToRender.length ) {
			return;
		}
		if ( this.rendered ) {
			target = this.parentFragment.getNode();
		}
		// Render new fragments to our docFrag
		while ( fragment = this.fragmentsToRender.shift() ) {
			rendered = fragment.render();
			this.docFrag.appendChild( rendered );
			// If this is an ordered list, and it's already rendered, we may
			// need to insert content into the appropriate place
			if ( this.rendered && this.ordered ) {
				// If the next fragment is already rendered, use it as an anchor...
				nextFragment = this.fragments[ fragment.index + 1 ];
				if ( nextFragment && nextFragment.rendered ) {
					target.insertBefore( this.docFrag, nextFragment.firstNode() || null );
				}
			}
		}
		if ( this.rendered && this.docFrag.childNodes.length ) {
			anchor = this.parentFragment.findNextNode( this );
			target.insertBefore( this.docFrag, anchor );
		}
	};

	/* virtualdom/items/Section/_Section.js */
	var Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, merge, render, setValue, splice, toString, unbind, unrender, update ) {

		var Section = function( options ) {
			this.type = types.SECTION;
			this.subtype = options.template.n;
			this.inverted = this.subtype === types.SECTION_UNLESS;
			this.pElement = options.pElement;
			this.fragments = [];
			this.fragmentsToCreate = [];
			this.fragmentsToRender = [];
			this.fragmentsToUnrender = [];
			this.length = 0;
			// number of times this section is rendered
			Mustache.init( this, options );
		};
		Section.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			merge: merge,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			splice: splice,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Section;
	}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$merge, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$splice, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );

	/* virtualdom/items/Triple/prototype/detach.js */
	var virtualdom_items_Triple$detach = function Triple$detach() {
		var len, i;
		if ( this.docFrag ) {
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				this.docFrag.appendChild( this.nodes[ i ] );
			}
			return this.docFrag;
		}
	};

	/* virtualdom/items/Triple/prototype/find.js */
	var virtualdom_items_Triple$find = function( matches ) {

		return function Triple$find( selector ) {
			var i, len, node, queryResult;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					return node;
				}
				if ( queryResult = node.querySelector( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/findAll.js */
	var virtualdom_items_Triple$findAll = function( matches ) {

		return function Triple$findAll( selector, queryResult ) {
			var i, len, node, queryAllResult, numNodes, j;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					queryResult.push( node );
				}
				if ( queryAllResult = node.querySelectorAll( selector ) ) {
					numNodes = queryAllResult.length;
					for ( j = 0; j < numNodes; j += 1 ) {
						queryResult.push( queryAllResult[ j ] );
					}
				}
			}
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/firstNode.js */
	var virtualdom_items_Triple$firstNode = function Triple$firstNode() {
		if ( this.rendered && this.nodes[ 0 ] ) {
			return this.nodes[ 0 ];
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Triple/helpers/insertHtml.js */
	var insertHtml = function( namespaces, createElement ) {

		var elementCache = {},
			ieBug, ieBlacklist;
		try {
			createElement( 'table' ).innerHTML = 'foo';
		} catch ( err ) {
			ieBug = true;
			ieBlacklist = {
				TABLE: [
					'<table class="x">',
					'</table>'
				],
				THEAD: [
					'<table><thead class="x">',
					'</thead></table>'
				],
				TBODY: [
					'<table><tbody class="x">',
					'</tbody></table>'
				],
				TR: [
					'<table><tr class="x">',
					'</tr></table>'
				],
				SELECT: [
					'<select class="x">',
					'</select>'
				]
			};
		}
		return function( html, node, docFrag ) {
			var container, nodes = [],
				wrapper, selectedOption, child, i;
			if ( html ) {
				if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
					container = element( 'DIV' );
					container.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];
					container = container.querySelector( '.x' );
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				} else if ( node.namespaceURI === namespaces.svg ) {
					container = element( 'DIV' );
					container.innerHTML = '<svg class="x">' + html + '</svg>';
					container = container.querySelector( '.x' );
				} else {
					container = element( node.tagName );
					container.innerHTML = html;
				}
				while ( child = container.firstChild ) {
					nodes.push( child );
					docFrag.appendChild( child );
				}
				// This is really annoying. Extracting <option> nodes from the
				// temporary container <select> causes the remaining ones to
				// become selected. So now we have to deselect them. IE8, you
				// amaze me. You really do
				if ( ieBug && node.tagName === 'SELECT' ) {
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] !== selectedOption ) {
							nodes[ i ].selected = false;
						}
					}
				}
			}
			return nodes;
		};

		function element( tagName ) {
			return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
		}
	}( namespaces, createElement );

	/* utils/toArray.js */
	var toArray = function toArray( arrayLike ) {
		var array = [],
			i = arrayLike.length;
		while ( i-- ) {
			array[ i ] = arrayLike[ i ];
		}
		return array;
	};

	/* virtualdom/items/Triple/helpers/updateSelect.js */
	var updateSelect = function( toArray ) {

		return function updateSelect( parentElement ) {
			var selectedOptions, option, value;
			if ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {
				return;
			}
			selectedOptions = toArray( parentElement.node.options ).filter( isSelected );
			// If one of them had a `selected` attribute, we need to sync
			// the model to the view
			if ( parentElement.getAttribute( 'multiple' ) ) {
				value = selectedOptions.map( function( o ) {
					return o.value;
				} );
			} else if ( option = selectedOptions[ 0 ] ) {
				value = option.value;
			}
			if ( value !== undefined ) {
				parentElement.binding.setValue( value );
			}
			parentElement.bubble();
		};

		function isSelected( option ) {
			return option.selected;
		}
	}( toArray );

	/* virtualdom/items/Triple/prototype/render.js */
	var virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {

		return function Triple$render() {
			if ( this.rendered ) {
				throw new Error( 'Attempted to render an item that was already rendered' );
			}
			this.docFrag = document.createDocumentFragment();
			this.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
			this.rendered = true;
			return this.docFrag;
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/prototype/setValue.js */
	var virtualdom_items_Triple$setValue = function( runloop ) {

		return function Triple$setValue( value ) {
			var wrapper;
			// TODO is there a better way to approach this?
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			if ( value !== this.value ) {
				this.value = value;
				this.parentFragment.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Triple/prototype/toString.js */
	var virtualdom_items_Triple$toString = function Triple$toString() {
		return this.value != undefined ? this.value : '';
	};

	/* virtualdom/items/Triple/prototype/unrender.js */
	var virtualdom_items_Triple$unrender = function( detachNode ) {

		return function Triple$unrender( shouldDestroy ) {
			if ( this.rendered && shouldDestroy ) {
				this.nodes.forEach( detachNode );
				this.rendered = false;
			}
		};
	}( detachNode );

	/* virtualdom/items/Triple/prototype/update.js */
	var virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {

		return function Triple$update() {
			var node, parentNode;
			if ( !this.rendered ) {
				return;
			}
			// Remove existing nodes
			while ( this.nodes && this.nodes.length ) {
				node = this.nodes.pop();
				node.parentNode.removeChild( node );
			}
			// Insert new nodes
			parentNode = this.parentFragment.getNode();
			this.nodes = insertHtml( this.value, parentNode, this.docFrag );
			parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/_Triple.js */
	var Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {

		var Triple = function( options ) {
			this.type = types.TRIPLE;
			Mustache.init( this, options );
		};
		Triple.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Triple;
	}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );

	/* virtualdom/items/Element/prototype/bubble.js */
	var virtualdom_items_Element$bubble = function() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Element/prototype/detach.js */
	var virtualdom_items_Element$detach = function Element$detach() {
		var node = this.node,
			parentNode;
		if ( node ) {
			// need to check for parent node - DOM may have been altered
			// by something other than Ractive! e.g. jQuery UI...
			if ( parentNode = node.parentNode ) {
				parentNode.removeChild( node );
			}
			return node;
		}
	};

	/* virtualdom/items/Element/prototype/find.js */
	var virtualdom_items_Element$find = function( matches ) {

		return function( selector ) {
			if ( matches( this.node, selector ) ) {
				return this.node;
			}
			if ( this.fragment && this.fragment.find ) {
				return this.fragment.find( selector );
			}
		};
	}( matches );

	/* virtualdom/items/Element/prototype/findAll.js */
	var virtualdom_items_Element$findAll = function( selector, query ) {
		// Add this node to the query, if applicable, and register the
		// query on this element
		if ( query._test( this, true ) && query.live ) {
			( this.liveQueries || ( this.liveQueries = [] ) ).push( query );
		}
		if ( this.fragment ) {
			this.fragment.findAll( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findAllComponents.js */
	var virtualdom_items_Element$findAllComponents = function( selector, query ) {
		if ( this.fragment ) {
			this.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findComponent.js */
	var virtualdom_items_Element$findComponent = function( selector ) {
		if ( this.fragment ) {
			return this.fragment.findComponent( selector );
		}
	};

	/* virtualdom/items/Element/prototype/findNextNode.js */
	var virtualdom_items_Element$findNextNode = function Element$findNextNode() {
		return null;
	};

	/* virtualdom/items/Element/prototype/firstNode.js */
	var virtualdom_items_Element$firstNode = function Element$firstNode() {
		return this.node;
	};

	/* virtualdom/items/Element/prototype/getAttribute.js */
	var virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {
		if ( !this.attributes || !this.attributes[ name ] ) {
			return;
		}
		return this.attributes[ name ].value;
	};

	/* virtualdom/items/Element/shared/enforceCase.js */
	var enforceCase = function() {

		var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
		svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );
		svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );
		createMap = function( items ) {
			var map = {},
				i = items.length;
			while ( i-- ) {
				map[ items[ i ].toLowerCase() ] = items[ i ];
			}
			return map;
		};
		map = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );
		return function( elementName ) {
			var lowerCaseElementName = elementName.toLowerCase();
			return map[ lowerCaseElementName ] || lowerCaseElementName;
		};
	}();

	/* virtualdom/items/Element/Attribute/prototype/bubble.js */
	var virtualdom_items_Element_Attribute$bubble = function( runloop ) {

		return function Attribute$bubble() {
			var value = this.fragment.getValue();
			// TODO this can register the attribute multiple times (see render test
			// 'Attribute with nested mustaches')
			if ( value !== this.value ) {
				this.value = value;
				if ( this.name === 'value' && this.node ) {
					// We need to store the value on the DOM like this so we
					// can retrieve it later without it being coerced to a string
					this.node._ractive.value = value;
				}
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */
	var determineNameAndNamespace = function( namespaces, enforceCase ) {

		return function( attribute, name ) {
			var colonIndex, namespacePrefix;
			// are we dealing with a namespaced attribute, e.g. xlink:href?
			colonIndex = name.indexOf( ':' );
			if ( colonIndex !== -1 ) {
				// looks like we are, yes...
				namespacePrefix = name.substr( 0, colonIndex );
				// ...unless it's a namespace *declaration*, which we ignore (on the assumption
				// that only valid namespaces will be used)
				if ( namespacePrefix !== 'xmlns' ) {
					name = name.substring( colonIndex + 1 );
					attribute.name = enforceCase( name );
					attribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];
					if ( !attribute.namespace ) {
						throw 'Unknown namespace ("' + namespacePrefix + '")';
					}
					return;
				}
			}
			// SVG attribute names are case sensitive
			attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;
		};
	}( namespaces, enforceCase );

	/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */
	var getInterpolator = function( types ) {

		return function getInterpolator( attribute ) {
			var items = attribute.fragment.items;
			if ( items.length !== 1 ) {
				return;
			}
			if ( items[ 0 ].type === types.INTERPOLATOR ) {
				return items[ 0 ];
			}
		};
	}( types );

	/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */
	var determinePropertyName = function( namespaces ) {

		// the property name equivalents for element attributes, where they differ
		// from the lowercased attribute name
		var propertyNames = {
			'accept-charset': 'acceptCharset',
			accesskey: 'accessKey',
			bgcolor: 'bgColor',
			'class': 'className',
			codebase: 'codeBase',
			colspan: 'colSpan',
			contenteditable: 'contentEditable',
			datetime: 'dateTime',
			dirname: 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			ismap: 'isMap',
			maxlength: 'maxLength',
			novalidate: 'noValidate',
			pubdate: 'pubDate',
			readonly: 'readOnly',
			rowspan: 'rowSpan',
			tabindex: 'tabIndex',
			usemap: 'useMap'
		};
		return function( attribute, options ) {
			var propertyName;
			if ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {
				propertyName = propertyNames[ attribute.name ] || attribute.name;
				if ( options.pNode[ propertyName ] !== undefined ) {
					attribute.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( typeof options.pNode[ propertyName ] === 'boolean' || propertyName === 'value' ) {
					attribute.useProperty = true;
				}
			}
		};
	}( namespaces );

	/* virtualdom/items/Element/Attribute/prototype/init.js */
	var virtualdom_items_Element_Attribute$init = function( types, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Attribute$init( options ) {
			this.type = types.ATTRIBUTE;
			this.element = options.element;
			this.root = options.root;
			determineNameAndNamespace( this, options.name );
			// if it's an empty attribute, or just a straight key-value pair, with no
			// mustache shenanigans, set the attribute accordingly and go home
			if ( !options.value || typeof options.value === 'string' ) {
				this.value = options.value || true;
				return;
			}
			// otherwise we need to do some work
			// share parentFragment with parent element
			this.parentFragment = this.element.parentFragment;
			this.fragment = new Fragment( {
				template: options.value,
				root: this.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
			// Store a reference to this attribute's interpolator, if its fragment
			// takes the form `{{foo}}`. This is necessary for two-way binding and
			// for correctly rendering HTML later
			this.interpolator = getInterpolator( this );
			this.isBindable = !!this.interpolator;
			// can we establish this attribute's property name equivalent?
			determinePropertyName( this, options );
			// mark as ready
			this.ready = true;
		};
	}( types, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );

	/* virtualdom/items/Element/Attribute/prototype/rebind.js */
	var virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( this.fragment ) {
			this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/render.js */
	var virtualdom_items_Element_Attribute$render = function( namespaces ) {

		// the property name equivalents for element attributes, where they differ
		// from the lowercased attribute name
		var propertyNames = {
			'accept-charset': 'acceptCharset',
			'accesskey': 'accessKey',
			'bgcolor': 'bgColor',
			'class': 'className',
			'codebase': 'codeBase',
			'colspan': 'colSpan',
			'contenteditable': 'contentEditable',
			'datetime': 'dateTime',
			'dirname': 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			'ismap': 'isMap',
			'maxlength': 'maxLength',
			'novalidate': 'noValidate',
			'pubdate': 'pubDate',
			'readonly': 'readOnly',
			'rowspan': 'rowSpan',
			'tabindex': 'tabIndex',
			'usemap': 'useMap'
		};
		return function Attribute$render( node ) {
			var propertyName;
			this.node = node;
			// should we use direct property access, or setAttribute?
			if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
				propertyName = propertyNames[ this.name ] || this.name;
				if ( node[ propertyName ] !== undefined ) {
					this.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( typeof node[ propertyName ] === 'boolean' || propertyName === 'value' ) {
					this.useProperty = true;
				}
				if ( propertyName === 'value' ) {
					this.useProperty = true;
					node._ractive.value = this.value;
				}
			}
			this.rendered = true;
			this.update();
		};
	}( namespaces );

	/* virtualdom/items/Element/Attribute/prototype/toString.js */
	var virtualdom_items_Element_Attribute$toString = function() {

		return function Attribute$toString() {
			var name, value, interpolator;
			name = this.name;
			value = this.value;
			// Special case - select values (should not be stringified)
			if ( name === 'value' && this.element.name === 'select' ) {
				return;
			}
			// Special case - radio names
			if ( name === 'name' && this.element.name === 'input' && ( interpolator = this.interpolator ) ) {
				return 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';
			}
			// Numbers
			if ( typeof value === 'number' ) {
				return name + '="' + value + '"';
			}
			// Strings
			if ( typeof value === 'string' ) {
				return name + '="' + escape( value ) + '"';
			}
			// Everything else
			return value ? name : '';
		};

		function escape( value ) {
			return value.replace( /&/g, '&amp;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
		}
	}();

	/* virtualdom/items/Element/Attribute/prototype/unbind.js */
	var virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {
		// ignore non-dynamic attributes
		if ( this.fragment ) {
			this.fragment.unbind();
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {
		var value = this.value,
			options, option, optionValue, i;
		if ( !this.locked ) {
			this.node._ractive.value = value;
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				if ( optionValue == value ) {
					// double equals as we may be comparing numbers with strings
					option.selected = true;
					break;
				}
			}
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( isArray ) {

		return function Attribute$updateMultipleSelect() {
			var value = this.value,
				options, i, option, optionValue;
			if ( !isArray( value ) ) {
				value = [ value ];
			}
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				option.selected = value.indexOf( optionValue ) !== -1;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */
	var virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {
		var node = ( value = this ).node,
			value = value.value;
		node.checked = value == node._ractive.value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */
	var virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {

		return function Attribute$updateRadioValue() {
			var wasChecked, node = this.node,
				binding, bindings, i;
			wasChecked = node.checked;
			node.value = this.element.getAttribute( 'value' );
			node.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );
			// This is a special case - if the input was checked, and the value
			// changed so that it's no longer checked, the twoway binding is
			// most likely out of date. To fix it we have to jump through some
			// hoops... this is a little kludgy but it works
			if ( wasChecked && !node.checked && this.element.binding ) {
				bindings = this.element.binding.siblings;
				if ( i = bindings.length ) {
					while ( i-- ) {
						binding = bindings[ i ];
						if ( !binding.element.node ) {
							// this is the initial render, siblings are still rendering!
							// we'll come back later...
							return;
						}
						if ( binding.element.node.checked ) {
							runloop.addViewmodel( binding.root.viewmodel );
							return binding.handleChange();
						}
					}
					runloop.addViewmodel( binding.root.viewmodel );
					this.root.viewmodel.set( binding.keypath, undefined );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */
	var virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {

		return function Attribute$updateCheckboxName() {
			var node, value;
			node = this.node;
			value = this.value;
			if ( !isArray( value ) ) {
				node.checked = value == node._ractive.value;
			} else {
				node.checked = value.indexOf( node._ractive.value ) !== -1;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */
	var virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.className = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value !== undefined ) {
			this.root.nodes[ value ] = undefined;
		}
		this.root.nodes[ value ] = node;
		node.id = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.style.setAttribute( 'cssText', value );
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */
	var virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		if ( !this.locked ) {
			node.innerHTML = value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */
	var virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {
		var node, value;
		node = this.node;
		value = this.value;
		// store actual value, so it doesn't get coerced to a string
		node._ractive.value = value;
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			node.value = value == undefined ? '' : value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */
	var virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			this.node[ this.propertyName ] = this.value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */
	var virtualdom_items_Element_Attribute$update_updateEverythingElse = function Attribute$updateEverythingElse() {
		var node, name, value;
		node = this.node;
		name = this.name;
		value = this.value;
		if ( this.namespace ) {
			node.setAttributeNS( this.namespace, name, value );
		} else if ( typeof value === 'string' || typeof value === 'number' ) {
			node.setAttribute( name, value );
		} else {
			if ( value ) {
				node.setAttribute( name, '' );
			} else {
				node.removeAttribute( name );
			}
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update.js */
	var virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {

		// There are a few special cases when it comes to updating attributes. For this reason,
		// the prototype .update() method points to this method, which waits until the
		// attribute has finished initialising, then replaces the prototype method with a more
		// suitable one. That way, we save ourselves doing a bunch of tests on each call
		return function Attribute$update() {
			var name, element, node, type, updateMethod;
			name = this.name;
			element = this.element;
			node = this.node;
			if ( name === 'id' ) {
				updateMethod = updateIdAttribute;
			} else if ( name === 'value' ) {
				// special case - selects
				if ( element.name === 'select' && name === 'value' ) {
					updateMethod = node.multiple ? updateMultipleSelectValue : updateSelectValue;
				} else if ( element.name === 'textarea' ) {
					updateMethod = updateValue;
				} else if ( node.getAttribute( 'contenteditable' ) ) {
					updateMethod = updateContentEditableValue;
				} else if ( element.name === 'input' ) {
					type = element.getAttribute( 'type' );
					// type='file' value='{{fileList}}'>
					if ( type === 'file' ) {
						updateMethod = noop;
					} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {
						updateMethod = updateRadioValue;
					} else {
						updateMethod = updateValue;
					}
				}
			} else if ( this.twoway && name === 'name' ) {
				if ( node.type === 'radio' ) {
					updateMethod = updateRadioName;
				} else if ( node.type === 'checkbox' ) {
					updateMethod = updateCheckboxName;
				}
			} else if ( name === 'style' && node.style.setAttribute ) {
				updateMethod = updateIEStyleAttribute;
			} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {
				updateMethod = updateClassName;
			} else if ( this.useProperty ) {
				updateMethod = updateBoolean;
			}
			if ( !updateMethod ) {
				updateMethod = updateEverythingElse;
			}
			this.update = updateMethod;
			this.update();
		};
	}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );

	/* virtualdom/items/Element/Attribute/_Attribute.js */
	var Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {

		var Attribute = function( options ) {
			this.init( options );
		};
		Attribute.prototype = {
			bubble: bubble,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			update: update
		};
		return Attribute;
	}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );

	/* virtualdom/items/Element/prototype/init/createAttributes.js */
	var virtualdom_items_Element$init_createAttributes = function( Attribute ) {

		return function( element, attributes ) {
			var name, attribute, result = [];
			for ( name in attributes ) {
				if ( attributes.hasOwnProperty( name ) ) {
					attribute = new Attribute( {
						element: element,
						name: name,
						value: attributes[ name ],
						root: element.root
					} );
					result.push( result[ name ] = attribute );
				}
			}
			return result;
		};
	}( Attribute );

	/* utils/extend.js */
	var extend = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		var prop, source;
		while ( source = sources.shift() ) {
			for ( prop in source ) {
				if ( source.hasOwnProperty( prop ) ) {
					target[ prop ] = source[ prop ];
				}
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Binding/Binding.js */
	var Binding = function( runloop, warn, create, extend, removeFromArray ) {

		var Binding = function( element ) {
			var interpolator, keypath, value;
			this.element = element;
			this.root = element.root;
			this.attribute = element.attributes[ this.name || 'value' ];
			interpolator = this.attribute.interpolator;
			interpolator.twowayBinding = this;
			if ( interpolator.keypath && interpolator.keypath.substr === '${' ) {
				warn( 'Two-way binding does not work with expressions: ' + interpolator.keypath );
				return false;
			}
			// A mustache may be *ambiguous*. Let's say we were given
			// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
			// *wasn't* `undefined`, the keypath would be `foo.bar`.
			// Then, any user input would result in `foo.bar` being updated.
			//
			// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
			// left with an unresolved partial keypath - so we are forced to make an
			// assumption. That assumption is that the input in question should
			// be forced to resolve to `bar`, and any user input would affect `bar`
			// and not `foo.bar`.
			//
			// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
			// be explicit when using two-way data-binding about what keypath you're
			// updating. Using it in lists is probably a recipe for confusion...
			if ( !interpolator.keypath ) {
				if ( interpolator.ref ) {
					interpolator.resolve( interpolator.ref );
				}
				// If we have a reference expression resolver, we have to force
				// members to attach themselves to the root
				if ( interpolator.resolver ) {
					interpolator.resolver.forceResolution();
				}
			}
			this.keypath = keypath = interpolator.keypath;
			// initialise value, if it's undefined
			if ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {
				value = this.getInitialValue();
				if ( value !== undefined ) {
					this.root.viewmodel.set( keypath, value );
				}
			}
		};
		Binding.prototype = {
			handleChange: function() {
				var this$0 = this;
				runloop.start( this.root );
				this.attribute.locked = true;
				this.root.viewmodel.set( this.keypath, this.getValue() );
				runloop.scheduleTask( function() {
					return this$0.attribute.locked = false;
				} );
				runloop.end();
			},
			rebound: function() {
				var bindings, oldKeypath, newKeypath;
				oldKeypath = this.keypath;
				newKeypath = this.attribute.interpolator.keypath;
				// The attribute this binding is linked to has already done the work
				if ( oldKeypath === newKeypath ) {
					return;
				}
				removeFromArray( this.root._twowayBindings[ oldKeypath ], this );
				this.keypath = newKeypath;
				bindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );
				bindings.push( this );
			},
			unbind: function() {}
		};
		Binding.extend = function( properties ) {
			var Parent = this,
				SpecialisedBinding;
			SpecialisedBinding = function( element ) {
				Binding.call( this, element );
				if ( this.init ) {
					this.init();
				}
			};
			SpecialisedBinding.prototype = create( Parent.prototype );
			extend( SpecialisedBinding.prototype, properties );
			SpecialisedBinding.extend = Binding.extend;
			return SpecialisedBinding;
		};
		return Binding;
	}( runloop, warn, create, extend, removeFromArray );

	/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */
	var handleDomEvent = function handleChange() {
		this._ractive.binding.handleChange();
	};

	/* virtualdom/items/Element/Binding/ContentEditableBinding.js */
	var ContentEditableBinding = function( Binding, handleDomEvent ) {

		var ContentEditableBinding = Binding.extend( {
			getInitialValue: function() {
				return this.element.fragment ? this.element.fragment.toString() : '';
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.innerHTML;
			}
		} );
		return ContentEditableBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/shared/getSiblings.js */
	var getSiblings = function() {

		var sets = {};
		return function getSiblings( id, group, keypath ) {
			var hash = id + group + keypath;
			return sets[ hash ] || ( sets[ hash ] = [] );
		};
	}();

	/* virtualdom/items/Element/Binding/RadioBinding.js */
	var RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var RadioBinding = Binding.extend( {
			name: 'checked',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );
				this.siblings.push( this );
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			handleChange: function() {
				runloop.start( this.root );
				this.siblings.forEach( function( binding ) {
					binding.root.viewmodel.set( binding.keypath, binding.getValue() );
				} );
				runloop.end();
			},
			getValue: function() {
				return this.element.node.checked;
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioBinding;
	}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/RadioNameBinding.js */
	var RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {

		var RadioNameBinding = Binding.extend( {
			name: 'name',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );
				this.siblings.push( this );
				this.radioName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
			},
			getInitialValue: function() {
				if ( this.element.getAttribute( 'checked' ) ) {
					return this.element.getAttribute( 'value' );
				}
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				var node = this.element.node;
				return node._ractive ? node._ractive.value : node.value;
			},
			handleChange: function() {
				// If this <input> is the one that's checked, then the value of its
				// `name` keypath gets set to its value
				if ( this.element.node.checked ) {
					Binding.prototype.handleChange.call( this );
				}
			},
			rebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var node;
				Binding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				if ( node = this.element.node ) {
					node.name = '{{' + this.keypath + '}}';
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioNameBinding;
	}( removeFromArray, Binding, handleDomEvent, getSiblings );

	/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */
	var CheckboxNameBinding = function( isArray, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var CheckboxNameBinding = Binding.extend( {
			name: 'name',
			getInitialValue: function() {
				// This only gets called once per group (of inputs that
				// share a name), because it only gets called if there
				// isn't an initial value. By the same token, we can make
				// a note of that fact that there was no initial value,
				// and populate it using any `checked` attributes that
				// exist (which users should avoid, but which we should
				// support anyway to avoid breaking expectations)
				this.noInitialValue = true;
				return [];
			},
			init: function() {
				var existingValue, bindingValue, noInitialValue;
				this.checkboxName = true;
				// so that ractive.updateModel() knows what to do with this
				// Each input has a reference to an array containing it and its
				// siblings, as two-way binding depends on being able to ascertain
				// the status of all inputs within the group
				this.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );
				this.siblings.push( this );
				if ( this.noInitialValue ) {
					this.siblings.noInitialValue = true;
				}
				noInitialValue = this.siblings.noInitialValue;
				existingValue = this.root.viewmodel.get( this.keypath );
				bindingValue = this.element.getAttribute( 'value' );
				if ( noInitialValue ) {
					this.isChecked = this.element.getAttribute( 'checked' );
					if ( this.isChecked ) {
						existingValue.push( bindingValue );
					}
				} else {
					this.isChecked = isArray( existingValue ) ? existingValue.indexOf( bindingValue ) !== -1 : existingValue === bindingValue;
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.isChecked;
				node.addEventListener( 'change', handleDomEvent, false );
				// in case of IE emergency, bind to click event as well
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			changed: function() {
				var wasChecked = !!this.isChecked;
				this.isChecked = this.element.node.checked;
				return this.isChecked === wasChecked;
			},
			handleChange: function() {
				this.isChecked = this.element.node.checked;
				Binding.prototype.handleChange.call( this );
			},
			getValue: function() {
				return this.siblings.filter( isChecked ).map( getValue );
			}
		} );

		function isChecked( binding ) {
			return binding.isChecked;
		}

		function getValue( binding ) {
			return binding.element.getAttribute( 'value' );
		}
		return CheckboxNameBinding;
	}( isArray, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/CheckboxBinding.js */
	var CheckboxBinding = function( Binding, handleDomEvent ) {

		var CheckboxBinding = Binding.extend( {
			name: 'checked',
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.checked;
			}
		} );
		return CheckboxBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/SelectBinding.js */
	var SelectBinding = function( runloop, Binding, handleDomEvent ) {

		var SelectBinding = Binding.extend( {
			getInitialValue: function() {
				var options = this.element.options,
					len, i;
				i = len = options.length;
				if ( !len ) {
					return;
				}
				// take the final selected option...
				while ( i-- ) {
					if ( options[ i ].getAttribute( 'selected' ) ) {
						return options[ i ].getAttribute( 'value' );
					}
				}
				// or the first non-disabled option, if none are selected
				while ( ++i < len ) {
					if ( !options[ i ].getAttribute( 'disabled' ) ) {
						return options[ i ].getAttribute( 'value' );
					}
				}
			},
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			// TODO this method is an anomaly... is it necessary?
			setValue: function( value ) {
				runloop.addViewmodel( this.root.viewmodel );
				this.root.viewmodel.set( this.keypath, value );
			},
			getValue: function() {
				var options, i, len, option, optionValue;
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( options[ i ].selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						return optionValue;
					}
				}
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			}
		} );
		return SelectBinding;
	}( runloop, Binding, handleDomEvent );

	/* utils/arrayContentsMatch.js */
	var arrayContentsMatch = function( isArray ) {

		return function( a, b ) {
			var i;
			if ( !isArray( a ) || !isArray( b ) ) {
				return false;
			}
			if ( a.length !== b.length ) {
				return false;
			}
			i = a.length;
			while ( i-- ) {
				if ( a[ i ] !== b[ i ] ) {
					return false;
				}
			}
			return true;
		};
	}( isArray );

	/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */
	var MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {

		var MultipleSelectBinding = SelectBinding.extend( {
			getInitialValue: function() {
				return this.element.options.filter( function( option ) {
					return option.getAttribute( 'selected' );
				} ).map( function( option ) {
					return option.getAttribute( 'value' );
				} );
			},
			render: function() {
				var valueFromModel;
				this.element.node.addEventListener( 'change', handleDomEvent, false );
				valueFromModel = this.root.viewmodel.get( this.keypath );
				if ( valueFromModel === undefined ) {
					// get value from DOM, if possible
					this.handleChange();
				}
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			setValue: function() {
				throw new Error( 'TODO not implemented yet' );
			},
			getValue: function() {
				var selectedValues, options, i, len, option, optionValue;
				selectedValues = [];
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( option.selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						selectedValues.push( optionValue );
					}
				}
				return selectedValues;
			},
			handleChange: function() {
				var attribute, previousValue, value;
				attribute = this.attribute;
				previousValue = attribute.value;
				value = this.getValue();
				if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
					SelectBinding.prototype.handleChange.call( this );
				}
				return this;
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			},
			updateModel: function() {
				if ( this.attribute.value === undefined || !this.attribute.value.length ) {
					this.root.viewmodel.set( this.keypath, this.initialValue );
				}
			}
		} );
		return MultipleSelectBinding;
	}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );

	/* virtualdom/items/Element/Binding/FileListBinding.js */
	var FileListBinding = function( Binding, handleDomEvent ) {

		var FileListBinding = Binding.extend( {
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.files;
			}
		} );
		return FileListBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/GenericBinding.js */
	var GenericBinding = function( Binding, handleDomEvent ) {

		var GenericBinding, getOptions;
		getOptions = {
			evaluateWrapped: true
		};
		GenericBinding = Binding.extend( {
			getInitialValue: function() {
				return '';
			},
			getValue: function() {
				return this.element.node.value;
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
				node.addEventListener( 'blur', handleBlur, false );
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
				node.removeEventListener( 'blur', handleBlur, false );
			}
		} );
		return GenericBinding;

		function handleBlur() {
			var value;
			handleDomEvent.call( this );
			value = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );
			this.value = value == undefined ? '' : value;
		}
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/NumericBinding.js */
	var NumericBinding = function( GenericBinding ) {

		return GenericBinding.extend( {
			getInitialValue: function() {
				return undefined;
			},
			getValue: function() {
				var value = parseFloat( this.element.node.value );
				return isNaN( value ) ? undefined : value;
			}
		} );
	}( GenericBinding );

	/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */
	var virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {

		return function createTwowayBinding( element ) {
			var attributes = element.attributes,
				type, Binding, bindName, bindChecked;
			// if this is a late binding, and there's already one, it
			// needs to be torn down
			if ( element.binding ) {
				element.binding.teardown();
				element.binding = null;
			}
			// contenteditable
			if ( element.getAttribute( 'contenteditable' ) && isBindable( attributes.value ) ) {
				Binding = ContentEditableBinding;
			} else if ( element.name === 'input' ) {
				type = element.getAttribute( 'type' );
				if ( type === 'radio' || type === 'checkbox' ) {
					bindName = isBindable( attributes.name );
					bindChecked = isBindable( attributes.checked );
					// we can either bind the name attribute, or the checked attribute - not both
					if ( bindName && bindChecked ) {
						log.error( {
							message: 'badRadioInputBinding'
						} );
					}
					if ( bindName ) {
						Binding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
					} else if ( bindChecked ) {
						Binding = type === 'radio' ? RadioBinding : CheckboxBinding;
					}
				} else if ( type === 'file' && isBindable( attributes.value ) ) {
					Binding = FileListBinding;
				} else if ( isBindable( attributes.value ) ) {
					Binding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;
				}
			} else if ( element.name === 'select' && isBindable( attributes.value ) ) {
				Binding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;
			} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
				Binding = GenericBinding;
			}
			if ( Binding ) {
				return new Binding( element );
			}
		};

		function isBindable( attribute ) {
			return attribute && attribute.isBindable;
		}
	}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );

	/* virtualdom/items/Element/EventHandler/prototype/fire.js */
	var virtualdom_items_Element_EventHandler$fire = function EventHandler$fire( event ) {
		this.root.fire( this.action.toString().trim(), event );
	};

	/* virtualdom/items/Element/EventHandler/prototype/init.js */
	var virtualdom_items_Element_EventHandler$init = function( circular ) {

		var Fragment, getValueOptions = {
			args: true
		};
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function EventHandler$init( element, name, template ) {
			var action;
			this.element = element;
			this.root = element.root;
			this.name = name;
			this.proxies = [];
			// Get action ('foo' in 'on-click='foo')
			action = template.n || template;
			if ( typeof action !== 'string' ) {
				action = new Fragment( {
					template: action,
					root: this.root,
					owner: this.element
				} );
			}
			this.action = action;
			// Get parameters
			if ( template.d ) {
				this.dynamicParams = new Fragment( {
					template: template.d,
					root: this.root,
					owner: this.element
				} );
				this.fire = fireEventWithDynamicParams;
			} else if ( template.a ) {
				this.params = template.a;
				this.fire = fireEventWithParams;
			}
		};

		function fireEventWithParams( event ) {
			this.root.fire.apply( this.root, [
				this.action.toString().trim(),
				event
			].concat( this.params ) );
		}

		function fireEventWithDynamicParams( event ) {
			var args = this.dynamicParams.getValue( getValueOptions );
			// need to strip [] from ends if a string!
			if ( typeof args === 'string' ) {
				args = args.substr( 1, args.length - 2 );
			}
			this.root.fire.apply( this.root, [
				this.action.toString().trim(),
				event
			].concat( args ) );
		}
	}( circular );

	/* virtualdom/items/Element/EventHandler/prototype/rebind.js */
	var virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( typeof this.action !== 'string' ) {
			this.action.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
		if ( this.dynamicParams ) {
			this.dynamicParams.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */
	var genericHandler = function genericHandler( event ) {
		var storage, handler;
		storage = this._ractive;
		handler = storage.events[ event.type ];
		handler.fire( {
			node: this,
			original: event,
			index: storage.index,
			keypath: storage.keypath,
			context: storage.root.get( storage.keypath )
		} );
	};

	/* virtualdom/items/Element/EventHandler/prototype/render.js */
	var virtualdom_items_Element_EventHandler$render = function( warn, config, genericHandler ) {

		var customHandlers = {};
		return function EventHandler$render() {
			var name = this.name,
				definition;
			this.node = this.element.node;
			if ( definition = config.registries.events.find( this.root, name ) ) {
				this.custom = definition( this.node, getCustomHandler( name ) );
			} else {
				// Looks like we're dealing with a standard DOM event... but let's check
				if ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {
					warn( 'Missing "' + this.name + '" event. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#events' );
				}
				this.node.addEventListener( name, genericHandler, false );
			}
			// store this on the node itself, so it can be retrieved by a
			// universal handler
			this.node._ractive.events[ name ] = this;
		};

		function getCustomHandler( name ) {
			if ( !customHandlers[ name ] ) {
				customHandlers[ name ] = function( event ) {
					var storage = event.node._ractive;
					event.index = storage.index;
					event.keypath = storage.keypath;
					event.context = storage.root.get( storage.keypath );
					storage.events[ name ].fire( event );
				};
			}
			return customHandlers[ name ];
		}
	}( warn, config, genericHandler );

	/* virtualdom/items/Element/EventHandler/prototype/teardown.js */
	var virtualdom_items_Element_EventHandler$teardown = function EventHandler$teardown() {
		// Tear down dynamic name
		if ( typeof this.action !== 'string' ) {
			this.action.teardown();
		}
		// Tear down dynamic parameters
		if ( this.dynamicParams ) {
			this.dynamicParams.teardown();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/unrender.js */
	var virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {

		return function EventHandler$unrender() {
			if ( this.custom ) {
				this.custom.teardown();
			} else {
				this.node.removeEventListener( this.name, genericHandler, false );
			}
		};
	}( genericHandler );

	/* virtualdom/items/Element/EventHandler/_EventHandler.js */
	var EventHandler = function( fire, init, rebind, render, teardown, unrender ) {

		var EventHandler = function( element, name, template ) {
			this.init( element, name, template );
		};
		EventHandler.prototype = {
			fire: fire,
			init: init,
			rebind: rebind,
			render: render,
			teardown: teardown,
			unrender: unrender
		};
		return EventHandler;
	}( virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$teardown, virtualdom_items_Element_EventHandler$unrender );

	/* virtualdom/items/Element/prototype/init/createEventHandlers.js */
	var virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {

		return function( element, template ) {
			var i, name, names, handler, result = [];
			for ( name in template ) {
				if ( template.hasOwnProperty( name ) ) {
					names = name.split( '-' );
					i = names.length;
					while ( i-- ) {
						handler = new EventHandler( element, names[ i ], template[ name ] );
						result.push( handler );
					}
				}
			}
			return result;
		};
	}( EventHandler );

	/* virtualdom/items/Element/Decorator/_Decorator.js */
	var Decorator = function( log, circular, config ) {

		var Fragment, getValueOptions, Decorator;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		getValueOptions = {
			args: true
		};
		Decorator = function( element, template ) {
			var decorator = this,
				ractive, name, fragment;
			decorator.element = element;
			decorator.root = ractive = element.root;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			if ( template.a ) {
				decorator.params = template.a;
			} else if ( template.d ) {
				decorator.fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				decorator.params = decorator.fragment.getValue( getValueOptions );
				decorator.fragment.bubble = function() {
					this.dirtyArgs = this.dirtyValue = true;
					decorator.params = this.getValue( getValueOptions );
					if ( decorator.ready ) {
						decorator.update();
					}
				};
			}
			decorator.fn = config.registries.decorators.find( ractive, name );
			if ( !decorator.fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'decorator',
						name: name
					}
				} );
			}
		};
		Decorator.prototype = {
			init: function() {
				var decorator = this,
					node, result, args;
				node = decorator.element.node;
				if ( decorator.params ) {
					args = [ node ].concat( decorator.params );
					result = decorator.fn.apply( decorator.root, args );
				} else {
					result = decorator.fn.call( decorator.root, node );
				}
				if ( !result || !result.teardown ) {
					throw new Error( 'Decorator definition must return an object with a teardown method' );
				}
				// TODO does this make sense?
				decorator.actual = result;
				decorator.ready = true;
			},
			update: function() {
				if ( this.actual.update ) {
					this.actual.update.apply( this.root, this.params );
				} else {
					this.actual.teardown( true );
					this.init();
				}
			},
			teardown: function( updating ) {
				this.actual.teardown();
				if ( !updating && this.fragment ) {
					this.fragment.unbind();
				}
			}
		};
		return Decorator;
	}( log, circular, config );

	/* virtualdom/items/Element/special/select/sync.js */
	var sync = function( toArray ) {

		return function syncSelect( selectElement ) {
			var selectNode, selectValue, isMultiple, options, optionWasSelected;
			selectNode = selectElement.node;
			if ( !selectNode ) {
				return;
			}
			options = toArray( selectNode.options );
			selectValue = selectElement.getAttribute( 'value' );
			isMultiple = selectElement.getAttribute( 'multiple' );
			// If the <select> has a specified value, that should override
			// these options
			if ( selectValue !== undefined ) {
				options.forEach( function( o ) {
					var optionValue, shouldSelect;
					optionValue = o._ractive ? o._ractive.value : o.value;
					shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;
					if ( shouldSelect ) {
						optionWasSelected = true;
					}
					o.selected = shouldSelect;
				} );
				if ( !optionWasSelected ) {
					if ( options[ 0 ] ) {
						options[ 0 ].selected = true;
					}
					if ( selectElement.binding ) {
						selectElement.binding.forceUpdate();
					}
				}
			} else if ( selectElement.binding ) {
				selectElement.binding.forceUpdate();
			}
		};

		function valueContains( selectValue, optionValue ) {
			var i = selectValue.length;
			while ( i-- ) {
				if ( selectValue[ i ] == optionValue ) {
					return true;
				}
			}
		}
	}( toArray );

	/* virtualdom/items/Element/special/select/bubble.js */
	var bubble = function( runloop, syncSelect ) {

		return function bubbleSelect() {
			var this$0 = this;
			if ( !this.dirty ) {
				this.dirty = true;
				runloop.scheduleTask( function() {
					syncSelect( this$0 );
					this$0.dirty = false;
				} );
			}
			this.parentFragment.bubble();
		};
	}( runloop, sync );

	/* virtualdom/items/Element/special/option/findParentSelect.js */
	var findParentSelect = function findParentSelect( element ) {
		do {
			if ( element.name === 'select' ) {
				return element;
			}
		} while ( element = element.parent );
	};

	/* virtualdom/items/Element/special/option/init.js */
	var init = function( findParentSelect ) {

		return function initOption( option, template ) {
			option.select = findParentSelect( option.parent );
			option.select.options.push( option );
			// If the value attribute is missing, use the element's content
			if ( !template.a ) {
				template.a = {};
			}
			// ...as long as it isn't disabled
			if ( !template.a.value && !template.a.hasOwnProperty( 'disabled' ) ) {
				template.a.value = template.f;
			}
			// If there is a `selected` attribute, but the <select>
			// already has a value, delete it
			if ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {
				delete template.a.selected;
			}
		};
	}( findParentSelect );

	/* virtualdom/items/Element/prototype/init.js */
	var virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Element$init( options ) {
			var parentFragment, template, ractive, binding, bindings;
			this.type = types.ELEMENT;
			// stuff we'll need later
			parentFragment = this.parentFragment = options.parentFragment;
			template = this.template = options.template;
			this.parent = options.pElement || parentFragment.pElement;
			this.root = ractive = parentFragment.root;
			this.index = options.index;
			this.name = enforceCase( template.e );
			// Special case - <option> elements
			if ( this.name === 'option' ) {
				initOption( this, template );
			}
			// Special case - <select> elements
			if ( this.name === 'select' ) {
				this.options = [];
				this.bubble = bubbleSelect;
			}
			// create attributes
			this.attributes = createAttributes( this, template.a );
			// append children, if there are any
			if ( template.f ) {
				this.fragment = new Fragment( {
					template: template.f,
					root: ractive,
					owner: this,
					pElement: this
				} );
			}
			// create twoway binding
			if ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {
				this.binding = binding;
				// register this with the root, so that we can do ractive.updateModel()
				bindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );
				bindings.push( binding );
			}
			// create event proxies
			if ( template.v ) {
				this.eventHandlers = createEventHandlers( this, template.v );
			}
			// create decorator
			if ( template.o ) {
				this.decorator = new Decorator( this, template.o );
			}
			// create transitions
			this.intro = template.t0 || template.t1;
			this.outro = template.t0 || template.t2;
		};
	}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );

	/* virtualdom/items/shared/utils/startsWith.js */
	var startsWith = function( startsWithKeypath ) {

		return function startsWith( target, keypath ) {
			return target === keypath || startsWithKeypath( target, keypath );
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/utils/assignNewKeypath.js */
	var assignNewKeypath = function( startsWith, getNewKeypath ) {

		return function assignNewKeypath( target, property, oldKeypath, newKeypath ) {
			var existingKeypath = target[ property ];
			if ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {
				return;
			}
			target[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );
		};
	}( startsWith, getNewKeypath );

	/* virtualdom/items/Element/prototype/rebind.js */
	var virtualdom_items_Element$rebind = function( assignNewKeypath ) {

		return function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var i, storage, liveQueries, ractive;
			if ( this.attributes ) {
				this.attributes.forEach( rebind );
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( rebind );
			}
			// rebind children
			if ( this.fragment ) {
				rebind( this.fragment );
			}
			// Update live queries, if necessary
			if ( liveQueries = this.liveQueries ) {
				ractive = this.root;
				i = liveQueries.length;
				while ( i-- ) {
					liveQueries[ i ]._makeDirty();
				}
			}
			if ( this.node && ( storage = this.node._ractive ) ) {
				// adjust keypath if needed
				assignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );
				if ( indexRef != undefined ) {
					storage.index[ indexRef ] = newIndex;
				}
			}

			function rebind( thing ) {
				thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( assignNewKeypath );

	/* virtualdom/items/Element/special/img/render.js */
	var render = function renderImage( img ) {
		var width, height, loadHandler;
		// if this is an <img>, and we're in a crap browser, we may need to prevent it
		// from overriding width and height when it loads the src
		if ( ( width = img.getAttribute( 'width' ) ) || ( height = img.getAttribute( 'height' ) ) ) {
			img.node.addEventListener( 'load', loadHandler = function() {
				if ( width ) {
					img.node.width = width.value;
				}
				if ( height ) {
					img.node.height = height.value;
				}
				img.node.removeEventListener( 'load', loadHandler, false );
			}, false );
		}
	};

	/* virtualdom/items/Element/Transition/prototype/init.js */
	var virtualdom_items_Element_Transition$init = function( log, config, circular ) {

		var Fragment, getValueOptions = {};
		// TODO what are the options?
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Transition$init( element, template, isIntro ) {
			var t = this,
				ractive, name, fragment;
			t.element = element;
			t.root = ractive = element.root;
			t.isIntro = isIntro;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			t.name = name;
			if ( template.a ) {
				t.params = template.a;
			} else if ( template.d ) {
				// TODO is there a way to interpret dynamic arguments without all the
				// 'dependency thrashing'?
				fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				t.params = fragment.getValue( getValueOptions );
				fragment.unbind();
			}
			t._fn = config.registries.transitions.find( ractive, name );
			if ( !t._fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'transition',
						name: name
					}
				} );
				return;
			}
		};
	}( log, config, circular );

	/* utils/camelCase.js */
	var camelCase = function( hyphenatedStr ) {
		return hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {
			return $1.toUpperCase();
		} );
	};

	/* virtualdom/items/Element/Transition/helpers/prefix.js */
	var prefix = function( isClient, vendors, createElement, camelCase ) {

		var prefix, prefixCache, testStyle;
		if ( !isClient ) {
			prefix = null;
		} else {
			prefixCache = {};
			testStyle = createElement( 'div' ).style;
			prefix = function( prop ) {
				var i, vendor, capped;
				prop = camelCase( prop );
				if ( !prefixCache[ prop ] ) {
					if ( testStyle[ prop ] !== undefined ) {
						prefixCache[ prop ] = prop;
					} else {
						// test vendors...
						capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );
						i = vendors.length;
						while ( i-- ) {
							vendor = vendors[ i ];
							if ( testStyle[ vendor + capped ] !== undefined ) {
								prefixCache[ prop ] = vendor + capped;
								break;
							}
						}
					}
				}
				return prefixCache[ prop ];
			};
		}
		return prefix;
	}( isClient, vendors, createElement, camelCase );

	/* virtualdom/items/Element/Transition/prototype/getStyle.js */
	var virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {

		var getStyle, getComputedStyle;
		if ( !isClient ) {
			getStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			getStyle = function( props ) {
				var computedStyle, styles, i, prop, value;
				computedStyle = getComputedStyle( this.node );
				if ( typeof props === 'string' ) {
					value = computedStyle[ prefix( props ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					return value;
				}
				if ( !isArray( props ) ) {
					throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
				}
				styles = {};
				i = props.length;
				while ( i-- ) {
					prop = props[ i ];
					value = computedStyle[ prefix( prop ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					styles[ prop ] = value;
				}
				return styles;
			};
		}
		return getStyle;
	}( legacy, isClient, isArray, prefix );

	/* virtualdom/items/Element/Transition/prototype/setStyle.js */
	var virtualdom_items_Element_Transition$setStyle = function( prefix ) {

		return function( style, value ) {
			var prop;
			if ( typeof style === 'string' ) {
				this.node.style[ prefix( style ) ] = value;
			} else {
				for ( prop in style ) {
					if ( style.hasOwnProperty( prop ) ) {
						this.node.style[ prefix( prop ) ] = style[ prop ];
					}
				}
			}
			return this;
		};
	}( prefix );

	/* shared/Ticker.js */
	var Ticker = function( warn, getTime, animations ) {

		// TODO what happens if a transition is aborted?
		// TODO use this with Animation to dedupe some code?
		var Ticker = function( options ) {
			var easing;
			this.duration = options.duration;
			this.step = options.step;
			this.complete = options.complete;
			// easing
			if ( typeof options.easing === 'string' ) {
				easing = options.root.easing[ options.easing ];
				if ( !easing ) {
					warn( 'Missing easing function ("' + options.easing + '"). You may need to download a plugin from [TODO]' );
					easing = linear;
				}
			} else if ( typeof options.easing === 'function' ) {
				easing = options.easing;
			} else {
				easing = linear;
			}
			this.easing = easing;
			this.start = getTime();
			this.end = this.start + this.duration;
			this.running = true;
			animations.add( this );
		};
		Ticker.prototype = {
			tick: function( now ) {
				var elapsed, eased;
				if ( !this.running ) {
					return false;
				}
				if ( now > this.end ) {
					if ( this.step ) {
						this.step( 1 );
					}
					if ( this.complete ) {
						this.complete( 1 );
					}
					return false;
				}
				elapsed = now - this.start;
				eased = this.easing( elapsed / this.duration );
				if ( this.step ) {
					this.step( eased );
				}
				return true;
			},
			stop: function() {
				if ( this.abort ) {
					this.abort();
				}
				this.running = false;
			}
		};
		return Ticker;

		function linear( t ) {
			return t;
		}
	}( warn, getTime, animations );

	/* virtualdom/items/Element/Transition/helpers/unprefix.js */
	var unprefix = function( vendors ) {

		var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );
		return function( prop ) {
			return prop.replace( unprefixPattern, '' );
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/helpers/hyphenate.js */
	var hyphenate = function( vendors ) {

		var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );
		return function( str ) {
			var hyphenated;
			if ( !str ) {
				return '';
			}
			if ( vendorPattern.test( str ) ) {
				str = '-' + str;
			}
			hyphenated = str.replace( /[A-Z]/g, function( match ) {
				return '-' + match.toLowerCase();
			} );
			return hyphenated;
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */
	var virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {

		var createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},
			cannotUseCssTransitions = {};
		if ( !isClient ) {
			createTransitions = null;
		} else {
			testStyle = createElement( 'div' ).style;
			// determine some facts about our environment
			( function() {
				if ( testStyle.transition !== undefined ) {
					TRANSITION = 'transition';
					TRANSITIONEND = 'transitionend';
					CSS_TRANSITIONS_ENABLED = true;
				} else if ( testStyle.webkitTransition !== undefined ) {
					TRANSITION = 'webkitTransition';
					TRANSITIONEND = 'webkitTransitionEnd';
					CSS_TRANSITIONS_ENABLED = true;
				} else {
					CSS_TRANSITIONS_ENABLED = false;
				}
			}() );
			if ( TRANSITION ) {
				TRANSITION_DURATION = TRANSITION + 'Duration';
				TRANSITION_PROPERTY = TRANSITION + 'Property';
				TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
			}
			createTransitions = function( t, to, options, changedProperties, resolve ) {
				// Wait a beat (otherwise the target styles will be applied immediately)
				// TODO use a fastdom-style mechanism?
				setTimeout( function() {
					var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;
					checkComplete = function() {
						if ( jsTransitionsComplete && cssTransitionsComplete ) {
							t.root.fire( t.name + ':end', t.node, t.isIntro );
							resolve();
						}
					};
					// this is used to keep track of which elements can use CSS to animate
					// which properties
					hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;
					t.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );
					t.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
					t.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';
					transitionEndHandler = function( event ) {
						var index;
						index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );
						if ( index !== -1 ) {
							changedProperties.splice( index, 1 );
						}
						if ( changedProperties.length ) {
							// still transitioning...
							return;
						}
						t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
						cssTransitionsComplete = true;
						checkComplete();
					};
					t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );
					setTimeout( function() {
						var i = changedProperties.length,
							hash, originalValue, index, propertiesToTransitionInJs = [],
							prop, suffix;
						while ( i-- ) {
							prop = changedProperties[ i ];
							hash = hashPrefix + prop;
							if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
								t.node.style[ prefix( prop ) ] = to[ prop ];
								// If we're not sure if CSS transitions are supported for
								// this tag/property combo, find out now
								if ( !canUseCssTransitions[ hash ] ) {
									originalValue = t.getStyle( prop );
									// if this property is transitionable in this browser,
									// the current style will be different from the target style
									canUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];
									cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];
									// Reset, if we're going to use timers after all
									if ( cannotUseCssTransitions[ hash ] ) {
										t.node.style[ prefix( prop ) ] = originalValue;
									}
								}
							}
							if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
								// we need to fall back to timer-based stuff
								if ( originalValue === undefined ) {
									originalValue = t.getStyle( prop );
								}
								// need to remove this from changedProperties, otherwise transitionEndHandler
								// will get confused
								index = changedProperties.indexOf( prop );
								if ( index === -1 ) {
									warn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );
								} else {
									changedProperties.splice( index, 1 );
								}
								// TODO Determine whether this property is animatable at all
								suffix = /[^\d]*$/.exec( to[ prop ] )[ 0 ];
								// ...then kick off a timer-based transition
								propertiesToTransitionInJs.push( {
									name: prefix( prop ),
									interpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),
									suffix: suffix
								} );
							}
						}
						// javascript transitions
						if ( propertiesToTransitionInJs.length ) {
							new Ticker( {
								root: t.root,
								duration: options.duration,
								easing: camelCase( options.easing || '' ),
								step: function( pos ) {
									var prop, i;
									i = propertiesToTransitionInJs.length;
									while ( i-- ) {
										prop = propertiesToTransitionInJs[ i ];
										t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
									}
								},
								complete: function() {
									jsTransitionsComplete = true;
									checkComplete();
								}
							} );
						} else {
							jsTransitionsComplete = true;
						}
						if ( !changedProperties.length ) {
							// We need to cancel the transitionEndHandler, and deal with
							// the fact that it will never fire
							t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
							cssTransitionsComplete = true;
							checkComplete();
						}
					}, 0 );
				}, options.delay || 0 );
			};
		}
		return createTransitions;
	}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */
	var virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {

		var hidden, vendor, prefix, i, visibility;
		if ( typeof document !== 'undefined' ) {
			hidden = 'hidden';
			visibility = {};
			if ( hidden in document ) {
				prefix = '';
			} else {
				i = vendors.length;
				while ( i-- ) {
					vendor = vendors[ i ];
					hidden = vendor + 'Hidden';
					if ( hidden in document ) {
						prefix = vendor;
					}
				}
			}
			if ( prefix !== undefined ) {
				document.addEventListener( prefix + 'visibilitychange', onChange );
				// initialise
				onChange();
			} else {
				// gah, we're in an old browser
				if ( 'onfocusout' in document ) {
					document.addEventListener( 'focusout', onHide );
					document.addEventListener( 'focusin', onShow );
				} else {
					window.addEventListener( 'pagehide', onHide );
					window.addEventListener( 'blur', onHide );
					window.addEventListener( 'pageshow', onShow );
					window.addEventListener( 'focus', onShow );
				}
				visibility.hidden = false;
			}
		}

		function onChange() {
			visibility.hidden = document[ hidden ];
		}

		function onHide() {
			visibility.hidden = true;
		}

		function onShow() {
			visibility.hidden = false;
		}
		return visibility;
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */
	var virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {

		var animateStyle, getComputedStyle, resolved;
		if ( !isClient ) {
			animateStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			animateStyle = function( style, value, options, complete ) {
				var t = this,
					to;
				// Special case - page isn't visible. Don't animate anything, because
				// that way you'll never get CSS transitionend events
				if ( visibility.hidden ) {
					this.setStyle( style, value );
					return resolved || ( resolved = Promise.resolve() );
				}
				if ( typeof style === 'string' ) {
					to = {};
					to[ style ] = value;
				} else {
					to = style;
					// shuffle arguments
					complete = options;
					options = value;
				}
				// As of 0.3.9, transition authors should supply an `option` object with
				// `duration` and `easing` properties (and optional `delay`), plus a
				// callback function that gets called after the animation completes
				// TODO remove this check in a future version
				if ( !options ) {
					warn( 'The "' + t.name + '" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );
					options = t;
					complete = t.complete;
				}
				var promise = new Promise( function( resolve ) {
					var propertyNames, changedProperties, computedStyle, current, from, i, prop;
					// Edge case - if duration is zero, set style synchronously and complete
					if ( !options.duration ) {
						t.setStyle( to );
						resolve();
						return;
					}
					// Get a list of the properties we're animating
					propertyNames = Object.keys( to );
					changedProperties = [];
					// Store the current styles
					computedStyle = getComputedStyle( t.node );
					from = {};
					i = propertyNames.length;
					while ( i-- ) {
						prop = propertyNames[ i ];
						current = computedStyle[ prefix( prop ) ];
						if ( current === '0px' ) {
							current = 0;
						}
						// we need to know if we're actually changing anything
						if ( current != to[ prop ] ) {
							// use != instead of !==, so we can compare strings with numbers
							changedProperties.push( prop );
							// make the computed style explicit, so we can animate where
							// e.g. height='auto'
							t.node.style[ prefix( prop ) ] = current;
						}
					}
					// If we're not actually changing anything, the transitionend event
					// will never fire! So we complete early
					if ( !changedProperties.length ) {
						resolve();
						return;
					}
					createTransitions( t, to, options, changedProperties, resolve );
				} );
				// If a callback was supplied, do the honours
				// TODO remove this check in future
				if ( complete ) {
					warn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );
					promise.then( complete );
				}
				return promise;
			};
		}
		return animateStyle;
	}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );

	/* utils/fillGaps.js */
	var fillGaps = function( target, source ) {
		var key;
		for ( key in source ) {
			if ( source.hasOwnProperty( key ) && !( key in target ) ) {
				target[ key ] = source[ key ];
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Transition/prototype/processParams.js */
	var virtualdom_items_Element_Transition$processParams = function( fillGaps ) {

		return function( params, defaults ) {
			if ( typeof params === 'number' ) {
				params = {
					duration: params
				};
			} else if ( typeof params === 'string' ) {
				if ( params === 'slow' ) {
					params = {
						duration: 600
					};
				} else if ( params === 'fast' ) {
					params = {
						duration: 200
					};
				} else {
					params = {
						duration: 400
					};
				}
			} else if ( !params ) {
				params = {};
			}
			return fillGaps( params, defaults );
		};
	}( fillGaps );

	/* virtualdom/items/Element/Transition/prototype/start.js */
	var virtualdom_items_Element_Transition$start = function() {

		return function Transition$start() {
			var t = this,
				node, originalStyle;
			node = t.node = t.element.node;
			originalStyle = node.getAttribute( 'style' );
			// create t.complete() - we don't want this on the prototype,
			// because we don't want `this` silliness when passing it as
			// an argument
			t.complete = function( noReset ) {
				if ( !noReset && t.isIntro ) {
					resetStyle( node, originalStyle );
				}
				node._ractive.transition = null;
				t._manager.remove( t );
			};
			// If the transition function doesn't exist, abort
			if ( !t._fn ) {
				t.complete();
				return;
			}
			t._fn.apply( t.root, [ t ].concat( t.params ) );
		};

		function resetStyle( node, style ) {
			if ( style ) {
				node.setAttribute( 'style', style );
			} else {
				// Next line is necessary, to remove empty style attribute!
				// See http://stackoverflow.com/a/7167553
				node.getAttribute( 'style' );
				node.removeAttribute( 'style' );
			}
		}
	}();

	/* virtualdom/items/Element/Transition/_Transition.js */
	var Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {

		var Fragment, Transition;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Transition = function( owner, template, isIntro ) {
			this.init( owner, template, isIntro );
		};
		Transition.prototype = {
			init: init,
			start: start,
			getStyle: getStyle,
			setStyle: setStyle,
			animateStyle: animateStyle,
			processParams: processParams
		};
		return Transition;
	}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );

	/* virtualdom/items/Element/prototype/render.js */
	var virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {

		var updateCss, updateScript;
		updateCss = function() {
			var node = this.node,
				content = this.fragment.toString( false );
			if ( node.styleSheet ) {
				node.styleSheet.cssText = content;
			} else {
				while ( node.hasChildNodes() ) {
					node.removeChild( node.firstChild );
				}
				node.appendChild( document.createTextNode( content ) );
			}
		};
		updateScript = function() {
			if ( !this.node.type || this.node.type === 'text/javascript' ) {
				warn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );
			}
			this.node.text = this.fragment.toString( false );
		};
		return function Element$render() {
			var this$0 = this;
			var root = this.root,
				namespace, node;
			namespace = getNamespace( this );
			node = this.node = createElement( this.name, namespace );
			// Is this a top-level node of a component? If so, we may need to add
			// a data-rvcguid attribute, for CSS encapsulation
			// NOTE: css no longer copied to instance, so we check constructor.css -
			// we can enhance to handle instance, but this is more "correct" with current
			// functionality
			if ( root.constructor.css && this.parentFragment.getNode() === root.el ) {
				this.node.setAttribute( 'data-rvcguid', root.constructor._guid );
			}
			// Add _ractive property to the node - we use this object to store stuff
			// related to proxy events, two-way bindings etc
			defineProperty( this.node, '_ractive', {
				value: {
					proxy: this,
					keypath: getInnerContext( this.parentFragment ),
					index: this.parentFragment.indexRefs,
					events: create( null ),
					root: root
				}
			} );
			// Render attributes
			this.attributes.forEach( function( a ) {
				return a.render( node );
			} );
			// Render children
			if ( this.fragment ) {
				// Special case - <script> element
				if ( this.name === 'script' ) {
					this.bubble = updateScript;
					this.node.text = this.fragment.toString( false );
					// bypass warning initially
					this.fragment.unrender = noop;
				} else if ( this.name === 'style' ) {
					this.bubble = updateCss;
					this.bubble();
					this.fragment.unrender = noop;
				} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {
					this.fragment.unrender = noop;
				} else {
					this.node.appendChild( this.fragment.render() );
				}
			}
			// Add proxy event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.render();
				} );
			}
			// deal with two-way bindings
			if ( this.binding ) {
				this.binding.render();
				this.node._ractive.binding = this.binding;
			}
			// Special case: if this is an <img>, and we're in a crap browser, we may
			// need to prevent it from overriding width and height when it loads the src
			if ( this.name === 'img' ) {
				renderImage( this );
			}
			// apply decorator(s)
			if ( this.decorator && this.decorator.fn ) {
				runloop.scheduleTask( function() {
					this$0.decorator.init();
				} );
			}
			// trigger intro transition
			if ( root.transitionsEnabled && this.intro ) {
				var transition = new Transition( this, this.intro, true );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			if ( this.name === 'option' ) {
				processOption( this );
			}
			if ( this.node.autofocus ) {
				// Special case. Some browsers (*cough* Firefix *cough*) have a problem
				// with dynamically-generated elements having autofocus, and they won't
				// allow you to programmatically focus the element until it's in the DOM
				runloop.scheduleTask( function() {
					return this$0.node.focus();
				} );
			}
			updateLiveQueries( this );
			return this.node;
		};

		function getNamespace( element ) {
			var namespace, xmlns, parent;
			// Use specified namespace...
			if ( xmlns = element.getAttribute( 'xmlns' ) ) {
				namespace = xmlns;
			} else if ( element.name === 'svg' ) {
				namespace = namespaces.svg;
			} else if ( parent = element.parent ) {
				// ...or HTML, if the parent is a <foreignObject>
				if ( parent.name === 'foreignObject' ) {
					namespace = namespaces.html;
				} else {
					namespace = parent.node.namespaceURI;
				}
			} else {
				namespace = element.root.el.namespaceURI;
			}
			return namespace;
		}

		function processOption( option ) {
			var optionValue, selectValue, i;
			selectValue = option.select.getAttribute( 'value' );
			if ( selectValue === undefined ) {
				return;
			}
			optionValue = option.getAttribute( 'value' );
			if ( option.select.node.multiple && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( optionValue == selectValue[ i ] ) {
						option.node.selected = true;
						break;
					}
				}
			} else {
				option.node.selected = optionValue == selectValue;
			}
		}

		function updateLiveQueries( element ) {
			var instance, liveQueries, i, selector, query;
			// Does this need to be added to any live queries?
			instance = element.root;
			do {
				liveQueries = instance._liveQueries;
				i = liveQueries.length;
				while ( i-- ) {
					selector = liveQueries[ i ];
					query = liveQueries[ '_' + selector ];
					if ( query._test( element ) ) {
						// keep register of applicable selectors, for when we teardown
						( element.liveQueries || ( element.liveQueries = [] ) ).push( query );
					}
				}
			} while ( instance = instance._parent );
		}
	}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );

	/* virtualdom/items/Element/prototype/toString.js */
	var virtualdom_items_Element$toString = function( voidElementNames, isArray ) {

		return function() {
			var str, escape;
			str = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );
			str += this.attributes.map( stringifyAttribute ).join( '' );
			// Special case - selected options
			if ( this.name === 'option' && optionIsSelected( this ) ) {
				str += ' selected';
			}
			// Special case - two-way radio name bindings
			if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
				str += ' checked';
			}
			str += '>';
			if ( this.fragment ) {
				escape = this.name !== 'script' && this.name !== 'style';
				str += this.fragment.toString( escape );
			}
			// add a closing tag if this isn't a void element
			if ( !voidElementNames.test( this.template.e ) ) {
				str += '</' + this.template.e + '>';
			}
			return str;
		};

		function optionIsSelected( element ) {
			var optionValue, selectValue, i;
			optionValue = element.getAttribute( 'value' );
			if ( optionValue === undefined ) {
				return false;
			}
			selectValue = element.select.getAttribute( 'value' );
			if ( selectValue == optionValue ) {
				return true;
			}
			if ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( selectValue[ i ] == optionValue ) {
						return true;
					}
				}
			}
		}

		function inputIsCheckedRadio( element ) {
			var attributes, typeAttribute, valueAttribute, nameAttribute;
			attributes = element.attributes;
			typeAttribute = attributes.type;
			valueAttribute = attributes.value;
			nameAttribute = attributes.name;
			if ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {
				return;
			}
			if ( valueAttribute.value === nameAttribute.interpolator.value ) {
				return true;
			}
		}

		function stringifyAttribute( attribute ) {
			var str = attribute.toString();
			return str ? ' ' + str : '';
		}
	}( voidElementNames, isArray );

	/* virtualdom/items/Element/special/option/unbind.js */
	var virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {

		return function unbindOption( option ) {
			removeFromArray( option.select.options, option );
		};
	}( removeFromArray );

	/* virtualdom/items/Element/prototype/unbind.js */
	var virtualdom_items_Element$unbind = function( unbindOption ) {

		return function Element$unbind() {
			if ( this.fragment ) {
				this.fragment.unbind();
			}
			if ( this.binding ) {
				this.binding.unbind();
			}
			// Special case - <option>
			if ( this.name === 'option' ) {
				unbindOption( this );
			}
			this.attributes.forEach( unbindAttribute );
		};

		function unbindAttribute( attribute ) {
			attribute.unbind();
		}
	}( virtualdom_items_Element_special_option_unbind );

	/* virtualdom/items/Element/prototype/unrender.js */
	var virtualdom_items_Element$unrender = function( runloop, Transition ) {

		return function Element$unrender( shouldDestroy ) {
			var binding, bindings;
			// Detach as soon as we can
			if ( this.name === 'option' ) {
				// <option> elements detach immediately, so that
				// their parent <select> element syncs correctly, and
				// since option elements can't have transitions anyway
				this.detach();
			} else if ( shouldDestroy ) {
				runloop.detachWhenReady( this );
			}
			// Children first. that way, any transitions on child elements will be
			// handled by the current transitionManager
			if ( this.fragment ) {
				this.fragment.unrender( false );
			}
			if ( binding = this.binding ) {
				this.binding.unrender();
				this.node._ractive.binding = null;
				bindings = this.root._twowayBindings[ binding.keypath ];
				bindings.splice( bindings.indexOf( binding ), 1 );
			}
			// Remove event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.unrender();
				} );
			}
			if ( this.decorator ) {
				this.decorator.teardown();
			}
			// trigger outro transition if necessary
			if ( this.root.transitionsEnabled && this.outro ) {
				var transition = new Transition( this, this.outro, false );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			// Remove this node from any live queries
			if ( this.liveQueries ) {
				removeFromLiveQueries( this );
			}
		};

		function removeFromLiveQueries( element ) {
			var query, selector, i;
			i = element.liveQueries.length;
			while ( i-- ) {
				query = element.liveQueries[ i ];
				selector = query.selector;
				query._remove( element.node );
			}
		}
	}( runloop, Transition );

	/* virtualdom/items/Element/_Element.js */
	var Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {

		var Element = function( options ) {
			this.init( options );
		};
		Element.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getAttribute: getAttribute,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Element;
	}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );

	/* virtualdom/items/Partial/deIndent.js */
	var deIndent = function() {

		var empty = /^\s*$/,
			leadingWhitespace = /^\s*/;
		return function( str ) {
			var lines, firstLine, lastLine, minIndent;
			lines = str.split( '\n' );
			// remove first and last line, if they only contain whitespace
			firstLine = lines[ 0 ];
			if ( firstLine !== undefined && empty.test( firstLine ) ) {
				lines.shift();
			}
			lastLine = lines[ lines.length - 1 ];
			if ( lastLine !== undefined && empty.test( lastLine ) ) {
				lines.pop();
			}
			minIndent = lines.reduce( reducer, null );
			if ( minIndent ) {
				str = lines.map( function( line ) {
					return line.replace( minIndent, '' );
				} ).join( '\n' );
			}
			return str;
		};

		function reducer( previous, line ) {
			var lineIndent = leadingWhitespace.exec( line )[ 0 ];
			if ( previous === null || lineIndent.length < previous.length ) {
				return lineIndent;
			}
			return previous;
		}
	}();

	/* virtualdom/items/Partial/getPartialDescriptor.js */
	var getPartialDescriptor = function( log, config, parser, deIndent ) {

		return function getPartialDescriptor( ractive, name ) {
			var partial;
			// If the partial in instance or view heirarchy instances, great
			if ( partial = getPartialFromRegistry( ractive, name ) ) {
				return partial;
			}
			// Does it exist on the page as a script tag?
			partial = parser.fromId( name, {
				noThrow: true
			} );
			if ( partial ) {
				// is this necessary?
				partial = deIndent( partial );
				// parse and register to this ractive instance
				var parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
				// register (and return main partial if there are others in the template)
				return ractive.partials[ name ] = parsed.t;
			}
			log.error( {
				debug: ractive.debug,
				message: 'noTemplateForPartial',
				args: {
					name: name
				}
			} );
			// No match? Return an empty array
			return [];
		};

		function getPartialFromRegistry( ractive, name ) {
			var partials = config.registries.partials;
			// find first instance in the ractive or view hierarchy that has this partial
			var instance = partials.findInstance( ractive, name );
			if ( !instance ) {
				return;
			}
			var partial = instance.partials[ name ],
				fn;
			// partial is a function?
			if ( typeof partial === 'function' ) {
				fn = partial.bind( instance );
				fn.isOwner = instance.partials.hasOwnProperty( name );
				partial = fn( instance.data, parser );
			}
			if ( !partial ) {
				log.warn( {
					debug: ractive.debug,
					message: 'noRegistryFunctionReturn',
					args: {
						registry: 'partial',
						name: name
					}
				} );
				return;
			}
			// If this was added manually to the registry,
			// but hasn't been parsed, parse it now
			if ( !parser.isParsed( partial ) ) {
				// use the parseOptions of the ractive instance on which it was found
				var parsed = parser.parse( partial, parser.getParseOptions( instance ) );
				// Partials cannot contain nested partials!
				// TODO add a test for this
				if ( parsed.p ) {
					log.warn( {
						debug: ractive.debug,
						message: 'noNestedPartials',
						args: {
							rname: name
						}
					} );
				}
				// if fn, use instance to store result, otherwise needs to go
				// in the correct point in prototype chain on instance or constructor
				var target = fn ? instance : partials.findOwner( instance, name );
				// may be a template with partials, which need to be registered and main template extracted
				target.partials[ name ] = partial = parsed.t;
			}
			// store for reset
			if ( fn ) {
				partial._fn = fn;
			}
			return partial.v ? partial.t : partial;
		}
	}( log, config, parser, deIndent );

	/* virtualdom/items/Partial/applyIndent.js */
	var applyIndent = function( string, indent ) {
		var indented;
		if ( !indent ) {
			return string;
		}
		indented = string.split( '\n' ).map( function( line, notFirstLine ) {
			return notFirstLine ? indent + line : line;
		} ).join( '\n' );
		return indented;
	};

	/* virtualdom/items/Partial/_Partial.js */
	var Partial = function( types, getPartialDescriptor, applyIndent, circular ) {

		var Partial, Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Partial = function( options ) {
			var parentFragment = this.parentFragment = options.parentFragment,
				template;
			this.type = types.PARTIAL;
			this.name = options.template.r;
			this.index = options.index;
			this.root = parentFragment.root;
			if ( !options.template.r ) {
				// TODO support dynamic partial switching
				throw new Error( 'Partials must have a static reference (no expressions). This may change in a future version of Ractive.' );
			}
			template = getPartialDescriptor( parentFragment.root, options.template.r );
			this.fragment = new Fragment( {
				template: template,
				root: parentFragment.root,
				owner: this,
				pElement: parentFragment.pElement
			} );
		};
		Partial.prototype = {
			bubble: function() {
				this.parentFragment.bubble();
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			findNextNode: function() {
				return this.parentFragment.findNextNode( this );
			},
			detach: function() {
				return this.fragment.detach();
			},
			render: function() {
				return this.fragment.render();
			},
			unrender: function( shouldDestroy ) {
				this.fragment.unrender( shouldDestroy );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				return this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			},
			toString: function( toString ) {
				var string, previousItem, lastLine, match;
				string = this.fragment.toString( toString );
				previousItem = this.parentFragment.items[ this.index - 1 ];
				if ( !previousItem || previousItem.type !== types.TEXT ) {
					return string;
				}
				lastLine = previousItem.template.split( '\n' ).pop();
				if ( match = /^\s+$/.exec( lastLine ) ) {
					return applyIndent( string, match[ 0 ] );
				}
				return string;
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			getValue: function() {
				return this.fragment.getValue();
			}
		};
		return Partial;
	}( types, getPartialDescriptor, applyIndent, circular );

	/* virtualdom/items/Component/getComponent.js */
	var getComponent = function( config, log, circular ) {

		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		// finds the component constructor in the registry or view hierarchy registries
		return function getComponent( ractive, name ) {
			var component, instance = config.registries.components.findInstance( ractive, name );
			if ( instance ) {
				component = instance.components[ name ];
				// best test we have for not Ractive.extend
				if ( !component._parent ) {
					// function option, execute and store for reset
					var fn = component.bind( instance );
					fn.isOwner = instance.components.hasOwnProperty( name );
					component = fn( instance.data );
					if ( !component ) {
						log.warn( {
							debug: ractive.debug,
							message: 'noRegistryFunctionReturn',
							args: {
								registry: 'component',
								name: name
							}
						} );
						return;
					}
					if ( typeof component === 'string' ) {
						//allow string lookup
						component = getComponent( ractive, component );
					}
					component._fn = fn;
					instance.components[ name ] = component;
				}
			}
			return component;
		};
	}( config, log, circular );

	/* virtualdom/items/Component/prototype/detach.js */
	var virtualdom_items_Component$detach = function Component$detach() {
		return this.instance.fragment.detach();
	};

	/* virtualdom/items/Component/prototype/find.js */
	var virtualdom_items_Component$find = function Component$find( selector ) {
		return this.instance.fragment.find( selector );
	};

	/* virtualdom/items/Component/prototype/findAll.js */
	var virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {
		return this.instance.fragment.findAll( selector, query );
	};

	/* virtualdom/items/Component/prototype/findAllComponents.js */
	var virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {
		query._test( this, true );
		if ( this.instance.fragment ) {
			this.instance.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Component/prototype/findComponent.js */
	var virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {
		if ( !selector || selector === this.name ) {
			return this.instance;
		}
		if ( this.instance.fragment ) {
			return this.instance.fragment.findComponent( selector );
		}
		return null;
	};

	/* virtualdom/items/Component/prototype/findNextNode.js */
	var virtualdom_items_Component$findNextNode = function Component$findNextNode() {
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Component/prototype/firstNode.js */
	var virtualdom_items_Component$firstNode = function Component$firstNode() {
		if ( this.rendered ) {
			return this.instance.fragment.firstNode();
		}
		return null;
	};

	/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */
	var ComponentParameter = function( runloop, circular ) {

		var Fragment, ComponentParameter;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		ComponentParameter = function( component, key, value ) {
			this.parentFragment = component.parentFragment;
			this.component = component;
			this.key = key;
			this.fragment = new Fragment( {
				template: value,
				root: component.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
		};
		ComponentParameter.prototype = {
			bubble: function() {
				if ( !this.dirty ) {
					this.dirty = true;
					runloop.addView( this );
				}
			},
			update: function() {
				var value = this.fragment.getValue();
				this.component.instance.viewmodel.set( this.key, value );
				runloop.addViewmodel( this.component.instance.viewmodel );
				this.value = value;
				this.dirty = false;
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			}
		};
		return ComponentParameter;
	}( runloop, circular );

	/* virtualdom/items/Component/initialise/createModel/_createModel.js */
	var createModel = function( types, parseJSON, resolveRef, ComponentParameter ) {

		return function( component, defaultData, attributes, toBind ) {
			var data = {},
				key, value;
			// some parameters, e.g. foo="The value is {{bar}}", are 'complex' - in
			// other words, we need to construct a string fragment to watch
			// when they change. We store these so they can be torn down later
			component.complexParameters = [];
			for ( key in attributes ) {
				if ( attributes.hasOwnProperty( key ) ) {
					value = getValue( component, key, attributes[ key ], toBind );
					if ( value !== undefined || defaultData[ key ] === undefined ) {
						data[ key ] = value;
					}
				}
			}
			return data;
		};

		function getValue( component, key, template, toBind ) {
			var parameter, parsed, parentInstance, parentFragment, keypath, indexRef;
			parentInstance = component.root;
			parentFragment = component.parentFragment;
			// If this is a static value, great
			if ( typeof template === 'string' ) {
				parsed = parseJSON( template );
				if ( !parsed ) {
					return template;
				}
				return parsed.value;
			}
			// If null, we treat it as a boolean attribute (i.e. true)
			if ( template === null ) {
				return true;
			}
			// If a regular interpolator, we bind to it
			if ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR && template[ 0 ].r ) {
				// Is it an index reference?
				if ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {
					component.indexRefBindings[ indexRef ] = key;
					return parentFragment.indexRefs[ indexRef ];
				}
				// TODO what about references that resolve late? Should these be considered?
				keypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;
				// We need to set up bindings between parent and child, but
				// we can't do it yet because the child instance doesn't exist
				// yet - so we make a note instead
				toBind.push( {
					childKeypath: key,
					parentKeypath: keypath
				} );
				return parentInstance.viewmodel.get( keypath );
			}
			// We have a 'complex parameter' - we need to create a full-blown string
			// fragment in order to evaluate and observe its value
			parameter = new ComponentParameter( component, key, template );
			component.complexParameters.push( parameter );
			return parameter.value;
		}
	}( types, parseJSON, resolveRef, ComponentParameter );

	/* virtualdom/items/Component/initialise/createInstance.js */
	var createInstance = function( component, Component, data, contentDescriptor ) {
		var instance, parentFragment, partials, root;
		parentFragment = component.parentFragment;
		root = component.root;
		// Make contents available as a {{>content}} partial
		partials = {
			content: contentDescriptor || []
		};
		instance = new Component( {
			append: true,
			data: data,
			partials: partials,
			magic: root.magic || Component.defaults.magic,
			modifyArrays: root.modifyArrays,
			_parent: root,
			_component: component,
			// need to inherit runtime parent adaptors
			adapt: root.adapt
		} );
		return instance;
	};

	/* virtualdom/items/Component/initialise/createBindings.js */
	var createBindings = function( createComponentBinding ) {

		return function createInitialComponentBindings( component, toBind ) {
			toBind.forEach( function createInitialComponentBinding( pair ) {
				var childValue, parentValue;
				createComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );
				childValue = component.instance.viewmodel.get( pair.childKeypath );
				parentValue = component.root.viewmodel.get( pair.parentKeypath );
				if ( childValue !== undefined && parentValue === undefined ) {
					component.root.viewmodel.set( pair.parentKeypath, childValue );
				}
			} );
		};
	}( createComponentBinding );

	/* virtualdom/items/Component/initialise/propagateEvents.js */
	var propagateEvents = function( log ) {

		// TODO how should event arguments be handled? e.g.
		// <widget on-foo='bar:1,2,3'/>
		// The event 'bar' will be fired on the parent instance
		// when 'foo' fires on the child, but the 1,2,3 arguments
		// will be lost
		return function( component, eventsDescriptor ) {
			var eventName;
			for ( eventName in eventsDescriptor ) {
				if ( eventsDescriptor.hasOwnProperty( eventName ) ) {
					propagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );
				}
			}
		};

		function propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {
			if ( typeof proxyEventName !== 'string' ) {
				log.error( {
					debug: parentInstance.debug,
					message: 'noComponentEventArguments'
				} );
			}
			childInstance.on( eventName, function() {
				var args = Array.prototype.slice.call( arguments );
				args.unshift( proxyEventName );
				parentInstance.fire.apply( parentInstance, args );
			} );
		}
	}( log );

	/* virtualdom/items/Component/initialise/updateLiveQueries.js */
	var updateLiveQueries = function( component ) {
		var ancestor, query;
		// If there's a live query for this component type, add it
		ancestor = component.root;
		while ( ancestor ) {
			if ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {
				query.push( component.instance );
			}
			ancestor = ancestor._parent;
		}
	};

	/* virtualdom/items/Component/prototype/init.js */
	var virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {

		return function Component$init( options, Component ) {
			var parentFragment, root, data, toBind;
			parentFragment = this.parentFragment = options.parentFragment;
			root = parentFragment.root;
			this.root = root;
			this.type = types.COMPONENT;
			this.name = options.template.e;
			this.index = options.index;
			this.indexRefBindings = {};
			this.bindings = [];
			if ( !Component ) {
				throw new Error( 'Component "' + this.name + '" not found' );
			}
			// First, we need to create a model for the component - e.g. if we
			// encounter <widget foo='bar'/> then we need to create a widget
			// with `data: { foo: 'bar' }`.
			//
			// This may involve setting up some bindings, but we can't do it
			// yet so we take some notes instead
			toBind = [];
			data = createModel( this, Component.defaults.data || {}, options.template.a, toBind );
			createInstance( this, Component, data, options.template.f );
			createBindings( this, toBind );
			propagateEvents( this, options.template.v );
			// intro, outro and decorator directives have no effect
			if ( options.template.t1 || options.template.t2 || options.template.o ) {
				warn( 'The "intro", "outro" and "decorator" directives have no effect on components' );
			}
			updateLiveQueries( this );
		};
	}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );

	/* virtualdom/items/Component/prototype/rebind.js */
	var virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {

		return function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var childInstance = this.instance,
				parentInstance = childInstance._parent,
				indexRefAlias, query;
			this.bindings.forEach( function( binding ) {
				var updated;
				if ( binding.root !== parentInstance ) {
					return;
				}
				if ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {
					binding.rebind( updated );
				}
			} );
			this.complexParameters.forEach( function( parameter ) {
				parameter.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			} );
			if ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {
				runloop.addViewmodel( childInstance.viewmodel );
				childInstance.viewmodel.set( indexRefAlias, newIndex );
			}
			if ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {
				query._makeDirty();
			}
		};
	}( runloop, getNewKeypath );

	/* virtualdom/items/Component/prototype/render.js */
	var virtualdom_items_Component$render = function Component$render() {
		var instance = this.instance;
		instance.render( this.parentFragment.getNode() );
		this.rendered = true;
		return instance.detach();
	};

	/* virtualdom/items/Component/prototype/toString.js */
	var virtualdom_items_Component$toString = function Component$toString() {
		return this.instance.fragment.toString();
	};

	/* virtualdom/items/Component/prototype/unbind.js */
	var virtualdom_items_Component$unbind = function() {

		return function Component$unbind() {
			this.complexParameters.forEach( unbind );
			this.bindings.forEach( unbind );
			removeFromLiveComponentQueries( this );
			this.instance.fragment.unbind();
		};

		function unbind( thing ) {
			thing.unbind();
		}

		function removeFromLiveComponentQueries( component ) {
			var instance, query;
			instance = component.root;
			do {
				if ( query = instance._liveComponentQueries[ '_' + component.name ] ) {
					query._remove( component );
				}
			} while ( instance = instance._parent );
		}
	}();

	/* virtualdom/items/Component/prototype/unrender.js */
	var virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {
		this.instance.fire( 'teardown' );
		this.shouldDestroy = shouldDestroy;
		this.instance.unrender();
	};

	/* virtualdom/items/Component/_Component.js */
	var Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {

		var Component = function( options, Constructor ) {
			this.init( options, Constructor );
		};
		Component.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Component;
	}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );

	/* virtualdom/items/Comment.js */
	var Comment = function( types, detach ) {

		var Comment = function( options ) {
			this.type = types.COMMENT;
			this.value = options.template.c;
		};
		Comment.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createComment( this.value );
				}
				return this.node;
			},
			toString: function() {
				return '<!--' + this.value + '-->';
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					this.node.parentNode.removeChild( this.node );
				}
			}
		};
		return Comment;
	}( types, detach );

	/* virtualdom/Fragment/prototype/init/createItem.js */
	var virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment ) {

		return function createItem( options ) {
			if ( typeof options.template === 'string' ) {
				return new Text( options );
			}
			switch ( options.template.t ) {
				case types.INTERPOLATOR:
					return new Interpolator( options );
				case types.SECTION:
					return new Section( options );
				case types.TRIPLE:
					return new Triple( options );
				case types.ELEMENT:
					var constructor;
					if ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {
						return new Component( options, constructor );
					}
					return new Element( options );
				case types.PARTIAL:
					return new Partial( options );
				case types.COMMENT:
					return new Comment( options );
				default:
					throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );
			}
		};
	}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment );

	/* virtualdom/Fragment/prototype/init.js */
	var virtualdom_Fragment$init = function( types, create, createItem ) {

		return function Fragment$init( options ) {
			var this$0 = this;
			var parentFragment, parentRefs, ref;
			// The item that owns this fragment - an element, section, partial, or attribute
			this.owner = options.owner;
			parentFragment = this.parent = this.owner.parentFragment;
			// inherited properties
			this.root = options.root;
			this.pElement = options.pElement;
			this.context = options.context;
			// If parent item is a section, this may not be the only fragment
			// that belongs to it - we need to make a note of the index
			if ( this.owner.type === types.SECTION ) {
				this.index = options.index;
			}
			// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade
			// down the tree
			if ( parentFragment ) {
				parentRefs = parentFragment.indexRefs;
				if ( parentRefs ) {
					this.indexRefs = create( null );
					// avoids need for hasOwnProperty
					for ( ref in parentRefs ) {
						this.indexRefs[ ref ] = parentRefs[ ref ];
					}
				}
			}
			// inherit priority
			this.priority = parentFragment ? parentFragment.priority + 1 : 1;
			if ( options.indexRef ) {
				if ( !this.indexRefs ) {
					this.indexRefs = {};
				}
				this.indexRefs[ options.indexRef ] = options.index;
			}
			// Time to create this fragment's child items
			// TEMP should this be happening?
			if ( typeof options.template === 'string' ) {
				options.template = [ options.template ];
			} else if ( !options.template ) {
				options.template = [];
			}
			this.items = options.template.map( function( template, i ) {
				return createItem( {
					parentFragment: this$0,
					pElement: options.pElement,
					template: template,
					index: i
				} );
			} );
			this.value = this.argsList = null;
			this.dirtyArgs = this.dirtyValue = true;
			this.inited = true;
		};
	}( types, create, virtualdom_Fragment$init_createItem );

	/* virtualdom/Fragment/prototype/rebind.js */
	var virtualdom_Fragment$rebind = function( assignNewKeypath ) {

		return function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			// assign new context keypath if needed
			assignNewKeypath( this, 'context', oldKeypath, newKeypath );
			if ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {
				this.indexRefs[ indexRef ] = newIndex;
			}
			this.items.forEach( function( item ) {
				if ( item.rebind ) {
					item.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			} );
		};
	}( assignNewKeypath );

	/* virtualdom/Fragment/prototype/render.js */
	var virtualdom_Fragment$render = function Fragment$render() {
		var result;
		if ( this.items.length === 1 ) {
			result = this.items[ 0 ].render();
		} else {
			result = document.createDocumentFragment();
			this.items.forEach( function( item ) {
				result.appendChild( item.render() );
			} );
		}
		this.rendered = true;
		return result;
	};

	/* virtualdom/Fragment/prototype/toString.js */
	var virtualdom_Fragment$toString = function Fragment$toString( escape ) {
		if ( !this.items ) {
			return '';
		}
		return this.items.map( function( item ) {
			return item.toString( escape );
		} ).join( '' );
	};

	/* virtualdom/Fragment/prototype/unbind.js */
	var virtualdom_Fragment$unbind = function() {

		return function Fragment$unbind() {
			this.items.forEach( unbindItem );
		};

		function unbindItem( item ) {
			if ( item.unbind ) {
				item.unbind();
			}
		}
	}();

	/* virtualdom/Fragment/prototype/unrender.js */
	var virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {
		if ( !this.rendered ) {
			throw new Error( 'Attempted to unrender a fragment that was not rendered' );
		}
		this.items.forEach( function( i ) {
			return i.unrender( shouldDestroy );
		} );
	};

	/* virtualdom/Fragment.js */
	var Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {

		var Fragment = function( options ) {
			this.init( options );
		};
		Fragment.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getNode: getNode,
			getValue: getValue,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		circular.Fragment = Fragment;
		return Fragment;
	}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );

	/* Ractive/prototype/reset.js */
	var Ractive$reset = function( runloop, Fragment, config ) {

		var shouldRerender = [
			'template',
			'partials',
			'components',
			'decorators',
			'events'
		];
		return function Ractive$reset( data, callback ) {
			var promise, wrapper, changes, i, rerender;
			if ( typeof data === 'function' && !callback ) {
				callback = data;
				data = {};
			} else {
				data = data || {};
			}
			if ( typeof data !== 'object' ) {
				throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
			}
			// If the root object is wrapped, try and use the wrapper's reset value
			if ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {
				if ( wrapper.reset( data ) === false ) {
					// reset was rejected, we need to replace the object
					this.data = data;
				}
			} else {
				this.data = data;
			}
			// reset config items and track if need to rerender
			changes = config.reset( this );
			i = changes.length;
			while ( i-- ) {
				if ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {
					rerender = true;
					break;
				}
			}
			if ( rerender ) {
				var component;
				this.viewmodel.mark( '' );
				// Is this is a component, we need to set the `shouldDestroy`
				// flag, otherwise it will assume by default that a parent node
				// will be detached, and therefore it doesn't need to bother
				// detaching its own nodes
				if ( component = this.component ) {
					component.shouldDestroy = true;
				}
				this.unrender();
				if ( component ) {
					component.shouldDestroy = false;
				}
				// If the template changed, we need to destroy the parallel DOM
				// TODO if we're here, presumably it did?
				if ( this.fragment.template !== this.template ) {
					this.fragment.unbind();
					this.fragment = new Fragment( {
						template: this.template,
						root: this,
						owner: this
					} );
				}
				promise = this.render( this.el, this.anchor );
			} else {
				promise = runloop.start( this, true );
				this.viewmodel.mark( '' );
				runloop.end();
			}
			this.fire( 'reset', data );
			if ( callback ) {
				promise.then( callback );
			}
			return promise;
		};
	}( runloop, Fragment, config );

	/* Ractive/prototype/resetTemplate.js */
	var Ractive$resetTemplate = function( config, Fragment ) {

		// TODO should resetTemplate be asynchronous? i.e. should it be a case
		// of outro, update template, intro? I reckon probably not, since that
		// could be achieved with unrender-resetTemplate-render. Also, it should
		// conceptually be similar to resetPartial, which couldn't be async
		return function Ractive$resetTemplate( template ) {
			var transitionsEnabled, component;
			config.template.init( null, this, {
				template: template
			} );
			transitionsEnabled = this.transitionsEnabled;
			this.transitionsEnabled = false;
			// Is this is a component, we need to set the `shouldDestroy`
			// flag, otherwise it will assume by default that a parent node
			// will be detached, and therefore it doesn't need to bother
			// detaching its own nodes
			if ( component = this.component ) {
				component.shouldDestroy = true;
			}
			this.unrender();
			if ( component ) {
				component.shouldDestroy = false;
			}
			// remove existing fragment and create new one
			this.fragment.unbind();
			this.fragment = new Fragment( {
				template: this.template,
				root: this,
				owner: this
			} );
			this.render( this.el, this.anchor );
			this.transitionsEnabled = transitionsEnabled;
		};
	}( config, Fragment );

	/* Ractive/prototype/reverse.js */
	var Ractive$reverse = function( makeArrayMethod ) {

		return makeArrayMethod( 'reverse' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/set.js */
	var Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {

		var wildcard = /\*/;
		return function Ractive$set( keypath, value, callback ) {
			var this$0 = this;
			var map, promise;
			promise = runloop.start( this, true );
			// Set multiple keypaths in one go
			if ( isObject( keypath ) ) {
				map = keypath;
				callback = value;
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						value = map[ keypath ];
						keypath = normaliseKeypath( keypath );
						this.viewmodel.set( keypath, value );
					}
				}
			} else {
				keypath = normaliseKeypath( keypath );
				if ( wildcard.test( keypath ) ) {
					getMatchingKeypaths( this, keypath ).forEach( function( keypath ) {
						this$0.viewmodel.set( keypath, value );
					} );
				} else {
					this.viewmodel.set( keypath, value );
				}
			}
			runloop.end();
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );

	/* Ractive/prototype/shift.js */
	var Ractive$shift = function( makeArrayMethod ) {

		return makeArrayMethod( 'shift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/sort.js */
	var Ractive$sort = function( makeArrayMethod ) {

		return makeArrayMethod( 'sort' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/splice.js */
	var Ractive$splice = function( makeArrayMethod ) {

		return makeArrayMethod( 'splice' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/subtract.js */
	var Ractive$subtract = function( add ) {

		return function Ractive$subtract( keypath, d ) {
			return add( this, keypath, d === undefined ? -1 : -d );
		};
	}( Ractive$shared_add );

	/* Ractive/prototype/teardown.js */
	var Ractive$teardown = function( Promise ) {

		// Teardown. This goes through the root fragment and all its children, removing observers
		// and generally cleaning up after itself
		return function Ractive$teardown( callback ) {
			var promise;
			this.fire( 'teardown' );
			this.fragment.unbind();
			this.viewmodel.teardown();
			promise = this.rendered ? this.unrender() : Promise.resolve();
			if ( callback ) {
				// TODO deprecate this?
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Promise );

	/* Ractive/prototype/toggle.js */
	var Ractive$toggle = function( log ) {

		return function Ractive$toggle( keypath, callback ) {
			var value;
			if ( typeof keypath !== 'string' ) {
				log.errorOnly( {
					debug: this.debug,
					messsage: 'badArguments',
					arg: {
						arguments: keypath
					}
				} );
			}
			value = this.get( keypath );
			return this.set( keypath, !value, callback );
		};
	}( log );

	/* Ractive/prototype/toHTML.js */
	var Ractive$toHTML = function Ractive$toHTML() {
		return this.fragment.toString( true );
	};

	/* Ractive/prototype/unrender.js */
	var Ractive$unrender = function( removeFromArray, runloop, css ) {

		return function Ractive$unrender() {
			var this$0 = this;
			var promise, shouldDestroy;
			if ( !this.rendered ) {
				throw new Error( 'ractive.unrender() was called on a Ractive instance that was not rendered' );
			}
			promise = runloop.start( this, true );
			// If this is a component, and the component isn't marked for destruction,
			// don't detach nodes from the DOM unnecessarily
			shouldDestroy = !this.component || this.component.shouldDestroy;
			shouldDestroy = shouldDestroy || this.shouldDestroy;
			if ( this.constructor.css ) {
				promise.then( function() {
					css.remove( this$0.constructor );
				} );
			}
			// Cancel any animations in progress
			while ( this._animations[ 0 ] ) {
				this._animations[ 0 ].stop();
			}
			this.fragment.unrender( shouldDestroy );
			this.rendered = false;
			removeFromArray( this.el.__ractive_instances__, this );
			runloop.end();
			return promise;
		};
	}( removeFromArray, runloop, global_css );

	/* Ractive/prototype/unshift.js */
	var Ractive$unshift = function( makeArrayMethod ) {

		return makeArrayMethod( 'unshift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/update.js */
	var Ractive$update = function( runloop ) {

		return function Ractive$update( keypath, callback ) {
			var promise;
			if ( typeof keypath === 'function' ) {
				callback = keypath;
				keypath = '';
			} else {
				keypath = keypath || '';
			}
			promise = runloop.start( this, true );
			this.viewmodel.mark( keypath );
			runloop.end();
			this.fire( 'update', keypath );
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop );

	/* Ractive/prototype/updateModel.js */
	var Ractive$updateModel = function( arrayContentsMatch, isEqual ) {

		return function Ractive$updateModel( keypath, cascade ) {
			var values;
			if ( typeof keypath !== 'string' ) {
				keypath = '';
				cascade = true;
			}
			consolidateChangedValues( this, keypath, values = {}, cascade );
			return this.set( values );
		};

		function consolidateChangedValues( ractive, keypath, values, cascade ) {
			var bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];
			bindings = ractive._twowayBindings[ keypath ];
			if ( bindings && ( i = bindings.length ) ) {
				while ( i-- ) {
					binding = bindings[ i ];
					// special case - radio name bindings
					if ( binding.radioName && !binding.element.node.checked ) {
						continue;
					}
					// special case - checkbox name bindings come in groups, so
					// we want to get the value once at most
					if ( binding.checkboxName ) {
						if ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {
							checkboxGroups.push( binding.keypath );
							checkboxGroups[ binding.keypath ] = binding;
						}
						continue;
					}
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( arrayContentsMatch( oldValue, newValue ) ) {
						continue;
					}
					if ( !isEqual( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				}
			}
			// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
			if ( checkboxGroups.length ) {
				checkboxGroups.forEach( function( keypath ) {
					var binding, oldValue, newValue;
					binding = checkboxGroups[ keypath ];
					// one to represent the entire group
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( !arrayContentsMatch( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				} );
			}
			if ( !cascade ) {
				return;
			}
			// cascade
			childDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];
			if ( childDeps ) {
				i = childDeps.length;
				while ( i-- ) {
					consolidateChangedValues( ractive, childDeps[ i ], values, cascade );
				}
			}
		}
	}( arrayContentsMatch, isEqual );

	/* Ractive/prototype.js */
	var prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {

		return {
			add: add,
			animate: animate,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			fire: fire,
			get: get,
			insert: insert,
			merge: merge,
			observe: observe,
			off: off,
			on: on,
			pop: pop,
			push: push,
			render: render,
			reset: reset,
			resetTemplate: resetTemplate,
			reverse: reverse,
			set: set,
			shift: shift,
			sort: sort,
			splice: splice,
			subtract: subtract,
			teardown: teardown,
			toggle: toggle,
			toHTML: toHTML,
			unrender: unrender,
			unshift: unshift,
			update: update,
			updateModel: updateModel
		};
	}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );

	/* utils/getGuid.js */
	var getGuid = function() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
			var r, v;
			r = Math.random() * 16 | 0;
			v = c == 'x' ? r : r & 3 | 8;
			return v.toString( 16 );
		} );
	};

	/* utils/getNextNumber.js */
	var getNextNumber = function() {

		var i = 0;
		return function() {
			return 'r-' + i++;
		};
	}();

	/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */
	var viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, spliceSummary ) {
		var root = wrapper.root,
			keypath = wrapper.keypath;
		// If this is a sort or reverse, we just do root.set()...
		// TODO use merge logic?
		if ( methodName === 'sort' || methodName === 'reverse' ) {
			root.viewmodel.set( keypath, array );
			return;
		}
		if ( !spliceSummary ) {
			// (presumably we tried to pop from an array of zero length.
			// in which case there's nothing to do)
			return;
		}
		root.viewmodel.splice( keypath, spliceSummary );
	};

	/* viewmodel/prototype/get/arrayAdaptor/patch.js */
	var viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getSpliceEquivalent, summariseSpliceOperation, processWrapper ) {

		var patchedArrayProto = [],
			mutatorMethods = [
				'pop',
				'push',
				'reverse',
				'shift',
				'sort',
				'splice',
				'unshift'
			],
			testObj, patchArrayMethods, unpatchArrayMethods;
		mutatorMethods.forEach( function( methodName ) {
			var method = function() {
				var spliceEquivalent, spliceSummary, result, wrapper, i;
				// push, pop, shift and unshift can all be represented as a splice operation.
				// this makes life easier later
				spliceEquivalent = getSpliceEquivalent( this, methodName, Array.prototype.slice.call( arguments ) );
				spliceSummary = summariseSpliceOperation( this, spliceEquivalent );
				// apply the underlying method
				result = Array.prototype[ methodName ].apply( this, arguments );
				// trigger changes
				this._ractive.setting = true;
				i = this._ractive.wrappers.length;
				while ( i-- ) {
					wrapper = this._ractive.wrappers[ i ];
					runloop.start( wrapper.root );
					processWrapper( wrapper, this, methodName, spliceSummary );
					runloop.end();
				}
				this._ractive.setting = false;
				return result;
			};
			defineProperty( patchedArrayProto, methodName, {
				value: method
			} );
		} );
		// can we use prototype chain injection?
		// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
		testObj = {};
		if ( testObj.__proto__ ) {
			// yes, we can
			patchArrayMethods = function( array ) {
				array.__proto__ = patchedArrayProto;
			};
			unpatchArrayMethods = function( array ) {
				array.__proto__ = Array.prototype;
			};
		} else {
			// no, we can't
			patchArrayMethods = function( array ) {
				var i, methodName;
				i = mutatorMethods.length;
				while ( i-- ) {
					methodName = mutatorMethods[ i ];
					defineProperty( array, methodName, {
						value: patchedArrayProto[ methodName ],
						configurable: true
					} );
				}
			};
			unpatchArrayMethods = function( array ) {
				var i;
				i = mutatorMethods.length;
				while ( i-- ) {
					delete array[ mutatorMethods[ i ] ];
				}
			};
		}
		patchArrayMethods.unpatch = unpatchArrayMethods;
		return patchArrayMethods;
	}( runloop, defineProperty, getSpliceEquivalent, summariseSpliceOperation, viewmodel$get_arrayAdaptor_processWrapper );

	/* viewmodel/prototype/get/arrayAdaptor.js */
	var viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {

		var arrayAdaptor,
			// helpers
			ArrayWrapper, errorMessage;
		arrayAdaptor = {
			filter: function( object ) {
				// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
				// or the array didn't trigger the get() itself
				return isArray( object ) && ( !object._ractive || !object._ractive.setting );
			},
			wrap: function( ractive, array, keypath ) {
				return new ArrayWrapper( ractive, array, keypath );
			}
		};
		ArrayWrapper = function( ractive, array, keypath ) {
			this.root = ractive;
			this.value = array;
			this.keypath = keypath;
			// if this array hasn't already been ractified, ractify it
			if ( !array._ractive ) {
				// define a non-enumerable _ractive property to store the wrappers
				defineProperty( array, '_ractive', {
					value: {
						wrappers: [],
						instances: [],
						setting: false
					},
					configurable: true
				} );
				patch( array );
			}
			// store the ractive instance, so we can handle transitions later
			if ( !array._ractive.instances[ ractive._guid ] ) {
				array._ractive.instances[ ractive._guid ] = 0;
				array._ractive.instances.push( ractive );
			}
			array._ractive.instances[ ractive._guid ] += 1;
			array._ractive.wrappers.push( this );
		};
		ArrayWrapper.prototype = {
			get: function() {
				return this.value;
			},
			teardown: function() {
				var array, storage, wrappers, instances, index;
				array = this.value;
				storage = array._ractive;
				wrappers = storage.wrappers;
				instances = storage.instances;
				// if teardown() was invoked because we're clearing the cache as a result of
				// a change that the array itself triggered, we can save ourselves the teardown
				// and immediate setup
				if ( storage.setting ) {
					return false;
				}
				index = wrappers.indexOf( this );
				if ( index === -1 ) {
					throw new Error( errorMessage );
				}
				wrappers.splice( index, 1 );
				// if nothing else depends on this array, we can revert it to its
				// natural state
				if ( !wrappers.length ) {
					delete array._ractive;
					patch.unpatch( this.value );
				} else {
					// remove ractive instance if possible
					instances[ this.root._guid ] -= 1;
					if ( !instances[ this.root._guid ] ) {
						index = instances.indexOf( this.root );
						if ( index === -1 ) {
							throw new Error( errorMessage );
						}
						instances.splice( index, 1 );
					}
				}
			}
		};
		errorMessage = 'Something went wrong in a rather interesting way';
		return arrayAdaptor;
	}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );

	/* viewmodel/prototype/get/magicArrayAdaptor.js */
	var viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {

		var magicArrayAdaptor, MagicArrayWrapper;
		if ( magicAdaptor ) {
			magicArrayAdaptor = {
				filter: function( object, keypath, ractive ) {
					return magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
				},
				wrap: function( ractive, array, keypath ) {
					return new MagicArrayWrapper( ractive, array, keypath );
				}
			};
			MagicArrayWrapper = function( ractive, array, keypath ) {
				this.value = array;
				this.magic = true;
				this.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );
				this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
			};
			MagicArrayWrapper.prototype = {
				get: function() {
					return this.value;
				},
				teardown: function() {
					this.arrayWrapper.teardown();
					this.magicWrapper.teardown();
				},
				reset: function( value ) {
					return this.magicWrapper.reset( value );
				}
			};
		}
		return magicArrayAdaptor;
	}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );

	/* viewmodel/prototype/adapt.js */
	var viewmodel$adapt = function( config, arrayAdaptor, magicAdaptor, magicArrayAdaptor ) {

		var prefixers = {};
		return function Viewmodel$adapt( keypath, value ) {
			var ractive = this.ractive,
				len, i, adaptor, wrapped;
			// Do we have an adaptor for this value?
			len = ractive.adapt.length;
			for ( i = 0; i < len; i += 1 ) {
				adaptor = ractive.adapt[ i ];
				// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -
				// we need to get the actual adaptor if that's the case
				if ( typeof adaptor === 'string' ) {
					var found = config.registries.adaptors.find( ractive, adaptor );
					if ( !found ) {
						throw new Error( 'Missing adaptor "' + adaptor + '"' );
					}
					adaptor = ractive.adapt[ i ] = found;
				}
				if ( adaptor.filter( value, keypath, ractive ) ) {
					wrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
					wrapped.value = value;
					return value;
				}
			}
			if ( ractive.magic ) {
				if ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );
				} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );
				}
			} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {
				this.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );
			}
			return value;
		};

		function prefixKeypath( obj, prefix ) {
			var prefixed = {},
				key;
			if ( !prefix ) {
				return obj;
			}
			prefix += '.';
			for ( key in obj ) {
				if ( obj.hasOwnProperty( key ) ) {
					prefixed[ prefix + key ] = obj[ key ];
				}
			}
			return prefixed;
		}

		function getPrefixer( rootKeypath ) {
			var rootDot;
			if ( !prefixers[ rootKeypath ] ) {
				rootDot = rootKeypath ? rootKeypath + '.' : '';
				prefixers[ rootKeypath ] = function( relativeKeypath, value ) {
					var obj;
					if ( typeof relativeKeypath === 'string' ) {
						obj = {};
						obj[ rootDot + relativeKeypath ] = value;
						return obj;
					}
					if ( typeof relativeKeypath === 'object' ) {
						// 'relativeKeypath' is in fact a hash, not a keypath
						return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
					}
				};
			}
			return prefixers[ rootKeypath ];
		}
	}( config, viewmodel$get_arrayAdaptor, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );

	/* viewmodel/helpers/getUpstreamChanges.js */
	var getUpstreamChanges = function getUpstreamChanges( changes ) {
		var upstreamChanges = [ '' ],
			i, keypath, keys, upstreamKeypath;
		i = changes.length;
		while ( i-- ) {
			keypath = changes[ i ];
			keys = keypath.split( '.' );
			while ( keys.length > 1 ) {
				keys.pop();
				upstreamKeypath = keys.join( '.' );
				if ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {
					upstreamChanges.push( upstreamKeypath );
				}
			}
		}
		return upstreamChanges;
	};

	/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */
	var viewmodel$applyChanges_getPotentialWildcardMatches = function() {

		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		return function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, result;
			keys = keypath.split( '.' );
			starMap = getStarMap( keys.length );
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			result = starMap.map( function( mask ) {
				return mask.map( mapper ).join( '.' );
			} );
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( length ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ length ] ) {
				starMap = [];
				while ( ones.length < length ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < length ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ length ] = starMap;
			}
			return starMaps[ length ];
		}
	}();

	/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */
	var viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {

		var lastKey = /[^\.]+$/;
		return notifyPatternObservers;

		function notifyPatternObservers( viewmodel, keypath, onlyDirect ) {
			var potentialWildcardMatches;
			updateMatchingPatternObservers( viewmodel, keypath );
			if ( onlyDirect ) {
				return;
			}
			potentialWildcardMatches = getPotentialWildcardMatches( keypath );
			potentialWildcardMatches.forEach( function( upstreamPattern ) {
				cascade( viewmodel, upstreamPattern, keypath );
			} );
		}

		function cascade( viewmodel, upstreamPattern, keypath ) {
			var group, map, actualChildKeypath;
			group = viewmodel.depsMap.patternObservers;
			map = group[ upstreamPattern ];
			if ( map ) {
				map.forEach( function( childKeypath ) {
					var key = lastKey.exec( childKeypath )[ 0 ];
					// 'baz'
					actualChildKeypath = keypath ? keypath + '.' + key : key;
					// 'foo.bar.baz'
					updateMatchingPatternObservers( viewmodel, actualChildKeypath );
					cascade( viewmodel, childKeypath, actualChildKeypath );
				} );
			}
		}

		function updateMatchingPatternObservers( viewmodel, keypath ) {
			viewmodel.patternObservers.forEach( function( observer ) {
				if ( observer.regex.test( keypath ) ) {
					observer.update( keypath );
				}
			} );
		}
	}( viewmodel$applyChanges_getPotentialWildcardMatches );

	/* viewmodel/prototype/applyChanges.js */
	var viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {

		var dependantGroups = [
			'observers',
			'default'
		];
		return function Viewmodel$applyChanges() {
			var this$0 = this;
			var self = this,
				changes, upstreamChanges, allChanges = [],
				computations, addComputations, cascade, hash = {};
			if ( !this.changes.length ) {
				// TODO we end up here on initial render. Perhaps we shouldn't?
				return;
			}
			addComputations = function( keypath ) {
				var newComputations;
				if ( newComputations = self.deps.computed[ keypath ] ) {
					addNewItems( computations, newComputations );
				}
			};
			cascade = function( keypath ) {
				var map;
				addComputations( keypath );
				if ( map = self.depsMap.computed[ keypath ] ) {
					map.forEach( cascade );
				}
			};
			// Find computations and evaluators that are invalidated by
			// these changes. If they have changed, add them to the
			// list of changes. Lather, rinse and repeat until the
			// system is settled
			do {
				changes = this.changes;
				addNewItems( allChanges, changes );
				this.changes = [];
				computations = [];
				upstreamChanges = getUpstreamChanges( changes );
				upstreamChanges.forEach( addComputations );
				changes.forEach( cascade );
				computations.forEach( updateComputation );
			} while ( this.changes.length );
			upstreamChanges = getUpstreamChanges( allChanges );
			// Pattern observers are a weird special case
			if ( this.patternObservers.length ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath, true );
				} );
				allChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath );
				} );
			}
			dependantGroups.forEach( function( group ) {
				if ( !this$0.deps[ group ] ) {
					return;
				}
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, keypath, group );
				} );
				notifyAllDependants( this$0, allChanges, group );
			} );
			// Return a hash of keypaths to updated values
			allChanges.forEach( function( keypath ) {
				hash[ keypath ] = this$0.get( keypath );
			} );
			this.implicitChanges = {};
			return hash;
		};

		function updateComputation( computation ) {
			computation.update();
		}

		function notifyUpstreamDependants( viewmodel, keypath, groupName ) {
			var dependants, value;
			if ( dependants = findDependants( viewmodel, keypath, groupName ) ) {
				value = viewmodel.get( keypath );
				dependants.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function notifyAllDependants( viewmodel, keypaths, groupName ) {
			var queue = [];
			addKeypaths( keypaths );
			queue.forEach( dispatch );

			function addKeypaths( keypaths ) {
				keypaths.forEach( addKeypath );
				keypaths.forEach( cascade );
			}

			function addKeypath( keypath ) {
				var deps = findDependants( viewmodel, keypath, groupName );
				if ( deps ) {
					queue.push( {
						keypath: keypath,
						deps: deps
					} );
				}
			}

			function cascade( keypath ) {
				var childDeps;
				if ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {
					addKeypaths( childDeps );
				}
			}

			function dispatch( set ) {
				var value = viewmodel.get( set.keypath );
				set.deps.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function findDependants( viewmodel, keypath, groupName ) {
			var group = viewmodel.deps[ groupName ];
			return group ? group[ keypath ] : null;
		}

		function addNewItems( arr, items ) {
			items.forEach( function( item ) {
				if ( arr.indexOf( item ) === -1 ) {
					arr.push( item );
				}
			} );
		}
	}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );

	/* viewmodel/prototype/capture.js */
	var viewmodel$capture = function Viewmodel$capture() {
		this.capturing = true;
		this.captured = [];
	};

	/* viewmodel/prototype/clearCache.js */
	var viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {
		var cacheMap, wrapper, computation;
		if ( !dontTeardownWrapper ) {
			// Is there a wrapped property at this keypath?
			if ( wrapper = this.wrapped[ keypath ] ) {
				// Did we unwrap it?
				if ( wrapper.teardown() !== false ) {
					this.wrapped[ keypath ] = null;
				}
			}
		}
		if ( computation = this.computations[ keypath ] ) {
			computation.compute();
		}
		this.cache[ keypath ] = undefined;
		if ( cacheMap = this.cacheMap[ keypath ] ) {
			while ( cacheMap.length ) {
				this.clearCache( cacheMap.pop() );
			}
		}
	};

	/* viewmodel/prototype/get/FAILED_LOOKUP.js */
	var viewmodel$get_FAILED_LOOKUP = {
		FAILED_LOOKUP: true
	};

	/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */
	var viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {

		var empty = {};
		var UnresolvedImplicitDependency = function( viewmodel, keypath ) {
			this.viewmodel = viewmodel;
			this.root = viewmodel.ractive;
			// TODO eliminate this
			this.ref = keypath;
			this.parentFragment = empty;
			viewmodel.unresolvedImplicitDependencies[ keypath ] = true;
			viewmodel.unresolvedImplicitDependencies.push( this );
			runloop.addUnresolved( this );
		};
		UnresolvedImplicitDependency.prototype = {
			resolve: function() {
				this.viewmodel.mark( this.ref );
				this.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;
				removeFromArray( this.viewmodel.unresolvedImplicitDependencies, this );
			},
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return UnresolvedImplicitDependency;
	}( removeFromArray, runloop );

	/* viewmodel/prototype/get.js */
	var viewmodel$get = function( FAILED_LOOKUP, UnresolvedImplicitDependency ) {

		var empty = {};
		return function Viewmodel$get( keypath ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = empty;
			var ractive = this.ractive,
				cache = this.cache,
				value, computation, wrapped, evaluator;
			if ( cache[ keypath ] === undefined ) {
				// Is this a computed property?
				if ( computation = this.computations[ keypath ] ) {
					value = computation.value;
				} else if ( wrapped = this.wrapped[ keypath ] ) {
					value = wrapped.value;
				} else if ( !keypath ) {
					this.adapt( '', ractive.data );
					value = ractive.data;
				} else if ( evaluator = this.evaluators[ keypath ] ) {
					value = evaluator.value;
				} else {
					value = retrieve( this, keypath );
				}
				cache[ keypath ] = value;
			} else {
				value = cache[ keypath ];
			}
			if ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {
				value = wrapped.get();
			}
			// capture the keypath, if we're inside a computation or evaluator
			if ( options.capture && this.capturing && this.captured.indexOf( keypath ) === -1 ) {
				this.captured.push( keypath );
				// if we couldn't resolve the keypath, we need to make it as a failed
				// lookup, so that the evaluator updates correctly once we CAN
				// resolve the keypath
				if ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {
					new UnresolvedImplicitDependency( this, keypath );
				}
			}
			return value === FAILED_LOOKUP ? void 0 : value;
		};

		function retrieve( viewmodel, keypath ) {
			var keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;
			keys = keypath.split( '.' );
			key = keys.pop();
			parentKeypath = keys.join( '.' );
			parentValue = viewmodel.get( parentKeypath );
			if ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {
				parentValue = wrapped.get();
			}
			if ( parentValue === null || parentValue === undefined ) {
				return;
			}
			// update cache map
			if ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {
				viewmodel.cacheMap[ parentKeypath ] = [ keypath ];
			} else {
				if ( cacheMap.indexOf( keypath ) === -1 ) {
					cacheMap.push( keypath );
				}
			}
			// If this property doesn't exist, we return a sentinel value
			// so that we know to query parent scope (if such there be)
			if ( typeof parentValue === 'object' && !( key in parentValue ) ) {
				return viewmodel.cache[ keypath ] = FAILED_LOOKUP;
			}
			value = parentValue[ key ];
			// Do we have an adaptor for this value?
			viewmodel.adapt( keypath, value, false );
			// Update cache
			viewmodel.cache[ keypath ] = value;
			return value;
		}
	}( viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );

	/* viewmodel/prototype/mark.js */
	var viewmodel$mark = function Viewmodel$mark( keypath, isImplicitChange ) {
		// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
		// should not be picked up by pattern observers
		if ( isImplicitChange ) {
			this.implicitChanges[ keypath ] = true;
		}
		if ( this.changes.indexOf( keypath ) === -1 ) {
			this.changes.push( keypath );
			this.clearCache( keypath );
		}
	};

	/* viewmodel/prototype/merge/mapOldToNewIndex.js */
	var viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {
		var usedIndices, firstUnusedIndex, newIndices, changed;
		usedIndices = {};
		firstUnusedIndex = 0;
		newIndices = oldArray.map( function( item, i ) {
			var index, start, len;
			start = firstUnusedIndex;
			len = newArray.length;
			do {
				index = newArray.indexOf( item, start );
				if ( index === -1 ) {
					changed = true;
					return -1;
				}
				start = index + 1;
			} while ( usedIndices[ index ] && start < len );
			// keep track of the first unused index, so we don't search
			// the whole of newArray for each item in oldArray unnecessarily
			if ( index === firstUnusedIndex ) {
				firstUnusedIndex += 1;
			}
			if ( index !== i ) {
				changed = true;
			}
			usedIndices[ index ] = true;
			return index;
		} );
		newIndices.unchanged = !changed;
		return newIndices;
	};

	/* viewmodel/prototype/merge.js */
	var viewmodel$merge = function( types, warn, mapOldToNewIndex ) {

		var comparators = {};
		return function Viewmodel$merge( keypath, currentArray, array, options ) {
			var this$0 = this;
			var oldArray, newArray, comparator, newIndices, dependants;
			this.mark( keypath );
			if ( options && options.compare ) {
				comparator = getComparatorFunction( options.compare );
				try {
					oldArray = currentArray.map( comparator );
					newArray = array.map( comparator );
				} catch ( err ) {
					// fallback to an identity check - worst case scenario we have
					// to do more DOM manipulation than we thought...
					// ...unless we're in debug mode of course
					if ( this.debug ) {
						throw err;
					} else {
						warn( 'Merge operation: comparison failed. Falling back to identity checking' );
					}
					oldArray = currentArray;
					newArray = array;
				}
			} else {
				oldArray = currentArray;
				newArray = array;
			}
			// find new indices for members of oldArray
			newIndices = mapOldToNewIndex( oldArray, newArray );
			// Indices that are being removed should be marked as dirty
			newIndices.forEach( function( newIndex, oldIndex ) {
				if ( newIndex === -1 ) {
					this$0.mark( keypath + '.' + oldIndex );
				}
			} );
			// Update the model
			// TODO allow existing array to be updated in place, rather than replaced?
			this.set( keypath, array, true );
			if ( dependants = this.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canMerge ).forEach( function( dependant ) {
					return dependant.merge( newIndices );
				} );
			}
			if ( currentArray.length !== array.length ) {
				this.mark( keypath + '.length', true );
			}
		};

		function canMerge( dependant ) {
			return typeof dependant.merge === 'function' && ( !dependant.subtype || dependant.subtype === types.SECTION_EACH );
		}

		function stringify( item ) {
			return JSON.stringify( item );
		}

		function getComparatorFunction( comparator ) {
			// If `compare` is `true`, we use JSON.stringify to compare
			// objects that are the same shape, but non-identical - i.e.
			// { foo: 'bar' } !== { foo: 'bar' }
			if ( comparator === true ) {
				return stringify;
			}
			if ( typeof comparator === 'string' ) {
				if ( !comparators[ comparator ] ) {
					comparators[ comparator ] = function( item ) {
						return item[ comparator ];
					};
				}
				return comparators[ comparator ];
			}
			if ( typeof comparator === 'function' ) {
				return comparator;
			}
			throw new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );
		}
	}( types, warn, viewmodel$merge_mapOldToNewIndex );

	/* viewmodel/prototype/register.js */
	var viewmodel$register = function() {

		return function Viewmodel$register( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var depsByKeypath, deps, evaluator;
			if ( dependant.isStatic ) {
				return;
			}
			depsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );
			deps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );
			deps.push( dependant );
			if ( !keypath ) {
				return;
			}
			if ( evaluator = this.evaluators[ keypath ] ) {
				if ( !evaluator.dependants ) {
					evaluator.wake();
				}
				evaluator.dependants += 1;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );
				parent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );
				if ( parent[ keypath ] === undefined ) {
					parent[ keypath ] = 0;
					parent.push( keypath );
				}
				parent[ keypath ] += 1;
				keypath = parentKeypath;
			}
		}
	}();

	/* viewmodel/prototype/release.js */
	var viewmodel$release = function Viewmodel$release() {
		this.capturing = false;
		return this.captured;
	};

	/* viewmodel/prototype/set.js */
	var viewmodel$set = function( isEqual, createBranch ) {

		return function Viewmodel$set( keypath, value, silent ) {
			var keys, lastKey, parentKeypath, parentValue, computation, wrapper, evaluator, dontTeardownWrapper;
			if ( isEqual( this.cache[ keypath ], value ) ) {
				return;
			}
			computation = this.computations[ keypath ];
			wrapper = this.wrapped[ keypath ];
			evaluator = this.evaluators[ keypath ];
			if ( computation && !computation.setting ) {
				computation.set( value );
			}
			// If we have a wrapper with a `reset()` method, we try and use it. If the
			// `reset()` method returns false, the wrapper should be torn down, and
			// (most likely) a new one should be created later
			if ( wrapper && wrapper.reset ) {
				dontTeardownWrapper = wrapper.reset( value ) !== false;
				if ( dontTeardownWrapper ) {
					value = wrapper.get();
				}
			}
			// Update evaluator value. This may be from the evaluator itself, or
			// it may be from the wrapper that wraps an evaluator's result - it
			// doesn't matter
			if ( evaluator ) {
				evaluator.value = value;
			}
			if ( !computation && !evaluator && !dontTeardownWrapper ) {
				keys = keypath.split( '.' );
				lastKey = keys.pop();
				parentKeypath = keys.join( '.' );
				wrapper = this.wrapped[ parentKeypath ];
				if ( wrapper && wrapper.set ) {
					wrapper.set( lastKey, value );
				} else {
					parentValue = wrapper ? wrapper.get() : this.get( parentKeypath );
					if ( !parentValue ) {
						parentValue = createBranch( lastKey );
						this.set( parentKeypath, parentValue, true );
					}
					parentValue[ lastKey ] = value;
				}
			}
			if ( !silent ) {
				this.mark( keypath );
			} else {
				// We're setting a parent of the original target keypath (i.e.
				// creating a fresh branch) - we need to clear the cache, but
				// not mark it as a change
				this.clearCache( keypath );
			}
		};
	}( isEqual, createBranch );

	/* viewmodel/prototype/splice.js */
	var viewmodel$splice = function( types ) {

		return function Viewmodel$splice( keypath, spliceSummary ) {
			var viewmodel = this,
				i, dependants;
			// Mark changed keypaths
			for ( i = spliceSummary.rangeStart; i < spliceSummary.rangeEnd; i += 1 ) {
				viewmodel.mark( keypath + '.' + i );
			}
			if ( spliceSummary.balance ) {
				viewmodel.mark( keypath + '.length', true );
			}
			// Trigger splice operations
			if ( dependants = viewmodel.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canSplice ).forEach( function( dependant ) {
					return dependant.splice( spliceSummary );
				} );
			}
		};

		function canSplice( dependant ) {
			return dependant.type === types.SECTION && ( !dependant.subtype || dependant.subtype === types.SECTION_EACH ) && dependant.rendered;
		}
	}( types );

	/* viewmodel/prototype/teardown.js */
	var viewmodel$teardown = function Viewmodel$teardown() {
		var this$0 = this;
		var unresolvedImplicitDependency;
		// Clear entire cache - this has the desired side-effect
		// of unwrapping adapted values (e.g. arrays)
		Object.keys( this.cache ).forEach( function( keypath ) {
			return this$0.clearCache( keypath );
		} );
		// Teardown any failed lookups - we don't need them to resolve any more
		while ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {
			unresolvedImplicitDependency.teardown();
		}
	};

	/* viewmodel/prototype/unregister.js */
	var viewmodel$unregister = function() {

		return function Viewmodel$unregister( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var deps, index, evaluator;
			if ( dependant.isStatic ) {
				return;
			}
			deps = this.deps[ group ][ keypath ];
			index = deps.indexOf( dependant );
			if ( index === -1 ) {
				throw new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );
			}
			deps.splice( index, 1 );
			if ( !keypath ) {
				return;
			}
			if ( evaluator = this.evaluators[ keypath ] ) {
				evaluator.dependants -= 1;
				if ( !evaluator.dependants ) {
					evaluator.sleep();
				}
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ];
				parent = map[ parentKeypath ];
				parent[ keypath ] -= 1;
				if ( !parent[ keypath ] ) {
					// remove from parent deps map
					parent.splice( parent.indexOf( keypath ), 1 );
					parent[ keypath ] = undefined;
				}
				keypath = parentKeypath;
			}
		}
	}();

	/* viewmodel/Computation/getComputationSignature.js */
	var getComputationSignature = function() {

		var pattern = /\$\{([^\}]+)\}/g;
		return function( signature ) {
			if ( typeof signature === 'function' ) {
				return {
					get: signature
				};
			}
			if ( typeof signature === 'string' ) {
				return {
					get: createFunctionFromString( signature )
				};
			}
			if ( typeof signature === 'object' && typeof signature.get === 'string' ) {
				signature = {
					get: createFunctionFromString( signature.get ),
					set: signature.set
				};
			}
			return signature;
		};

		function createFunctionFromString( signature ) {
			var functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {
				return '__ractive.get("' + keypath + '")';
			} ) + ')';
			return new Function( functionBody );
		}
	}();

	/* viewmodel/Computation/Computation.js */
	var Computation = function( log, isEqual, diff ) {

		var Computation = function( ractive, key, signature ) {
			this.ractive = ractive;
			this.viewmodel = ractive.viewmodel;
			this.key = key;
			this.getter = signature.get;
			this.setter = signature.set;
			this.dependencies = [];
			this.update();
		};
		Computation.prototype = {
			set: function( value ) {
				if ( this.setting ) {
					this.value = value;
					return;
				}
				if ( !this.setter ) {
					throw new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );
				}
				this.setter.call( this.ractive, value );
			},
			// returns `false` if the computation errors
			compute: function() {
				var ractive, errored, newDependencies;
				ractive = this.ractive;
				ractive.viewmodel.capture();
				try {
					this.value = this.getter.call( ractive );
				} catch ( err ) {
					log.warn( {
						debug: ractive.debug,
						message: 'failedComputation',
						args: {
							key: this.key,
							err: err.message || err
						}
					} );
					errored = true;
				}
				newDependencies = ractive.viewmodel.release();
				diff( this, this.dependencies, newDependencies );
				return errored ? false : true;
			},
			update: function() {
				var oldValue = this.value;
				if ( this.compute() && !isEqual( this.value, oldValue ) ) {
					this.ractive.viewmodel.mark( this.key );
				}
			}
		};
		return Computation;
	}( log, isEqual, diff );

	/* viewmodel/Computation/createComputations.js */
	var createComputations = function( getComputationSignature, Computation ) {

		return function createComputations( ractive, computed ) {
			var key, signature;
			for ( key in computed ) {
				signature = getComputationSignature( computed[ key ] );
				ractive.viewmodel.computations[ key ] = new Computation( ractive, key, signature );
			}
		};
	}( getComputationSignature, Computation );

	/* viewmodel/adaptConfig.js */
	var adaptConfig = function() {

		// should this be combined with prototype/adapt.js?
		var configure = {
			lookup: function( target, adaptors ) {
				var i, adapt = target.adapt;
				if ( !adapt || !adapt.length ) {
					return adapt;
				}
				if ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {
					while ( i-- ) {
						var adaptor = adapt[ i ];
						if ( typeof adaptor === 'string' ) {
							adapt[ i ] = adaptors[ adaptor ] || adaptor;
						}
					}
				}
				return adapt;
			},
			combine: function( parent, adapt ) {
				// normalize 'Foo' to [ 'Foo' ]
				parent = arrayIfString( parent );
				adapt = arrayIfString( adapt );
				// no parent? return adapt
				if ( !parent || !parent.length ) {
					return adapt;
				}
				// no adapt? return 'copy' of parent
				if ( !adapt || !adapt.length ) {
					return parent.slice();
				}
				// add parent adaptors to options
				parent.forEach( function( a ) {
					// don't put in duplicates
					if ( adapt.indexOf( a ) === -1 ) {
						adapt.push( a );
					}
				} );
				return adapt;
			}
		};

		function arrayIfString( adapt ) {
			if ( typeof adapt === 'string' ) {
				adapt = [ adapt ];
			}
			return adapt;
		}
		return configure;
	}();

	/* viewmodel/Viewmodel.js */
	var Viewmodel = function( create, adapt, applyChanges, capture, clearCache, get, mark, merge, register, release, set, splice, teardown, unregister, createComputations, adaptConfig ) {

		// TODO: fix our ES6 modules so we can have multiple exports
		// then this magic check can be reused by magicAdaptor
		var noMagic;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
		} catch ( err ) {
			noMagic = true;
		}
		var Viewmodel = function( ractive ) {
			this.ractive = ractive;
			// TODO eventually, we shouldn't need this reference
			Viewmodel.extend( ractive.constructor, ractive );
			//this.ractive.data
			this.cache = {};
			// we need to be able to use hasOwnProperty, so can't inherit from null
			this.cacheMap = create( null );
			this.deps = {
				computed: {},
				'default': {}
			};
			this.depsMap = {
				computed: {},
				'default': {}
			};
			this.patternObservers = [];
			this.wrapped = create( null );
			// TODO these are conceptually very similar. Can they be merged somehow?
			this.evaluators = create( null );
			this.computations = create( null );
			this.captured = null;
			this.unresolvedImplicitDependencies = [];
			this.changes = [];
			this.implicitChanges = {};
		};
		Viewmodel.extend = function( Parent, instance ) {
			if ( instance.magic && noMagic ) {
				throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
			}
			instance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];
			instance.adapt = adaptConfig.lookup( instance, instance.adaptors );
		};
		Viewmodel.prototype = {
			adapt: adapt,
			applyChanges: applyChanges,
			capture: capture,
			clearCache: clearCache,
			get: get,
			mark: mark,
			merge: merge,
			register: register,
			release: release,
			set: set,
			splice: splice,
			teardown: teardown,
			unregister: unregister,
			// createComputations, in the computations, may call back through get or set
			// of ractive. So, for now, we delay creation of computed from constructor.
			// on option would be to have the Computed class be lazy about using .update()
			compute: function() {
				createComputations( this.ractive, this.ractive.computed );
			}
		};
		return Viewmodel;
	}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$get, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$splice, viewmodel$teardown, viewmodel$unregister, createComputations, adaptConfig );

	/* Ractive/initialise.js */
	var Ractive_initialise = function( config, create, getElement, getNextNumber, Viewmodel, Fragment ) {

		return function initialiseRactiveInstance( ractive ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			initialiseProperties( ractive, options );
			// init config from Parent and options
			config.init( ractive.constructor, ractive, options );
			// TEMPORARY. This is so we can implement Viewmodel gradually
			ractive.viewmodel = new Viewmodel( ractive );
			// hacky circular problem until we get this sorted out
			// if viewmodel immediately processes computed properties,
			// they may call ractive.get, which calls ractive.viewmodel,
			// which hasn't been set till line above finishes.
			ractive.viewmodel.compute();
			// Render our *root fragment*
			if ( ractive.template ) {
				ractive.fragment = new Fragment( {
					template: ractive.template,
					root: ractive,
					owner: ractive
				} );
			}
			ractive.viewmodel.applyChanges();
			// render automatically ( if `el` is specified )
			tryRender( ractive );
		};

		function tryRender( ractive ) {
			var el;
			if ( el = getElement( ractive.el ) ) {
				var wasEnabled = ractive.transitionsEnabled;
				// Temporarily disable transitions, if `noIntro` flag is set
				if ( ractive.noIntro ) {
					ractive.transitionsEnabled = false;
				}
				// If the target contains content, and `append` is falsy, clear it
				if ( el && !ractive.append ) {
					// Tear down any existing instances on this element
					if ( el.__ractive_instances__ ) {
						try {
							el.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {
								return r.teardown();
							} );
						} catch ( err ) {}
					}
					el.innerHTML = '';
				}
				ractive.render( el, ractive.append );
				// reset transitionsEnabled
				ractive.transitionsEnabled = wasEnabled;
			}
		}

		function initialiseProperties( ractive, options ) {
			// Generate a unique identifier, for places where you'd use a weak map if it
			// existed
			ractive._guid = getNextNumber();
			// events
			ractive._subs = create( null );
			// storage for item configuration from instantiation to reset,
			// like dynamic functions or original values
			ractive._config = {};
			// two-way bindings
			ractive._twowayBindings = create( null );
			// animations (so we can stop any in progress at teardown)
			ractive._animations = [];
			// nodes registry
			ractive.nodes = {};
			// live queries
			ractive._liveQueries = [];
			ractive._liveComponentQueries = [];
			// If this is a component, store a reference to the parent
			if ( options._parent && options._component ) {
				ractive._parent = options._parent;
				ractive.component = options._component;
				// And store a reference to the instance on the component
				options._component.instance = ractive;
			}
		}
	}( config, create, getElement, getNextNumber, Viewmodel, Fragment );

	/* extend/initChildInstance.js */
	var initChildInstance = function( initialise ) {

		// The Child constructor contains the default init options for this class
		return function initChildInstance( child, Child, options ) {
			if ( child.beforeInit ) {
				child.beforeInit( options );
			}
			initialise( child, options );
		};
	}( Ractive_initialise );

	/* extend/childOptions.js */
	var childOptions = function( wrapPrototype, wrap, config, circular ) {

		var Ractive,
			// would be nice to not have these here,
			// they get added during initialise, so for now we have
			// to make sure not to try and extend them.
			// Possibly, we could re-order and not add till later
			// in process.
			blacklisted = {
				'_parent': true,
				'_component': true
			},
			childOptions = {
				toPrototype: toPrototype,
				toOptions: toOptions
			},
			registries = config.registries;
		config.keys.forEach( function( key ) {
			return blacklisted[ key ] = true;
		} );
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		return childOptions;

		function toPrototype( parent, proto, options ) {
			for ( var key in options ) {
				if ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {
					var member = options[ key ];
					// if this is a method that overwrites a method, wrap it:
					if ( typeof member === 'function' ) {
						member = wrapPrototype( parent, key, member );
					}
					proto[ key ] = member;
				}
			}
		}

		function toOptions( Child ) {
			if ( !( Child.prototype instanceof Ractive ) ) {
				return Child;
			}
			var options = {};
			while ( Child ) {
				registries.forEach( function( r ) {
					addRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );
				} );
				Object.keys( Child.prototype ).forEach( function( key ) {
					if ( key === 'computed' ) {
						return;
					}
					var value = Child.prototype[ key ];
					if ( !( key in options ) ) {
						options[ key ] = value._method ? value._method : value;
					} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {
						var result, needsSuper = value._method;
						if ( needsSuper ) {
							value = value._method;
						}
						// rewrap bound directly to parent fn
						result = wrap( options[ key ]._method, value );
						if ( needsSuper ) {
							result._method = result;
						}
						options[ key ] = result;
					}
				} );
				if ( Child._parent !== Ractive ) {
					Child = Child._parent;
				} else {
					Child = false;
				}
			}
			return options;
		}

		function addRegistry( target, options, name ) {
			var registry, keys = Object.keys( target[ name ] );
			if ( !keys.length ) {
				return;
			}
			if ( !( registry = options[ name ] ) ) {
				registry = options[ name ] = {};
			}
			keys.filter( function( key ) {
				return !( key in registry );
			} ).forEach( function( key ) {
				return registry[ key ] = target[ name ][ key ];
			} );
		}
	}( wrapPrototypeMethod, wrapMethod, config, circular );

	/* extend/_extend.js */
	var Ractive_extend = function( create, defineProperties, getGuid, config, initChildInstance, Viewmodel, childOptions ) {

		return function extend() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = {};
			var Parent = this,
				Child, proto, staticProperties;
			// if we're extending with another Ractive instance, inherit its
			// prototype methods and default options as well
			options = childOptions.toOptions( options );
			// create Child constructor
			Child = function( options ) {
				initChildInstance( this, Child, options );
			};
			proto = create( Parent.prototype );
			proto.constructor = Child;
			staticProperties = {
				// each component needs a guid, for managing CSS etc
				_guid: {
					value: getGuid()
				},
				// alias prototype as defaults
				defaults: {
					value: proto
				},
				// extendable
				extend: {
					value: extend,
					writable: true,
					configurable: true
				},
				// Parent - for IE8, can't use Object.getPrototypeOf
				_parent: {
					value: Parent
				}
			};
			defineProperties( Child, staticProperties );
			// extend configuration
			config.extend( Parent, proto, options );
			Viewmodel.extend( Parent, proto );
			// and any other properties or methods on options...
			childOptions.toPrototype( Parent.prototype, proto, options );
			Child.prototype = proto;
			return Child;
		};
	}( create, defineProperties, getGuid, config, initChildInstance, Viewmodel, childOptions );

	/* Ractive.js */
	var Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {

		var Ractive, properties;
		// Main Ractive required object
		Ractive = function( options ) {
			initialise( this, options );
		};
		// Ractive properties
		properties = {
			// static methods:
			extend: {
				value: extend
			},
			parse: {
				value: parse
			},
			// Namespaced constructors
			Promise: {
				value: Promise
			},
			// support
			svg: {
				value: svg
			},
			magic: {
				value: magic
			},
			// version
			VERSION: {
				value: '0.5.5'
			},
			// Plugins
			adaptors: {
				writable: true,
				value: {}
			},
			components: {
				writable: true,
				value: {}
			},
			decorators: {
				writable: true,
				value: {}
			},
			easing: {
				writable: true,
				value: easing
			},
			events: {
				writable: true,
				value: {}
			},
			interpolators: {
				writable: true,
				value: interpolators
			},
			partials: {
				writable: true,
				value: {}
			},
			transitions: {
				writable: true,
				value: {}
			}
		};
		// Ractive properties
		defineProperties( Ractive, properties );
		Ractive.prototype = extendObj( proto, defaults );
		Ractive.prototype.constructor = Ractive;
		// alias prototype as defaults
		Ractive.defaults = Ractive.prototype;
		// Certain modules have circular dependencies. If we were bundling a
		// module loader, e.g. almond.js, this wouldn't be a problem, but we're
		// not - we're using amdclean as part of the build process. Because of
		// this, we need to wait until all modules have loaded before those
		// circular dependencies can be required.
		circular.Ractive = Ractive;
		while ( circular.length ) {
			circular.pop()();
		}
		// Ractive.js makes liberal use of things like Array.prototype.indexOf. In
		// older browsers, these are made available via a shim - here, we do a quick
		// pre-flight check to make sure that either a) we're not in a shit browser,
		// or b) we're using a Ractive-legacy.js build
		var FUNCTION = 'function';
		if ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {
			throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
		}
		return Ractive;
	}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );


	// export as Common JS module...
	if ( typeof module !== "undefined" && module.exports ) {
		module.exports = Ractive;
	}

	// ... or as AMD module
	else if ( typeof define === "function" && define.amd ) {
		define( function() {
			return Ractive;
		} );
	}

	// ... or as browser global
	global.Ractive = Ractive;

	Ractive.noConflict = function() {
		global.Ractive = noConflict;
		return Ractive;
	};

}( typeof window !== 'undefined' ? window : this ) );

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2RhcmtvL0RldmVsb3BtZW50L2F3ZXNvbWVwYWQyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuL3NyYy9hcHAuanMiLCIvaG9tZS9kYXJrby9EZXZlbG9wbWVudC9hd2Vzb21lcGFkMi9ib3dlcl9jb21wb25lbnRzL3JhY3RpdmUvcmFjdGl2ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiBqc2hpbnQgbm9kZTp0cnVlICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJhY3RpdmUgPSByZXF1aXJlKFwiLi8uLi9ib3dlcl9jb21wb25lbnRzL3JhY3RpdmUvcmFjdGl2ZS5qc1wiKTtcblxuY29uc29sZS5sb2coXCJoZWxsbyB3b3JsZFwiKTtcbmNvbnNvbGUubG9nKFJhY3RpdmUpO1xuIiwiLypcblx0cmFjdGl2ZS5qcyB2MC41LjVcblx0MjAxNC0wNy0xMyAtIGNvbW1pdCA4YjFkMzRlZiBcblxuXHRodHRwOi8vcmFjdGl2ZWpzLm9yZ1xuXHRodHRwOi8vdHdpdHRlci5jb20vUmFjdGl2ZUpTXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbm9Db25mbGljdCA9IGdsb2JhbC5SYWN0aXZlO1xuXG5cdC8qIGNvbmZpZy9kZWZhdWx0cy9vcHRpb25zLmpzICovXG5cdHZhciBvcHRpb25zID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBUaGVzZSBhcmUgYm90aCB0aGUgdmFsdWVzIGZvciBSYWN0aXZlLmRlZmF1bHRzXG5cdFx0Ly8gYXMgd2VsbCBhcyB0aGUgZGV0ZXJtaW5hdGlvbiBmb3Igd2hldGhlciBhbiBvcHRpb25cblx0XHQvLyB2YWx1ZSB3aWxsIGJlIHBsYWNlZCBvbiBDb21wb25lbnQuZGVmYXVsdHNcblx0XHQvLyAodmVyc3VzIGRpcmVjdGx5IG9uIENvbXBvbmVudCkgZHVyaW5nIGFuIGV4dGVuZCBvcGVyYXRpb25cblx0XHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0XHQvLyByZW5kZXIgcGxhY2VtZW50OlxuXHRcdFx0ZWw6IHZvaWQgMCxcblx0XHRcdGFwcGVuZDogZmFsc2UsXG5cdFx0XHQvLyB0ZW1wbGF0ZTpcblx0XHRcdHRlbXBsYXRlOiB7XG5cdFx0XHRcdHY6IDEsXG5cdFx0XHRcdHQ6IFtdXG5cdFx0XHR9LFxuXHRcdFx0Ly8gcGFyc2U6XG5cdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2U6IGZhbHNlLFxuXHRcdFx0c2FuaXRpemU6IGZhbHNlLFxuXHRcdFx0c3RyaXBDb21tZW50czogdHJ1ZSxcblx0XHRcdC8vIGRhdGEgJiBiaW5kaW5nOlxuXHRcdFx0ZGF0YToge30sXG5cdFx0XHRjb21wdXRlZDoge30sXG5cdFx0XHRtYWdpYzogZmFsc2UsXG5cdFx0XHRtb2RpZnlBcnJheXM6IHRydWUsXG5cdFx0XHRhZGFwdDogW10sXG5cdFx0XHRpc29sYXRlZDogZmFsc2UsXG5cdFx0XHR0d293YXk6IHRydWUsXG5cdFx0XHRsYXp5OiBmYWxzZSxcblx0XHRcdC8vIHRyYW5zaXRpb25zOlxuXHRcdFx0bm9JbnRybzogZmFsc2UsXG5cdFx0XHR0cmFuc2l0aW9uc0VuYWJsZWQ6IHRydWUsXG5cdFx0XHRjb21wbGV0ZTogdm9pZCAwLFxuXHRcdFx0Ly8gY3NzOlxuXHRcdFx0bm9Dc3NUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdFx0Ly8gZGVidWc6XG5cdFx0XHRkZWJ1ZzogZmFsc2Vcblx0XHR9O1xuXHRcdHJldHVybiBkZWZhdWx0T3B0aW9ucztcblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9kZWZhdWx0cy9lYXNpbmcuanMgKi9cblx0dmFyIGVhc2luZyA9IHtcblx0XHRsaW5lYXI6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRyZXR1cm4gcG9zO1xuXHRcdH0sXG5cdFx0ZWFzZUluOiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0cmV0dXJuIE1hdGgucG93KCBwb3MsIDMgKTtcblx0XHR9LFxuXHRcdGVhc2VPdXQ6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIHBvcyAtIDEsIDMgKSArIDE7XG5cdFx0fSxcblx0XHRlYXNlSW5PdXQ6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRpZiAoICggcG9zIC89IDAuNSApIDwgMSApIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KCBwb3MsIDMgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoIE1hdGgucG93KCBwb3MgLSAyLCAzICkgKyAyICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIGNpcmN1bGFyLmpzICovXG5cdHZhciBjaXJjdWxhciA9IFtdO1xuXG5cdC8qIHV0aWxzL2hhc093blByb3BlcnR5LmpzICovXG5cdHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cdC8qIHV0aWxzL2lzQXJyYXkuanMgKi9cblx0dmFyIGlzQXJyYXkgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFx0Ly8gdGhhbmtzLCBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9pbnN0YW5jZW9mLWNvbnNpZGVyZWQtaGFybWZ1bC1vci1ob3ctdG8td3JpdGUtYS1yb2J1c3QtaXNhcnJheS9cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0cmV0dXJuIHRvU3RyaW5nLmNhbGwoIHRoaW5nICkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2lzT2JqZWN0LmpzICovXG5cdHZhciBpc09iamVjdCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0cmV0dXJuIHRoaW5nICYmIHRvU3RyaW5nLmNhbGwoIHRoaW5nICkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB1dGlscy9pc051bWVyaWMuanMgKi9cblx0dmFyIGlzTnVtZXJpYyA9IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRyZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KCB0aGluZyApICkgJiYgaXNGaW5pdGUoIHRoaW5nICk7XG5cdH07XG5cblx0LyogY29uZmlnL2RlZmF1bHRzL2ludGVycG9sYXRvcnMuanMgKi9cblx0dmFyIGludGVycG9sYXRvcnMgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGhhc093blByb3BlcnR5LCBpc0FycmF5LCBpc09iamVjdCwgaXNOdW1lcmljICkge1xuXG5cdFx0dmFyIGludGVycG9sYXRvcnMsIGludGVycG9sYXRlLCBjc3NMZW5ndGhQYXR0ZXJuO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aW50ZXJwb2xhdGUgPSBjaXJjdWxhci5pbnRlcnBvbGF0ZTtcblx0XHR9ICk7XG5cdFx0Y3NzTGVuZ3RoUGF0dGVybiA9IC9eKFsrLV0/WzAtOV0rXFwuPyg/OlswLTldKyk/KShweHxlbXxleHwlfGlufGNtfG1tfHB0fHBjKSQvO1xuXHRcdGludGVycG9sYXRvcnMgPSB7XG5cdFx0XHRudW1iZXI6IGZ1bmN0aW9uKCBmcm9tLCB0byApIHtcblx0XHRcdFx0dmFyIGRlbHRhO1xuXHRcdFx0XHRpZiAoICFpc051bWVyaWMoIGZyb20gKSB8fCAhaXNOdW1lcmljKCB0byApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZyb20gPSArZnJvbTtcblx0XHRcdFx0dG8gPSArdG87XG5cdFx0XHRcdGRlbHRhID0gdG8gLSBmcm9tO1xuXHRcdFx0XHRpZiAoICFkZWx0YSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnJvbSArIHQgKiBkZWx0YTtcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRhcnJheTogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgaW50ZXJtZWRpYXRlLCBpbnRlcnBvbGF0b3JzLCBsZW4sIGk7XG5cdFx0XHRcdGlmICggIWlzQXJyYXkoIGZyb20gKSB8fCAhaXNBcnJheSggdG8gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbnRlcm1lZGlhdGUgPSBbXTtcblx0XHRcdFx0aW50ZXJwb2xhdG9ycyA9IFtdO1xuXHRcdFx0XHRpID0gbGVuID0gTWF0aC5taW4oIGZyb20ubGVuZ3RoLCB0by5sZW5ndGggKTtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aW50ZXJwb2xhdG9yc1sgaSBdID0gaW50ZXJwb2xhdGUoIGZyb21bIGkgXSwgdG9bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHN1cnBsdXMgdmFsdWVzIC0gZG9uJ3QgaW50ZXJwb2xhdGUsIGJ1dCBkb24ndCBleGNsdWRlIHRoZW0gZWl0aGVyXG5cdFx0XHRcdGZvciAoIGkgPSBsZW47IGkgPCBmcm9tLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGludGVybWVkaWF0ZVsgaSBdID0gZnJvbVsgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGkgPSBsZW47IGkgPCB0by5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIGkgXSA9IHRvWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdHZhciBpID0gbGVuO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBpIF0gPSBpbnRlcnBvbGF0b3JzWyBpIF0oIHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGludGVybWVkaWF0ZTtcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRvYmplY3Q6IGZ1bmN0aW9uKCBmcm9tLCB0byApIHtcblx0XHRcdFx0dmFyIHByb3BlcnRpZXMsIGxlbiwgaW50ZXJwb2xhdG9ycywgaW50ZXJtZWRpYXRlLCBwcm9wO1xuXHRcdFx0XHRpZiAoICFpc09iamVjdCggZnJvbSApIHx8ICFpc09iamVjdCggdG8gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9wZXJ0aWVzID0gW107XG5cdFx0XHRcdGludGVybWVkaWF0ZSA9IHt9O1xuXHRcdFx0XHRpbnRlcnBvbGF0b3JzID0ge307XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gZnJvbSApIHtcblx0XHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIGZyb20sIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggdG8sIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdGludGVycG9sYXRvcnNbIHByb3AgXSA9IGludGVycG9sYXRlKCBmcm9tWyBwcm9wIF0sIHRvWyBwcm9wIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgcHJvcCBdID0gZnJvbVsgcHJvcCBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBwcm9wIGluIHRvICkge1xuXHRcdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggdG8sIHByb3AgKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbCggZnJvbSwgcHJvcCApICkge1xuXHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBwcm9wIF0gPSB0b1sgcHJvcCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdHZhciBpID0gbGVuLFxuXHRcdFx0XHRcdFx0cHJvcDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzWyBpIF07XG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IGludGVycG9sYXRvcnNbIHByb3AgXSggdCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGNzc0xlbmd0aDogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgZnJvbU1hdGNoLCB0b01hdGNoLCBmcm9tVW5pdCwgdG9Vbml0LCBmcm9tVmFsdWUsIHRvVmFsdWUsIHVuaXQsIGRlbHRhO1xuXHRcdFx0XHRpZiAoIGZyb20gIT09IDAgJiYgdHlwZW9mIGZyb20gIT09ICdzdHJpbmcnIHx8IHRvICE9PSAwICYmIHR5cGVvZiB0byAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJvbU1hdGNoID0gY3NzTGVuZ3RoUGF0dGVybi5leGVjKCBmcm9tICk7XG5cdFx0XHRcdHRvTWF0Y2ggPSBjc3NMZW5ndGhQYXR0ZXJuLmV4ZWMoIHRvICk7XG5cdFx0XHRcdGZyb21Vbml0ID0gZnJvbU1hdGNoID8gZnJvbU1hdGNoWyAyIF0gOiAnJztcblx0XHRcdFx0dG9Vbml0ID0gdG9NYXRjaCA/IHRvTWF0Y2hbIDIgXSA6ICcnO1xuXHRcdFx0XHRpZiAoIGZyb21Vbml0ICYmIHRvVW5pdCAmJiBmcm9tVW5pdCAhPT0gdG9Vbml0ICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHVuaXQgPSBmcm9tVW5pdCB8fCB0b1VuaXQ7XG5cdFx0XHRcdGZyb21WYWx1ZSA9IGZyb21NYXRjaCA/ICtmcm9tTWF0Y2hbIDEgXSA6IDA7XG5cdFx0XHRcdHRvVmFsdWUgPSB0b01hdGNoID8gK3RvTWF0Y2hbIDEgXSA6IDA7XG5cdFx0XHRcdGRlbHRhID0gdG9WYWx1ZSAtIGZyb21WYWx1ZTtcblx0XHRcdFx0aWYgKCAhZGVsdGEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21WYWx1ZSArIHVuaXQ7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21WYWx1ZSArIHQgKiBkZWx0YSArIHVuaXQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gaW50ZXJwb2xhdG9ycztcblx0fSggY2lyY3VsYXIsIGhhc093biwgaXNBcnJheSwgaXNPYmplY3QsIGlzTnVtZXJpYyApO1xuXG5cdC8qIGNvbmZpZy9zdmcuanMgKi9cblx0dmFyIHN2ZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN2Zztcblx0XHRpZiAoIHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRzdmcgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3ZnID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSggJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLCAnMS4xJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gc3ZnO1xuXHR9KCk7XG5cblx0LyogdXRpbHMvcmVtb3ZlRnJvbUFycmF5LmpzICovXG5cdHZhciByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiggYXJyYXksIG1lbWJlciApIHtcblx0XHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKCBtZW1iZXIgKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdGFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdXRpbHMvUHJvbWlzZS5qcyAqL1xuXHR2YXIgUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9Qcm9taXNlLCBQRU5ESU5HID0ge30sXG5cdFx0XHRGVUxGSUxMRUQgPSB7fSxcblx0XHRcdFJFSkVDVEVEID0ge307XG5cdFx0aWYgKCB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIHVzZSBuYXRpdmUgUHJvbWlzZVxuXHRcdFx0X1Byb21pc2UgPSBQcm9taXNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfUHJvbWlzZSA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdFx0dmFyIGZ1bGZpbGxlZEhhbmRsZXJzID0gW10sXG5cdFx0XHRcdFx0cmVqZWN0ZWRIYW5kbGVycyA9IFtdLFxuXHRcdFx0XHRcdHN0YXRlID0gUEVORElORyxcblx0XHRcdFx0XHRyZXN1bHQsIGRpc3BhdGNoSGFuZGxlcnMsIG1ha2VSZXNvbHZlciwgZnVsZmlsLCByZWplY3QsIHByb21pc2U7XG5cdFx0XHRcdG1ha2VSZXNvbHZlciA9IGZ1bmN0aW9uKCBuZXdTdGF0ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gUEVORElORyApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IG5ld1N0YXRlO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2hIYW5kbGVycyA9IG1ha2VEaXNwYXRjaGVyKCBzdGF0ZSA9PT0gRlVMRklMTEVEID8gZnVsZmlsbGVkSGFuZGxlcnMgOiByZWplY3RlZEhhbmRsZXJzLCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdC8vIGRpc3BhdGNoIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG5cdFx0XHRcdFx0XHR3YWl0KCBkaXNwYXRjaEhhbmRsZXJzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0ZnVsZmlsID0gbWFrZVJlc29sdmVyKCBGVUxGSUxMRUQgKTtcblx0XHRcdFx0cmVqZWN0ID0gbWFrZVJlc29sdmVyKCBSRUpFQ1RFRCApO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdHJlamVjdCggZXJyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0XHQvLyBgdGhlbigpYCByZXR1cm5zIGEgUHJvbWlzZSAtIDIuMi43XG5cdFx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkICkge1xuXHRcdFx0XHRcdFx0dmFyIHByb21pc2UyID0gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIgPSBmdW5jdGlvbiggaGFuZGxlciwgaGFuZGxlcnMsIGZvcndhcmQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gMi4yLjEuMVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBmdW5jdGlvbiggcDFyZXN1bHQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB4O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHggPSBoYW5kbGVyKCBwMXJlc3VsdCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIHByb21pc2UyLCB4LCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlamVjdCggZXJyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yd2FyZCB0aGUgcmVzdWx0IG9mIHByb21pc2UxIHRvIHByb21pc2UyLCBpZiByZXNvbHV0aW9uIGhhbmRsZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBhcmUgbm90IGdpdmVuXG5cdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBmb3J3YXJkICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHQvLyAyLjJcblx0XHRcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKCBvbkZ1bGZpbGxlZCwgZnVsZmlsbGVkSGFuZGxlcnMsIGZ1bGZpbCApO1xuXHRcdFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIoIG9uUmVqZWN0ZWQsIHJlamVjdGVkSGFuZGxlcnMsIHJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBQRU5ESU5HICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcm9taXNlIGhhcyByZXNvbHZlZCBhbHJlYWR5LCBkaXNwYXRjaCB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcblx0XHRcdFx0XHRcdFx0XHR3YWl0KCBkaXNwYXRjaEhhbmRsZXJzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHByb21pc2VbICdjYXRjaCcgXSA9IGZ1bmN0aW9uKCBvblJlamVjdGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRoZW4oIG51bGwsIG9uUmVqZWN0ZWQgKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdFx0X1Byb21pc2UuYWxsID0gZnVuY3Rpb24oIHByb21pc2VzICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRcdFx0cGVuZGluZywgaSwgcHJvY2Vzc1Byb21pc2U7XG5cdFx0XHRcdFx0aWYgKCAhcHJvbWlzZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZnVsZmlsKCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRcdHByb21pc2VzWyBpIF0udGhlbiggZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRpZiAoICEtLXBlbmRpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZnVsZmlsKCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRwZW5kaW5nID0gaSA9IHByb21pc2VzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb2Nlc3NQcm9taXNlKCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9O1xuXHRcdFx0X1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZSggZnVuY3Rpb24oIGZ1bGZpbCApIHtcblx0XHRcdFx0XHRmdWxmaWwoIHZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiggcmVhc29uICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0cmVqZWN0KCByZWFzb24gKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIF9Qcm9taXNlO1xuXHRcdC8vIFRPRE8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJzIG9yIHNvbWV0aGluZyB0byBzaW11bGF0ZSBzZXRJbW1lZGlhdGVcblx0XHRmdW5jdGlvbiB3YWl0KCBjYWxsYmFjayApIHtcblx0XHRcdHNldFRpbWVvdXQoIGNhbGxiYWNrLCAwICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIoIGhhbmRsZXJzLCByZXN1bHQgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBoYW5kbGVyO1xuXHRcdFx0XHR3aGlsZSAoIGhhbmRsZXIgPSBoYW5kbGVycy5zaGlmdCgpICkge1xuXHRcdFx0XHRcdGhhbmRsZXIoIHJlc3VsdCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc29sdmUoIHByb21pc2UsIHgsIGZ1bGZpbCwgcmVqZWN0ICkge1xuXHRcdFx0Ly8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVxuXHRcdFx0dmFyIHRoZW47XG5cdFx0XHQvLyAyLjMuMVxuXHRcdFx0aWYgKCB4ID09PSBwcm9taXNlICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnQSBwcm9taXNlXFwncyBmdWxmaWxsbWVudCBoYW5kbGVyIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZScgKTtcblx0XHRcdH1cblx0XHRcdC8vIDIuMy4yXG5cdFx0XHRpZiAoIHggaW5zdGFuY2VvZiBfUHJvbWlzZSApIHtcblx0XHRcdFx0eC50aGVuKCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0fSBlbHNlIGlmICggeCAmJiAoIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyApICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoZW4gPSB4LnRoZW47XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdHJlamVjdCggZSApO1xuXHRcdFx0XHRcdC8vIDIuMy4zLjJcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gMi4zLjMuM1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHZhciBjYWxsZWQsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlO1xuXHRcdFx0XHRcdHJlc29sdmVQcm9taXNlID0gZnVuY3Rpb24oIHkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJlc29sdmUoIHByb21pc2UsIHksIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZWplY3RQcm9taXNlID0gZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJlamVjdCggciApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRoZW4uY2FsbCggeCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UgKTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdGlmICggIWNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0cmVqZWN0KCBlICk7XG5cdFx0XHRcdFx0XHRcdC8vIDIuMy4zLjMuNC4yXG5cdFx0XHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZnVsZmlsKCB4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZ1bGZpbCggeCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHV0aWxzL25vcm1hbGlzZVJlZi5qcyAqL1xuXHR2YXIgbm9ybWFsaXNlUmVmID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgcmVnZXggPSAvXFxbXFxzKihcXCp8WzAtOV18WzEtOV1bMC05XSspXFxzKlxcXS9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBub3JtYWxpc2VSZWYoIHJlZiApIHtcblx0XHRcdHJldHVybiAoIHJlZiB8fCAnJyApLnJlcGxhY2UoIHJlZ2V4LCAnLiQxJyApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBzaGFyZWQvZ2V0SW5uZXJDb250ZXh0LmpzICovXG5cdHZhciBnZXRJbm5lckNvbnRleHQgPSBmdW5jdGlvbiggZnJhZ21lbnQgKSB7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKCBmcmFnbWVudC5jb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQuY29udGV4dDtcblx0XHRcdH1cblx0XHR9IHdoaWxlICggZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgKTtcblx0XHRyZXR1cm4gJyc7XG5cdH07XG5cblx0LyogdXRpbHMvaXNFcXVhbC5qcyAqL1xuXHR2YXIgaXNFcXVhbCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gbnVsbCAmJiBiID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIGEgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBiID09PSAnb2JqZWN0JyApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIGEgPT09IGI7XG5cdH07XG5cblx0Lyogc2hhcmVkL2NyZWF0ZUNvbXBvbmVudEJpbmRpbmcuanMgKi9cblx0dmFyIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGlzQXJyYXksIGlzRXF1YWwgKSB7XG5cblx0XHR2YXIgcnVubG9vcDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBydW5sb29wID0gY2lyY3VsYXIucnVubG9vcDtcblx0XHR9ICk7XG5cdFx0dmFyIEJpbmRpbmcgPSBmdW5jdGlvbiggcmFjdGl2ZSwga2V5cGF0aCwgb3RoZXJJbnN0YW5jZSwgb3RoZXJLZXlwYXRoLCBwcmlvcml0eSApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuXHRcdFx0dGhpcy5vdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZTtcblx0XHRcdHRoaXMub3RoZXJLZXlwYXRoID0gb3RoZXJLZXlwYXRoO1xuXHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdH07XG5cdFx0QmluZGluZy5wcm90b3R5cGUgPSB7XG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0Ly8gT25seSAqeW91KiBjYW4gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgfHwgdGhpcy5jb3VudGVycGFydCAmJiB0aGlzLmNvdW50ZXJwYXJ0LnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSXMgdGhpcyBhIHNtYXJ0IGFycmF5IHVwZGF0ZT8gSWYgc28sIGl0J2xsIHVwZGF0ZSBvbiBpdHNcblx0XHRcdFx0Ly8gb3duLCB3ZSBzaG91bGRuJ3QgZG8gYW55dGhpbmdcblx0XHRcdFx0aWYgKCBpc0FycmF5KCB2YWx1ZSApICYmIHZhbHVlLl9yYWN0aXZlICYmIHZhbHVlLl9yYWN0aXZlLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0Ly8gVE9ETyBtYXliZSB0aGUgY2FzZSB0aGF0IGB2YWx1ZSA9PT0gdGhpcy52YWx1ZWAgLSBzaG91bGQgdGhhdCByZXN1bHRcblx0XHRcdFx0XHQvLyBpbiBhbiB1cGRhdGUgcmF0aGVyIHRoYW4gYSBzZXQ/XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMub3RoZXJJbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLm90aGVySW5zdGFuY2Uudmlld21vZGVsLnNldCggdGhpcy5vdGhlcktleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdC8vIFRPRE8gd2lsbCB0aGUgY291bnRlcnBhcnQgdXBkYXRlIGFmdGVyIHRoaXMgbGluZSwgZHVyaW5nXG5cdFx0XHRcdFx0Ly8gdGhlIHJ1bmxvb3AgZW5kIGN5Y2xlPyBtYXkgYmUgYSBwcm9ibGVtLi4uXG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLnVuYmluZCgpO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBuZXdLZXlwYXRoO1xuXHRcdFx0XHR0aGlzLmNvdW50ZXJwYXJ0Lm90aGVyS2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50QmluZGluZyggY29tcG9uZW50LCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50S2V5cGF0aCwgY2hpbGRLZXlwYXRoICkge1xuXHRcdFx0dmFyIGhhc2gsIGNoaWxkSW5zdGFuY2UsIGJpbmRpbmdzLCBwcmlvcml0eSwgcGFyZW50VG9DaGlsZEJpbmRpbmcsIGNoaWxkVG9QYXJlbnRCaW5kaW5nO1xuXHRcdFx0aGFzaCA9IHBhcmVudEtleXBhdGggKyAnPScgKyBjaGlsZEtleXBhdGg7XG5cdFx0XHRiaW5kaW5ncyA9IGNvbXBvbmVudC5iaW5kaW5ncztcblx0XHRcdGlmICggYmluZGluZ3NbIGhhc2ggXSApIHtcblx0XHRcdFx0Ly8gVE9ETyBkb2VzIHRoaXMgZXZlciBoYXBwZW4/XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGJpbmRpbmdzWyBoYXNoIF0gPSB0cnVlO1xuXHRcdFx0Y2hpbGRJbnN0YW5jZSA9IGNvbXBvbmVudC5pbnN0YW5jZTtcblx0XHRcdHByaW9yaXR5ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50LnByaW9yaXR5O1xuXHRcdFx0cGFyZW50VG9DaGlsZEJpbmRpbmcgPSBuZXcgQmluZGluZyggcGFyZW50SW5zdGFuY2UsIHBhcmVudEtleXBhdGgsIGNoaWxkSW5zdGFuY2UsIGNoaWxkS2V5cGF0aCwgcHJpb3JpdHkgKTtcblx0XHRcdGJpbmRpbmdzLnB1c2goIHBhcmVudFRvQ2hpbGRCaW5kaW5nICk7XG5cdFx0XHRpZiAoIGNoaWxkSW5zdGFuY2UudHdvd2F5ICkge1xuXHRcdFx0XHRjaGlsZFRvUGFyZW50QmluZGluZyA9IG5ldyBCaW5kaW5nKCBjaGlsZEluc3RhbmNlLCBjaGlsZEtleXBhdGgsIHBhcmVudEluc3RhbmNlLCBwYXJlbnRLZXlwYXRoLCAxICk7XG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIGNoaWxkVG9QYXJlbnRCaW5kaW5nICk7XG5cdFx0XHRcdHBhcmVudFRvQ2hpbGRCaW5kaW5nLmNvdW50ZXJwYXJ0ID0gY2hpbGRUb1BhcmVudEJpbmRpbmc7XG5cdFx0XHRcdGNoaWxkVG9QYXJlbnRCaW5kaW5nLmNvdW50ZXJwYXJ0ID0gcGFyZW50VG9DaGlsZEJpbmRpbmc7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggY2lyY3VsYXIsIGlzQXJyYXksIGlzRXF1YWwgKTtcblxuXHQvKiBzaGFyZWQvcmVzb2x2ZVJlZi5qcyAqL1xuXHR2YXIgcmVzb2x2ZVJlZiA9IGZ1bmN0aW9uKCBub3JtYWxpc2VSZWYsIGdldElubmVyQ29udGV4dCwgY3JlYXRlQ29tcG9uZW50QmluZGluZyApIHtcblxuXHRcdHZhciBhbmNlc3RvckVycm9yTWVzc2FnZSwgZ2V0T3B0aW9ucztcblx0XHRhbmNlc3RvckVycm9yTWVzc2FnZSA9ICdDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgLSB0b28gbWFueSBcIi4uL1wiIHByZWZpeGVzJztcblx0XHRnZXRPcHRpb25zID0ge1xuXHRcdFx0ZXZhbHVhdGVXcmFwcGVkOiB0cnVlXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBmcmFnbWVudCApIHtcblx0XHRcdHZhciBjb250ZXh0LCBrZXksIGluZGV4LCBrZXlwYXRoLCBwYXJlbnRWYWx1ZSwgaGFzQ29udGV4dENoYWluLCBwYXJlbnRLZXlzLCBjaGlsZEtleXMsIHBhcmVudEtleXBhdGgsIGNoaWxkS2V5cGF0aDtcblx0XHRcdHJlZiA9IG5vcm1hbGlzZVJlZiggcmVmICk7XG5cdFx0XHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgJ34vJywgaXQncyBhIHRvcC1sZXZlbCByZWZlcmVuY2Vcblx0XHRcdGlmICggcmVmLnN1YnN0ciggMCwgMiApID09PSAnfi8nICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmLnN1YnN0cmluZyggMiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zIHdpdGggJy4nLCBpdCdzIGVpdGhlciBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIG9yXG5cdFx0XHQvLyBhbiBhbmNlc3RvciByZWZlcmVuY2UuLi5cblx0XHRcdGlmICggcmVmLmNoYXJBdCggMCApID09PSAnLicgKSB7XG5cdFx0XHRcdHJldHVybiByZXNvbHZlQW5jZXN0b3JSZWZlcmVuY2UoIGdldElubmVyQ29udGV4dCggZnJhZ21lbnQgKSwgcmVmICk7XG5cdFx0XHR9XG5cdFx0XHQvLyAuLi5vdGhlcndpc2Ugd2UgbmVlZCB0byBmaW5kIHRoZSBrZXlwYXRoXG5cdFx0XHRrZXkgPSByZWYuc3BsaXQoICcuJyApWyAwIF07XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGNvbnRleHQgPSBmcmFnbWVudC5jb250ZXh0O1xuXHRcdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCBjb250ZXh0LCBnZXRPcHRpb25zICk7XG5cdFx0XHRcdGlmICggcGFyZW50VmFsdWUgJiYgKCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyApICYmIGtleSBpbiBwYXJlbnRWYWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY29udGV4dCArICcuJyArIHJlZjtcblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50ICk7XG5cdFx0XHQvLyBSb290L2NvbXB1dGVkIHByb3BlcnR5P1xuXHRcdFx0aWYgKCBrZXkgaW4gcmFjdGl2ZS5kYXRhIHx8IGtleSBpbiByYWN0aXZlLnZpZXdtb2RlbC5jb21wdXRhdGlvbnMgKSB7XG5cdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubGluZSBjb21wb25lbnQsIGFuZCBpdCdzIG5vdCBpc29sYXRlZCwgd2Vcblx0XHRcdC8vIGNhbiB0cnkgZ29pbmcgdXAgdGhlIHNjb3BlIGNoYWluXG5cdFx0XHRpZiAoIHJhY3RpdmUuX3BhcmVudCAmJiAhcmFjdGl2ZS5pc29sYXRlZCApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSByYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaW5kZXggcmVmc1xuXHRcdFx0XHRpZiAoIGZyYWdtZW50LmluZGV4UmVmcyAmJiAoIGluZGV4ID0gZnJhZ21lbnQuaW5kZXhSZWZzWyByZWYgXSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGFuIGluZGV4IHJlZiBiaW5kaW5nLCBzbyB0aGF0IGl0IGNhbiBiZSByZWJvdW5kIGxldHRlciBpZiBuZWNlc3NhcnkuXG5cdFx0XHRcdFx0Ly8gSXQgZG9lc24ndCBoYXZlIGFuIGFsaWFzIHNpbmNlIGl0J3MgYW4gaW1wbGljaXQgYmluZGluZywgaGVuY2UgYC4uLlsgcmVmIF0gPSByZWZgXG5cdFx0XHRcdFx0cmFjdGl2ZS5jb21wb25lbnQuaW5kZXhSZWZCaW5kaW5nc1sgcmVmIF0gPSByZWY7XG5cdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KCByZWYsIGluZGV4LCB0cnVlICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXBhdGggPSByZXNvbHZlUmVmKCByYWN0aXZlLl9wYXJlbnQsIHJlZiwgZnJhZ21lbnQgKTtcblx0XHRcdFx0aWYgKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY3JlYXRlIGFuIGludGVyLWNvbXBvbmVudCBiaW5kaW5nXG5cdFx0XHRcdFx0Ly8gSWYgcGFyZW50IGtleXBhdGggaXMgJ29uZS5mb28nIGFuZCBjaGlsZCBpcyAndHdvLmZvbycsIHdlIGJpbmRcblx0XHRcdFx0XHQvLyAnb25lJyB0byAndHdvJyBhcyBpdCdzIG1vcmUgZWZmaWNpZW50IGFuZCBhdm9pZHMgZWRnZSBjYXNlc1xuXHRcdFx0XHRcdHBhcmVudEtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHRjaGlsZEtleXMgPSByZWYuc3BsaXQoICcuJyApO1xuXHRcdFx0XHRcdHdoaWxlICggcGFyZW50S2V5cy5sZW5ndGggPiAxICYmIGNoaWxkS2V5cy5sZW5ndGggPiAxICYmIHBhcmVudEtleXNbIHBhcmVudEtleXMubGVuZ3RoIC0gMSBdID09PSBjaGlsZEtleXNbIGNoaWxkS2V5cy5sZW5ndGggLSAxIF0gKSB7XG5cdFx0XHRcdFx0XHRwYXJlbnRLZXlzLnBvcCgpO1xuXHRcdFx0XHRcdFx0Y2hpbGRLZXlzLnBvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoID0gcGFyZW50S2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0XHRjaGlsZEtleXBhdGggPSBjaGlsZEtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KCBjaGlsZEtleXBhdGgsIHJhY3RpdmUuX3BhcmVudC52aWV3bW9kZWwuZ2V0KCBwYXJlbnRLZXlwYXRoICksIHRydWUgKTtcblx0XHRcdFx0XHRjcmVhdGVDb21wb25lbnRCaW5kaW5nKCByYWN0aXZlLmNvbXBvbmVudCwgcmFjdGl2ZS5fcGFyZW50LCBwYXJlbnRLZXlwYXRoLCBjaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGVyZSdzIG5vIGNvbnRleHQgY2hhaW4sIGFuZCB0aGUgaW5zdGFuY2UgaXMgZWl0aGVyIGEpIGlzb2xhdGVkIG9yXG5cdFx0XHQvLyBiKSBhbiBvcnBoYW4sIHRoZW4gd2Uga25vdyB0aGF0IHRoZSBrZXlwYXRoIGlzIGlkZW50aWNhbCB0byB0aGUgcmVmZXJlbmNlXG5cdFx0XHRpZiAoICFoYXNDb250ZXh0Q2hhaW4gKSB7XG5cdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJhY3RpdmUudmlld21vZGVsLmdldCggcmVmICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZUFuY2VzdG9yUmVmZXJlbmNlKCBiYXNlQ29udGV4dCwgcmVmICkge1xuXHRcdFx0dmFyIGNvbnRleHRLZXlzO1xuXHRcdFx0Ly8ge3sufX0gbWVhbnMgJ2N1cnJlbnQgY29udGV4dCdcblx0XHRcdGlmICggcmVmID09PSAnLicgKVxuXHRcdFx0XHRyZXR1cm4gYmFzZUNvbnRleHQ7XG5cdFx0XHRjb250ZXh0S2V5cyA9IGJhc2VDb250ZXh0ID8gYmFzZUNvbnRleHQuc3BsaXQoICcuJyApIDogW107XG5cdFx0XHQvLyBhbmNlc3RvciByZWZlcmVuY2VzIChzdGFydGluZyBcIi4uL1wiKSBnbyB1cCB0aGUgdHJlZVxuXHRcdFx0aWYgKCByZWYuc3Vic3RyKCAwLCAzICkgPT09ICcuLi8nICkge1xuXHRcdFx0XHR3aGlsZSAoIHJlZi5zdWJzdHIoIDAsIDMgKSA9PT0gJy4uLycgKSB7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dEtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBhbmNlc3RvckVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250ZXh0S2V5cy5wb3AoKTtcblx0XHRcdFx0XHRyZWYgPSByZWYuc3Vic3RyaW5nKCAzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGV4dEtleXMucHVzaCggcmVmICk7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0S2V5cy5qb2luKCAnLicgKTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdCBhbiBhbmNlc3RvciByZWZlcmVuY2UgLSBtdXN0IGJlIGEgcmVzdHJpY3RlZCByZWZlcmVuY2UgKHByZXBlbmRlZCB3aXRoIFwiLlwiIG9yIFwiLi9cIilcblx0XHRcdGlmICggIWJhc2VDb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmLnJlcGxhY2UoIC9eXFwuXFwvPy8sICcnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYmFzZUNvbnRleHQgKyByZWYucmVwbGFjZSggL15cXC5cXC8vLCAnLicgKTtcblx0XHR9XG5cdH0oIG5vcm1hbGlzZVJlZiwgZ2V0SW5uZXJDb250ZXh0LCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICk7XG5cblx0LyogZ2xvYmFsL1RyYW5zaXRpb25NYW5hZ2VyLmpzICovXG5cdHZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiggY2FsbGJhY2ssIHBhcmVudCApIHtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXHRcdFx0dGhpcy5pbnRyb3MgPSBbXTtcblx0XHRcdHRoaXMub3V0cm9zID0gW107XG5cdFx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gPSB0aGlzLm91dHJvQ2hpbGRyZW4gPSAwO1xuXHRcdFx0dGhpcy5kZXRhY2hRdWV1ZSA9IFtdO1xuXHRcdFx0dGhpcy5vdXRyb3NDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5hZGRDaGlsZCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKCBjaGlsZCApIHtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gKz0gMTtcblx0XHRcdFx0dGhpcy5vdXRyb0NoaWxkcmVuICs9IDE7XG5cdFx0XHR9LFxuXHRcdFx0ZGVjcmVtZW50T3V0cm9zOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5vdXRyb0NoaWxkcmVuIC09IDE7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZGVjcmVtZW50VG90YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gLT0gMTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG5cdFx0XHRcdGxpc3QucHVzaCggdHJhbnNpdGlvbiApO1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIHRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBsaXN0LCB0cmFuc2l0aW9uICk7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGRldGFjaE5vZGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5kZXRhY2hRdWV1ZS5mb3JFYWNoKCBkZXRhY2ggKTtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCBkZXRhY2hOb2RlcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkZXRhY2goIGVsZW1lbnQgKSB7XG5cdFx0XHRlbGVtZW50LmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRldGFjaE5vZGVzKCB0bSApIHtcblx0XHRcdHRtLmRldGFjaE5vZGVzKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2soIHRtICkge1xuXHRcdFx0aWYgKCAhdG0ucmVhZHkgfHwgdG0ub3V0cm9zLmxlbmd0aCB8fCB0bS5vdXRyb0NoaWxkcmVuIClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Ly8gSWYgYWxsIG91dHJvcyBhcmUgY29tcGxldGUsIGFuZCB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSB0aGlzLFxuXHRcdFx0Ly8gd2Ugbm90aWZ5IHRoZSBwYXJlbnQgaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2Vcblx0XHRcdC8vIHN0YXJ0IGRldGFjaGluZyBub2Rlc1xuXHRcdFx0aWYgKCAhdG0ub3V0cm9zQ29tcGxldGUgKSB7XG5cdFx0XHRcdGlmICggdG0ucGFyZW50ICkge1xuXHRcdFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRPdXRyb3MoIHRtICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bS5vdXRyb3NDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgd2UgY2FuIG5vdGlmeSBwYXJlbnQgdHJhbnNpdGlvblxuXHRcdFx0Ly8gbWFuYWdlciBhbmQgY2FsbCB0aGUgY2FsbGJhY2tcblx0XHRcdGlmICggIXRtLmludHJvcy5sZW5ndGggJiYgIXRtLnRvdGFsQ2hpbGRyZW4gKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRtLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHRtLmNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0bS5wYXJlbnQgKSB7XG5cdFx0XHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudFRvdGFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFRyYW5zaXRpb25NYW5hZ2VyO1xuXHR9KCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBnbG9iYWwvcnVubG9vcC5qcyAqL1xuXHR2YXIgcnVubG9vcCA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgcmVtb3ZlRnJvbUFycmF5LCBQcm9taXNlLCByZXNvbHZlUmVmLCBUcmFuc2l0aW9uTWFuYWdlciApIHtcblxuXHRcdHZhciBiYXRjaCwgcnVubG9vcCwgdW5yZXNvbHZlZCA9IFtdO1xuXHRcdHJ1bmxvb3AgPSB7XG5cdFx0XHRzdGFydDogZnVuY3Rpb24oIGluc3RhbmNlLCByZXR1cm5Qcm9taXNlICkge1xuXHRcdFx0XHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZTtcblx0XHRcdFx0aWYgKCByZXR1cm5Qcm9taXNlICkge1xuXHRcdFx0XHRcdHByb21pc2UgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIGYgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVsZmlsUHJvbWlzZSA9IGY7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJhdGNoID0ge1xuXHRcdFx0XHRcdHByZXZpb3VzQmF0Y2g6IGJhdGNoLFxuXHRcdFx0XHRcdHRyYW5zaXRpb25NYW5hZ2VyOiBuZXcgVHJhbnNpdGlvbk1hbmFnZXIoIGZ1bGZpbFByb21pc2UsIGJhdGNoICYmIGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyICksXG5cdFx0XHRcdFx0dmlld3M6IFtdLFxuXHRcdFx0XHRcdHRhc2tzOiBbXSxcblx0XHRcdFx0XHR2aWV3bW9kZWxzOiBbXVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGJhdGNoLnZpZXdtb2RlbHMucHVzaCggaW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9LFxuXHRcdFx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zmx1c2hDaGFuZ2VzKCk7XG5cdFx0XHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmluaXQoKTtcblx0XHRcdFx0YmF0Y2ggPSBiYXRjaC5wcmV2aW91c0JhdGNoO1xuXHRcdFx0fSxcblx0XHRcdGFkZFZpZXdtb2RlbDogZnVuY3Rpb24oIHZpZXdtb2RlbCApIHtcblx0XHRcdFx0aWYgKCBiYXRjaCApIHtcblx0XHRcdFx0XHRpZiAoIGJhdGNoLnZpZXdtb2RlbHMuaW5kZXhPZiggdmlld21vZGVsICkgPT09IC0xICkge1xuXHRcdFx0XHRcdFx0YmF0Y2gudmlld21vZGVscy5wdXNoKCB2aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmlld21vZGVsLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVnaXN0ZXJUcmFuc2l0aW9uOiBmdW5jdGlvbiggdHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dHJhbnNpdGlvbi5fbWFuYWdlciA9IGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyO1xuXHRcdFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGQoIHRyYW5zaXRpb24gKTtcblx0XHRcdH0sXG5cdFx0XHRhZGRWaWV3OiBmdW5jdGlvbiggdmlldyApIHtcblx0XHRcdFx0YmF0Y2gudmlld3MucHVzaCggdmlldyApO1xuXHRcdFx0fSxcblx0XHRcdGFkZFVucmVzb2x2ZWQ6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0dW5yZXNvbHZlZC5wdXNoKCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZVVucmVzb2x2ZWQ6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB1bnJlc29sdmVkLCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdC8vIHN5bmNocm9uaXNlIG5vZGUgZGV0YWNobWVudHMgd2l0aCB0cmFuc2l0aW9uIGVuZHNcblx0XHRcdGRldGFjaFdoZW5SZWFkeTogZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5kZXRhY2hRdWV1ZS5wdXNoKCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHNjaGVkdWxlVGFzazogZnVuY3Rpb24oIHRhc2sgKSB7XG5cdFx0XHRcdGlmICggIWJhdGNoICkge1xuXHRcdFx0XHRcdHRhc2soKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRiYXRjaC50YXNrcy5wdXNoKCB0YXNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdGNpcmN1bGFyLnJ1bmxvb3AgPSBydW5sb29wO1xuXHRcdHJldHVybiBydW5sb29wO1xuXG5cdFx0ZnVuY3Rpb24gZmx1c2hDaGFuZ2VzKCkge1xuXHRcdFx0dmFyIGksIHRoaW5nLCBjaGFuZ2VIYXNoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBiYXRjaC52aWV3bW9kZWxzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHR0aGluZyA9IGJhdGNoLnZpZXdtb2RlbHNbIGkgXTtcblx0XHRcdFx0Y2hhbmdlSGFzaCA9IHRoaW5nLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0XHRpZiAoIGNoYW5nZUhhc2ggKSB7XG5cdFx0XHRcdFx0dGhpbmcucmFjdGl2ZS5maXJlKCAnY2hhbmdlJywgY2hhbmdlSGFzaCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRiYXRjaC52aWV3bW9kZWxzLmxlbmd0aCA9IDA7XG5cdFx0XHRhdHRlbXB0S2V5cGF0aFJlc29sdXRpb24oKTtcblx0XHRcdC8vIE5vdyB0aGF0IGNoYW5nZXMgaGF2ZSBiZWVuIGZ1bGx5IHByb3BhZ2F0ZWQsIHdlIGNhbiB1cGRhdGUgdGhlIERPTVxuXHRcdFx0Ly8gYW5kIGNvbXBsZXRlIG90aGVyIHRhc2tzXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJhdGNoLnZpZXdzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRiYXRjaC52aWV3c1sgaSBdLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0YmF0Y2gudmlld3MubGVuZ3RoID0gMDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgYmF0Y2gudGFza3MubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdGJhdGNoLnRhc2tzWyBpIF0oKTtcblx0XHRcdH1cblx0XHRcdGJhdGNoLnRhc2tzLmxlbmd0aCA9IDA7XG5cdFx0XHQvLyBJZiB1cGRhdGluZyB0aGUgdmlldyBjYXVzZWQgc29tZSBtb2RlbCBibG93YmFjayAtIGUuZy4gYSB0cmlwbGVcblx0XHRcdC8vIGNvbnRhaW5pbmcgPG9wdGlvbj4gZWxlbWVudHMgY2F1c2VkIHRoZSBiaW5kaW5nIG9uIHRoZSA8c2VsZWN0PlxuXHRcdFx0Ly8gdG8gdXBkYXRlIC0gdGhlbiB3ZSBzdGFydCBvdmVyXG5cdFx0XHRpZiAoIGJhdGNoLnZpZXdtb2RlbHMubGVuZ3RoIClcblx0XHRcdFx0cmV0dXJuIGZsdXNoQ2hhbmdlcygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpIHtcblx0XHRcdHZhciBhcnJheSwgdGhpbmcsIGtleXBhdGg7XG5cdFx0XHRpZiAoICF1bnJlc29sdmVkLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc2VlIGlmIHdlIGNhbiByZXNvbHZlIGFueSB1bnJlc29sdmVkIHJlZmVyZW5jZXNcblx0XHRcdGFycmF5ID0gdW5yZXNvbHZlZC5zcGxpY2UoIDAsIHVucmVzb2x2ZWQubGVuZ3RoICk7XG5cdFx0XHR3aGlsZSAoIHRoaW5nID0gYXJyYXkucG9wKCkgKSB7XG5cdFx0XHRcdGlmICggdGhpbmcua2V5cGF0aCApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggdGhpbmcucm9vdCwgdGhpbmcucmVmLCB0aGluZy5wYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBJZiB3ZSd2ZSByZXNvbHZlZCB0aGUga2V5cGF0aCwgd2UgY2FuIGluaXRpYWxpc2UgdGhpcyBpdGVtXG5cdFx0XHRcdFx0dGhpbmcucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIHdlIGNhbid0IHJlc29sdmUgdGhlIHJlZmVyZW5jZSwgdHJ5IGFnYWluIG5leHQgdGltZVxuXHRcdFx0XHRcdHVucmVzb2x2ZWQucHVzaCggdGhpbmcgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSggY2lyY3VsYXIsIHJlbW92ZUZyb21BcnJheSwgUHJvbWlzZSwgcmVzb2x2ZVJlZiwgVHJhbnNpdGlvbk1hbmFnZXIgKTtcblxuXHQvKiB1dGlscy9jcmVhdGVCcmFuY2guanMgKi9cblx0dmFyIGNyZWF0ZUJyYW5jaCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG51bWVyaWMgPSAvXlxccypbMC05XStcXHMqJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gbnVtZXJpYy50ZXN0KCBrZXkgKSA/IFtdIDoge307XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L21hZ2ljQWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9tYWdpY0FkYXB0b3IgPSBmdW5jdGlvbiggcnVubG9vcCwgY3JlYXRlQnJhbmNoLCBpc0FycmF5ICkge1xuXG5cdFx0dmFyIG1hZ2ljQWRhcHRvciwgTWFnaWNXcmFwcGVyO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHRcdG1hZ2ljQWRhcHRvciA9IHtcblx0XHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkge1xuXHRcdFx0XHRcdHZhciBrZXlzLCBrZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFdyYXBwZXIsIHBhcmVudFZhbHVlO1xuXHRcdFx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHRrZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRcdC8vIElmIHRoZSBwYXJlbnQgdmFsdWUgaXMgYSB3cmFwcGVyLCBvdGhlciB0aGFuIGEgbWFnaWMgd3JhcHBlcixcblx0XHRcdFx0XHQvLyB3ZSBzaG91bGRuJ3Qgd3JhcCB0aGlzIHByb3BlcnR5XG5cdFx0XHRcdFx0aWYgKCAoIHBhcmVudFdyYXBwZXIgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF0gKSAmJiAhcGFyZW50V3JhcHBlci5tYWdpYyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLmdldCggcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHRcdC8vIGlmIHBhcmVudFZhbHVlIGlzIGFuIGFycmF5IHRoYXQgZG9lc24ndCBpbmNsdWRlIHRoaXMgbWVtYmVyLFxuXHRcdFx0XHRcdC8vIHdlIHNob3VsZCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlIGxlbmd0aHMgd2lsbCBnZXQgbWVzc2VkIHVwXG5cdFx0XHRcdFx0aWYgKCBpc0FycmF5KCBwYXJlbnRWYWx1ZSApICYmIC9eWzAtOV0rJC8udGVzdCgga2V5ICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwYXJlbnRWYWx1ZSAmJiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSAnZnVuY3Rpb24nICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljV3JhcHBlciggcmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdE1hZ2ljV3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGtleXMsIG9iaktleXBhdGgsIHRlbXBsYXRlLCBzaWJsaW5ncztcblx0XHRcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0XHR0aGlzLnByb3AgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRvYmpLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0dGhpcy5vYmogPSBvYmpLZXlwYXRoID8gcmFjdGl2ZS5nZXQoIG9iaktleXBhdGggKSA6IHJhY3RpdmUuZGF0YTtcblx0XHRcdFx0dGVtcGxhdGUgPSB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHRoaXMub2JqLCB0aGlzLnByb3AgKTtcblx0XHRcdFx0Ly8gSGFzIHRoaXMgcHJvcGVydHkgYWxyZWFkeSBiZWVuIHdyYXBwZWQ/XG5cdFx0XHRcdGlmICggdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0ICYmICggc2libGluZ3MgPSB0ZW1wbGF0ZS5zZXQuX3JhY3RpdmVXcmFwcGVycyApICkge1xuXHRcdFx0XHRcdC8vIFllcy4gUmVnaXN0ZXIgdGhpcyB3cmFwcGVyIHRvIHRoaXMgcHJvcGVydHksIGlmIGl0IGhhc24ndCBiZWVuIGFscmVhZHlcblx0XHRcdFx0XHRpZiAoIHNpYmxpbmdzLmluZGV4T2YoIHRoaXMgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRzaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBObywgaXQgaGFzbid0IGJlZW4gd3JhcHBlZFxuXHRcdFx0XHRjcmVhdGVBY2Nlc3NvcnMoIHRoaXMsIHZhbHVlLCB0ZW1wbGF0ZSApO1xuXHRcdFx0fTtcblx0XHRcdE1hZ2ljV3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHQvLyB0cmlnZ2VyIHNldCgpIGFjY2Vzc29yXG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucmFjdGl2ZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLm1hcmsoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXRoaXMub2JqWyB0aGlzLnByb3AgXSApIHtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdID0gY3JlYXRlQnJhbmNoKCBrZXkgKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHRlbXBsYXRlLCBzZXQsIHZhbHVlLCB3cmFwcGVycywgaW5kZXg7XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWNhdXNlIHRoZSBjYWNoZSB3YXMgYmVpbmcgY2xlYXJlZCBhcyBhXG5cdFx0XHRcdFx0Ly8gcmVzdWx0IG9mIGEgc2V0KCkvdXBkYXRlKCkgY2FsbCBtYWRlIGJ5IHRoaXMgd3JhcHBlciwgd2UgcmV0dXJuIGZhbHNlXG5cdFx0XHRcdFx0Ly8gc28gdGhhdCBpdCBkb2Vzbid0IGdldCB0b3JuIGRvd25cblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRlbXBsYXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdGhpcy5vYmosIHRoaXMucHJvcCApO1xuXHRcdFx0XHRcdHNldCA9IHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldDtcblx0XHRcdFx0XHRpZiAoICFzZXQgKSB7XG5cdFx0XHRcdFx0XHQvLyBtb3N0IGxpa2VseSwgdGhpcyB3YXMgYW4gYXJyYXkgbWVtYmVyIHRoYXQgd2FzIHNwbGljZWQgb3V0XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdyYXBwZXJzID0gc2V0Ll9yYWN0aXZlV3JhcHBlcnM7XG5cdFx0XHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHR3cmFwcGVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIExhc3Qgb25lIG91dCwgdHVybiBvZmYgdGhlIGxpZ2h0c1xuXHRcdFx0XHRcdGlmICggIXdyYXBwZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdGhpcy5vYmpbIHRoaXMucHJvcCBdO1xuXHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLm9iaiwgdGhpcy5wcm9wLCB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciB8fCB7XG5cdFx0XHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0bWFnaWNBZGFwdG9yID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBtYWdpY0FkYXB0b3I7XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVBY2Nlc3NvcnMoIG9yaWdpbmFsV3JhcHBlciwgdmFsdWUsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIG9iamVjdCwgcHJvcGVydHksIG9sZEdldCwgb2xkU2V0LCBnZXQsIHNldDtcblx0XHRcdG9iamVjdCA9IG9yaWdpbmFsV3JhcHBlci5vYmo7XG5cdFx0XHRwcm9wZXJ0eSA9IG9yaWdpbmFsV3JhcHBlci5wcm9wO1xuXHRcdFx0Ly8gSXMgdGhpcyB0ZW1wbGF0ZSBjb25maWd1cmFibGU/XG5cdFx0XHRpZiAoIHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb25maWd1cmFibGUgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGFycmF5IGxlbmd0aFxuXHRcdFx0XHRpZiAoIHByb3BlcnR5ID09PSAnbGVuZ3RoJyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IHVzZSBtYWdpYyBtb2RlIHdpdGggcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCIgLSBvYmplY3QgaXMgbm90IGNvbmZpZ3VyYWJsZScgKTtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWUgdG8gd3JhcCB0aGlzIHByb3BlcnR5XG5cdFx0XHRpZiAoIHRlbXBsYXRlICkge1xuXHRcdFx0XHRvbGRHZXQgPSB0ZW1wbGF0ZS5nZXQ7XG5cdFx0XHRcdG9sZFNldCA9IHRlbXBsYXRlLnNldDtcblx0XHRcdH1cblx0XHRcdGdldCA9IG9sZEdldCB8fCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fTtcblx0XHRcdHNldCA9IGZ1bmN0aW9uKCB2ICkge1xuXHRcdFx0XHRpZiAoIG9sZFNldCApIHtcblx0XHRcdFx0XHRvbGRTZXQoIHYgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IG9sZEdldCA/IG9sZEdldCgpIDogdjtcblx0XHRcdFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMuZm9yRWFjaCggdXBkYXRlV3JhcHBlciApO1xuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlV3JhcHBlciggd3JhcHBlciApIHtcblx0XHRcdFx0dmFyIGtleXBhdGgsIHJhY3RpdmU7XG5cdFx0XHRcdHdyYXBwZXIudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKCB3cmFwcGVyLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyYWN0aXZlID0gd3JhcHBlci5yYWN0aXZlO1xuXHRcdFx0XHRrZXlwYXRoID0gd3JhcHBlci5rZXlwYXRoO1xuXHRcdFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0cnVubG9vcC5zdGFydCggcmFjdGl2ZSApO1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIENyZWF0ZSBhbiBhcnJheSBvZiB3cmFwcGVycywgaW4gY2FzZSBvdGhlciBrZXlwYXRocy9yYWN0aXZlcyBkZXBlbmQgb24gdGhpcyBwcm9wZXJ0eS5cblx0XHRcdC8vIEhhbmRpbHksIHdlIGNhbiBzdG9yZSB0aGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIHNldCBmdW5jdGlvbi4gWWF5IEphdmFTY3JpcHQuXG5cdFx0XHRzZXQuX3JhY3RpdmVXcmFwcGVycyA9IFsgb3JpZ2luYWxXcmFwcGVyIF07XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iamVjdCwgcHJvcGVydHksIHtcblx0XHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRcdHNldDogc2V0LFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0oIHJ1bmxvb3AsIGNyZWF0ZUJyYW5jaCwgaXNBcnJheSApO1xuXG5cdC8qIGNvbmZpZy9tYWdpYy5qcyAqL1xuXHR2YXIgbWFnaWMgPSBmdW5jdGlvbiggbWFnaWNBZGFwdG9yICkge1xuXG5cdFx0cmV0dXJuICEhbWFnaWNBZGFwdG9yO1xuXHR9KCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciApO1xuXG5cdC8qIGNvbmZpZy9uYW1lc3BhY2VzLmpzICovXG5cdHZhciBuYW1lc3BhY2VzID0ge1xuXHRcdGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcblx0XHRtYXRobWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyxcblx0XHRzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0eGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0XHR4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLFxuXHRcdHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG5cdH07XG5cblx0LyogdXRpbHMvY3JlYXRlRWxlbWVudC5qcyAqL1xuXHR2YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCBzdmcsIG5hbWVzcGFjZXMgKSB7XG5cblx0XHR2YXIgY3JlYXRlRWxlbWVudDtcblx0XHQvLyBUZXN0IGZvciBTVkcgc3VwcG9ydFxuXHRcdGlmICggIXN2ZyApIHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZSwgbnMgKSB7XG5cdFx0XHRcdGlmICggbnMgJiYgbnMgIT09IG5hbWVzcGFjZXMuaHRtbCApIHtcblx0XHRcdFx0XHR0aHJvdyAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbmFtZXNwYWNlcyBvdGhlciB0aGFuIGh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwuIFRoZSBtb3N0IGxpa2VseSBjYXVzZSBvZiB0aGlzIGVycm9yIGlzIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBTVkcgaW4gYW4gb2xkZXIgYnJvd3Nlci4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3N2Zy1hbmQtb2xkZXItYnJvd3NlcnMgZm9yIG1vcmUgaW5mb3JtYXRpb24nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0eXBlICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oIHR5cGUsIG5zICkge1xuXHRcdFx0XHRpZiAoICFucyB8fCBucyA9PT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggbnMsIHR5cGUgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50O1xuXHR9KCBzdmcsIG5hbWVzcGFjZXMgKTtcblxuXHQvKiBjb25maWcvaXNDbGllbnQuanMgKi9cblx0dmFyIGlzQ2xpZW50ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnO1xuXHRcdHJldHVybiBpc0NsaWVudDtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2RlZmluZVByb3BlcnR5LmpzICovXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBpc0NsaWVudCApIHtcblxuXHRcdHZhciBkZWZpbmVQcm9wZXJ0eTtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB7fSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoIGlzQ2xpZW50ICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICksICd0ZXN0Jywge1xuXHRcdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lc24ndCBleGlzdCwgb3Igd2UncmUgaW4gSUU4IHdoZXJlIHlvdSBjYW5cblx0XHRcdC8vIG9ubHkgdXNlIGl0IHdpdGggRE9NIG9iamVjdHMgKHdoYXQgdGhlIGZ1Y2sgd2VyZSB5b3Ugc21va2luZywgTVNGVD8pXG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBvYmosIHByb3AsIGRlc2MgKSB7XG5cdFx0XHRcdG9ialsgcHJvcCBdID0gZGVzYy52YWx1ZTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBkZWZpbmVQcm9wZXJ0eTtcblx0fSggaXNDbGllbnQgKTtcblxuXHQvKiB1dGlscy9kZWZpbmVQcm9wZXJ0aWVzLmpzICovXG5cdHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIGNyZWF0ZUVsZW1lbnQsIGRlZmluZVByb3BlcnR5LCBpc0NsaWVudCApIHtcblxuXHRcdHZhciBkZWZpbmVQcm9wZXJ0aWVzO1xuXHRcdHRyeSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcygge30sIHtcblx0XHRcdFx0XHR0ZXN0OiB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0Ly8gVE9ETyBob3cgZG8gd2UgYWNjb3VudCBmb3IgdGhpcz8gbm9NYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRocm93IGVycjtcblx0XHRcdH1cblx0XHRcdGlmICggaXNDbGllbnQgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBjcmVhdGVFbGVtZW50KCAnZGl2JyApLCB7XG5cdFx0XHRcdFx0dGVzdDoge1xuXHRcdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBvYmosIHByb3BzICkge1xuXHRcdFx0XHR2YXIgcHJvcDtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHRcdFx0XHRpZiAoIHByb3BzLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggb2JqLCBwcm9wLCBwcm9wc1sgcHJvcCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZGVmaW5lUHJvcGVydGllcztcblx0fSggY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIGlzQ2xpZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL2FkZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfYWRkID0gZnVuY3Rpb24oIGlzTnVtZXJpYyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhZGQoIHJvb3QsIGtleXBhdGgsIGQgKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyB8fCAhaXNOdW1lcmljKCBkICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0JhZCBhcmd1bWVudHMnICk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9ICtyb290LmdldCgga2V5cGF0aCApIHx8IDA7XG5cdFx0XHRpZiAoICFpc051bWVyaWMoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCBhZGQgdG8gYSBub24tbnVtZXJpYyB2YWx1ZScgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByb290LnNldCgga2V5cGF0aCwgdmFsdWUgKyBkICk7XG5cdFx0fTtcblx0fSggaXNOdW1lcmljICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYWRkLmpzICovXG5cdHZhciBSYWN0aXZlJGFkZCA9IGZ1bmN0aW9uKCBhZGQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRhZGQoIGtleXBhdGgsIGQgKSB7XG5cdFx0XHRyZXR1cm4gYWRkKCB0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAxIDogK2QgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9hZGQgKTtcblxuXHQvKiB1dGlscy9ub3JtYWxpc2VLZXlwYXRoLmpzICovXG5cdHZhciBub3JtYWxpc2VLZXlwYXRoID0gZnVuY3Rpb24oIG5vcm1hbGlzZVJlZiApIHtcblxuXHRcdHZhciBsZWFkaW5nRG90ID0gL15cXC4rLztcblx0XHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiBub3JtYWxpc2VSZWYoIGtleXBhdGggKS5yZXBsYWNlKCBsZWFkaW5nRG90LCAnJyApO1xuXHRcdH07XG5cdH0oIG5vcm1hbGlzZVJlZiApO1xuXG5cdC8qIGNvbmZpZy92ZW5kb3JzLmpzICovXG5cdHZhciB2ZW5kb3JzID0gW1xuXHRcdCdvJyxcblx0XHQnbXMnLFxuXHRcdCdtb3onLFxuXHRcdCd3ZWJraXQnXG5cdF07XG5cblx0LyogdXRpbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzICovXG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0Ly8gSWYgd2luZG93IGRvZXNuJ3QgZXhpc3QsIHdlIGRvbid0IG5lZWQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG5cdFx0XHQoIGZ1bmN0aW9uKCB2ZW5kb3JzLCBsYXN0VGltZSwgd2luZG93ICkge1xuXHRcdFx0XHR2YXIgeCwgc2V0VGltZW91dDtcblx0XHRcdFx0aWYgKCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3ggKSB7XG5cdFx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1sgdmVuZG9yc1sgeCBdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcblx0XHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJUaW1lLCB0aW1lVG9DYWxsLCBpZDtcblx0XHRcdFx0XHRcdGN1cnJUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRcdHRpbWVUb0NhbGwgPSBNYXRoLm1heCggMCwgMTYgLSAoIGN1cnJUaW1lIC0gbGFzdFRpbWUgKSApO1xuXHRcdFx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApO1xuXHRcdFx0XHRcdFx0fSwgdGltZVRvQ2FsbCApO1xuXHRcdFx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaWQ7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSggdmVuZG9ycywgMCwgd2luZG93ICkgKTtcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0fVxuXHRcdHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB1dGlscy9nZXRUaW1lLmpzICovXG5cdHZhciBnZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZ2V0VGltZTtcblx0XHRpZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIERhdGUubm93KCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZ2V0VGltZTtcblx0fSgpO1xuXG5cdC8qIHNoYXJlZC9hbmltYXRpb25zLmpzICovXG5cdHZhciBhbmltYXRpb25zID0gZnVuY3Rpb24oIHJBRiwgZ2V0VGltZSwgcnVubG9vcCApIHtcblxuXHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdHZhciBhbmltYXRpb25zID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpLCBhbmltYXRpb24sIG5vdztcblx0XHRcdFx0bm93ID0gZ2V0VGltZSgpO1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gcXVldWVbIGkgXTtcblx0XHRcdFx0XHRpZiAoICFhbmltYXRpb24udGljayggbm93ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBhbmltYXRpb24gaXMgY29tcGxldGUsIHJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgYW5kIGRlY3JlbWVudCBpIHNvIHdlIGRvbid0IG1pc3Mgb25lXG5cdFx0XHRcdFx0XHRxdWV1ZS5zcGxpY2UoIGktLSwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRpZiAoIHF1ZXVlLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyQUYoIGFuaW1hdGlvbnMudGljayApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YWRkOiBmdW5jdGlvbiggYW5pbWF0aW9uICkge1xuXHRcdFx0XHRxdWV1ZS5wdXNoKCBhbmltYXRpb24gKTtcblx0XHRcdFx0aWYgKCAhYW5pbWF0aW9ucy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IHRydWU7XG5cdFx0XHRcdFx0ckFGKCBhbmltYXRpb25zLnRpY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vIFRPRE8gb3B0aW1pc2UgdGhpc1xuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBrZXlwYXRoLCByb290ICkge1xuXHRcdFx0XHR2YXIgaSA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdFx0XHRhbmltYXRpb247XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBhbmltYXRpb24ucm9vdCA9PT0gcm9vdCAmJiBhbmltYXRpb24ua2V5cGF0aCA9PT0ga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0fSggcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBnZXRUaW1lLCBydW5sb29wICk7XG5cblx0LyogdXRpbHMvd2Fybi5qcyAqL1xuXHR2YXIgd2FybiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0LyogZ2xvYmFsIGNvbnNvbGUgKi9cblx0XHR2YXIgd2Fybiwgd2FybmVkID0ge307XG5cdFx0aWYgKCB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29uc29sZS53YXJuLmFwcGx5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0d2FybiA9IGZ1bmN0aW9uKCBtZXNzYWdlLCBhbGxvd0R1cGxpY2F0ZXMgKSB7XG5cdFx0XHRcdGlmICggIWFsbG93RHVwbGljYXRlcyApIHtcblx0XHRcdFx0XHRpZiAoIHdhcm5lZFsgbWVzc2FnZSBdICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3YXJuZWRbIG1lc3NhZ2UgXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3YXJuID0gZnVuY3Rpb24oKSB7fTtcblx0XHR9XG5cdFx0cmV0dXJuIHdhcm47XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9jc3MvdHJhbnNmb3JtLmpzICovXG5cdHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBzZWxlY3RvcnNQYXR0ZXJuID0gLyg/Ol58XFx9KT9cXHMqKFteXFx7XFx9XSspXFxzKlxcey9nLFxuXHRcdFx0Y29tbWVudHNQYXR0ZXJuID0gL1xcL1xcKi4qP1xcKlxcLy9nLFxuXHRcdFx0c2VsZWN0b3JVbml0UGF0dGVybiA9IC8oKD86KD86XFxbW15cXF0rXVxcXSl8KD86W15cXHNcXCtcXD5cXH46XSkpKykoKD86OlteXFxzXFwrXFw+XFx+XSspP1xccypbXFxzXFwrXFw+XFx+XT8pXFxzKi9nLFxuXHRcdFx0bWVkaWFRdWVyeVBhdHRlcm4gPSAvXkBtZWRpYS8sXG5cdFx0XHRkYXRhUnZjR3VpZFBhdHRlcm4gPSAvXFxbZGF0YS1ydmNndWlkPVwiW2EtejAtOS1dK1wiXS9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2Zvcm1Dc3MoIGNzcywgZ3VpZCApIHtcblx0XHRcdHZhciB0cmFuc2Zvcm1lZCwgYWRkR3VpZDtcblx0XHRcdGFkZEd1aWQgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHZhciBzZWxlY3RvclVuaXRzLCBtYXRjaCwgdW5pdCwgZGF0YUF0dHIsIGJhc2UsIHByZXBlbmRlZCwgYXBwZW5kZWQsIGksIHRyYW5zZm9ybWVkID0gW107XG5cdFx0XHRcdHNlbGVjdG9yVW5pdHMgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBtYXRjaCA9IHNlbGVjdG9yVW5pdFBhdHRlcm4uZXhlYyggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRzZWxlY3RvclVuaXRzLnB1c2goIHtcblx0XHRcdFx0XHRcdHN0cjogbWF0Y2hbIDAgXSxcblx0XHRcdFx0XHRcdGJhc2U6IG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRtb2RpZmllcnM6IG1hdGNoWyAyIF1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRm9yIGVhY2ggc2ltcGxlIHNlbGVjdG9yIHdpdGhpbiB0aGUgc2VsZWN0b3IsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdmVyc2lvblxuXHRcdFx0XHQvLyB0aGF0IGEpIGNvbWJpbmVzIHdpdGggdGhlIGd1aWQsIGFuZCBiKSBpcyBpbnNpZGUgdGhlIGd1aWRcblx0XHRcdFx0ZGF0YUF0dHIgPSAnW2RhdGEtcnZjZ3VpZD1cIicgKyBndWlkICsgJ1wiXSc7XG5cdFx0XHRcdGJhc2UgPSBzZWxlY3RvclVuaXRzLm1hcCggZXh0cmFjdFN0cmluZyApO1xuXHRcdFx0XHRpID0gc2VsZWN0b3JVbml0cy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGFwcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXHRcdFx0XHRcdC8vIFBzZXVkby1zZWxlY3RvcnMgc2hvdWxkIGdvIGFmdGVyIHRoZSBhdHRyaWJ1dGUgc2VsZWN0b3Jcblx0XHRcdFx0XHR1bml0ID0gc2VsZWN0b3JVbml0c1sgaSBdO1xuXHRcdFx0XHRcdGFwcGVuZGVkWyBpIF0gPSB1bml0LmJhc2UgKyBkYXRhQXR0ciArIHVuaXQubW9kaWZpZXJzIHx8ICcnO1xuXHRcdFx0XHRcdHByZXBlbmRlZCA9IGJhc2Uuc2xpY2UoKTtcblx0XHRcdFx0XHRwcmVwZW5kZWRbIGkgXSA9IGRhdGFBdHRyICsgJyAnICsgcHJlcGVuZGVkWyBpIF07XG5cdFx0XHRcdFx0dHJhbnNmb3JtZWQucHVzaCggYXBwZW5kZWQuam9pbiggJyAnICksIHByZXBlbmRlZC5qb2luKCAnICcgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cmFuc2Zvcm1lZC5qb2luKCAnLCAnICk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBkYXRhUnZjR3VpZFBhdHRlcm4udGVzdCggY3NzICkgKSB7XG5cdFx0XHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoIGRhdGFSdmNHdWlkUGF0dGVybiwgJ1tkYXRhLXJ2Y2d1aWQ9XCInICsgZ3VpZCArICdcIl0nICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKCBjb21tZW50c1BhdHRlcm4sICcnICkucmVwbGFjZSggc2VsZWN0b3JzUGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCAkMSApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0b3JzLCB0cmFuc2Zvcm1lZDtcblx0XHRcdFx0XHQvLyBkb24ndCB0cmFuc2Zvcm0gbWVkaWEgcXVlcmllcyFcblx0XHRcdFx0XHRpZiAoIG1lZGlhUXVlcnlQYXR0ZXJuLnRlc3QoICQxICkgKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHRcdHNlbGVjdG9ycyA9ICQxLnNwbGl0KCAnLCcgKS5tYXAoIHRyaW0gKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZCA9IHNlbGVjdG9ycy5tYXAoIGFkZEd1aWQgKS5qb2luKCAnLCAnICkgKyAnICc7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoLnJlcGxhY2UoICQxLCB0cmFuc2Zvcm1lZCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtZWQ7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRyaW0oIHN0ciApIHtcblx0XHRcdGlmICggc3RyLnRyaW0gKSB7XG5cdFx0XHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCAvXlxccysvLCAnJyApLnJlcGxhY2UoIC9cXHMrJC8sICcnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFN0cmluZyggdW5pdCApIHtcblx0XHRcdHJldHVybiB1bml0LnN0cjtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9jc3MvY3NzLmpzICovXG5cdHZhciBjc3MgPSBmdW5jdGlvbiggdHJhbnNmb3JtQ3NzICkge1xuXG5cdFx0dmFyIGNzc0NvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICdjc3MnLFxuXHRcdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBndWlkID0gcHJvdG8uY29uc3RydWN0b3IuX2d1aWQsXG5cdFx0XHRcdGNzcztcblx0XHRcdGlmICggY3NzID0gZ2V0Q3NzKCBvcHRpb25zLmNzcywgb3B0aW9ucywgZ3VpZCApIHx8IGdldENzcyggUGFyZW50LmNzcywgUGFyZW50LCBndWlkICkgKSB7XG5cdFx0XHRcdHByb3RvLmNvbnN0cnVjdG9yLmNzcyA9IGNzcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDc3MoIGNzcywgdGFyZ2V0LCBndWlkICkge1xuXHRcdFx0aWYgKCAhY3NzICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm5vQ3NzVHJhbnNmb3JtID8gY3NzIDogdHJhbnNmb3JtQ3NzKCBjc3MsIGd1aWQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNzc0NvbmZpZztcblx0fSggdHJhbnNmb3JtICk7XG5cblx0LyogdXRpbHMvd3JhcE1ldGhvZC5qcyAqL1xuXHR2YXIgd3JhcE1ldGhvZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBtZXRob2QsIHN1cGVyTWV0aG9kLCBmb3JjZSApIHtcblx0XHRcdGlmICggZm9yY2UgfHwgbmVlZHNTdXBlciggbWV0aG9kLCBzdXBlck1ldGhvZCApICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGhhc1N1cGVyID0gJ19zdXBlcicgaW4gdGhpcyxcblx0XHRcdFx0XHRcdF9zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cdFx0XHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRpZiAoIGhhc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBuZWVkc1N1cGVyKCBtZXRob2QsIHN1cGVyTWV0aG9kICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBzdXBlck1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyAmJiAvX3N1cGVyLy50ZXN0KCBtZXRob2QgKTtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9kYXRhLmpzICovXG5cdHZhciBkYXRhID0gZnVuY3Rpb24oIHdyYXAgKSB7XG5cblx0XHR2YXIgZGF0YUNvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICdkYXRhJyxcblx0XHRcdGV4dGVuZDogZXh0ZW5kLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlc2V0OiByZXNldFxuXHRcdH07XG5cdFx0cmV0dXJuIGRhdGFDb25maWc7XG5cblx0XHRmdW5jdGlvbiBjb21iaW5lKCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnMuZGF0YSB8fCB7fSxcblx0XHRcdFx0cGFyZW50VmFsdWUgPSBnZXRBZGRlZEtleXMoIFBhcmVudC5wcm90b3R5cGUuZGF0YSApO1xuXHRcdFx0cmV0dXJuIGRpc3BhdGNoKCBwYXJlbnRWYWx1ZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRwcm90by5kYXRhID0gY29tYmluZSggUGFyZW50LCBwcm90bywgb3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluaXQoIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnMuZGF0YSxcblx0XHRcdFx0cmVzdWx0ID0gY29tYmluZSggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHRpZiAoIHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jYWxsKCByYWN0aXZlLCB2YWx1ZSApIHx8IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJhY3RpdmUuZGF0YSA9IHJlc3VsdCB8fCB7fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNldCggcmFjdGl2ZSApIHtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmluaXQoIHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHJhY3RpdmUgKTtcblx0XHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0XHRyYWN0aXZlLmRhdGEgPSByZXN1bHQ7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEFkZGVkS2V5cyggcGFyZW50ICkge1xuXHRcdFx0Ly8gb25seSBmb3IgZnVuY3Rpb25zIHRoYXQgaGFkIGtleXMgYWRkZWRcblx0XHRcdGlmICggdHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyB8fCAhT2JqZWN0LmtleXMoIHBhcmVudCApLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHRcdH1cblx0XHRcdC8vIGNvcHkgdGhlIGFkZGVkIGtleXMgdG8gdGVtcCAnb2JqZWN0Jywgb3RoZXJ3aXNlXG5cdFx0XHQvLyBwYXJlbnQgd291bGQgYmUgaW50ZXJwcmV0ZWQgYXMgJ2Z1bmN0aW9uJyBieSBkaXNwYXRjaFxuXHRcdFx0dmFyIHRlbXAgPSB7fTtcblx0XHRcdGNvcHkoIHBhcmVudCwgdGVtcCApO1xuXHRcdFx0Ly8gcm9sbCBpbiBhZGRlZCBrZXlzXG5cdFx0XHRyZXR1cm4gZGlzcGF0Y2goIHBhcmVudCwgdGVtcCApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3BhdGNoKCBwYXJlbnQsIGNoaWxkICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBleHRlbmRGbiggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHBhcmVudCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGZyb21GbiggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZyb21Qcm9wZXJ0aWVzKCBjaGlsZCwgcGFyZW50ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29weSggZnJvbSwgdG8sIGZpbGxPbmx5ICkge1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBmcm9tICkge1xuXHRcdFx0XHRpZiAoIGZpbGxPbmx5ICYmIGtleSBpbiB0byApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b1sga2V5IF0gPSBmcm9tWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tUHJvcGVydGllcyggY2hpbGQsIHBhcmVudCApIHtcblx0XHRcdGNoaWxkID0gY2hpbGQgfHwge307XG5cdFx0XHRpZiAoICFwYXJlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGNvcHkoIHBhcmVudCwgY2hpbGQsIHRydWUgKTtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tRm4oIGNoaWxkLCBwYXJlbnRGbiApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0dmFyIGtleXM7XG5cdFx0XHRcdGlmICggY2hpbGQgKSB7XG5cdFx0XHRcdFx0Ly8gVHJhY2sgdGhlIGtleXMgdGhhdCBvdXIgb24gdGhlIGNoaWxkLFxuXHRcdFx0XHRcdC8vIGJ1dCBub3Qgb24gdGhlIGRhdGEuIFdlJ2xsIG5lZWQgdG8gYXBwbHkgdGhlc2Vcblx0XHRcdFx0XHQvLyBhZnRlciB0aGUgcGFyZW50IGZ1bmN0aW9uIHJldHVybnMuXG5cdFx0XHRcdFx0a2V5cyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2hpbGQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFkYXRhIHx8ICEoIGtleSBpbiBkYXRhICkgKSB7XG5cdFx0XHRcdFx0XHRcdGtleXMucHVzaCgga2V5ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNhbGwgdGhlIHBhcmVudCBmbiwgdXNlIGRhdGEgaWYgbm8gcmV0dXJuIHZhbHVlXG5cdFx0XHRcdGRhdGEgPSBwYXJlbnRGbi5jYWxsKCB0aGlzLCBkYXRhICkgfHwgZGF0YTtcblx0XHRcdFx0Ly8gQ29weSBjaGlsZCBrZXlzIGJhY2sgb250byBkYXRhLiBUaGUgY2hpbGQga2V5c1xuXHRcdFx0XHQvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgd2hhdGV2ZXIgdGhlXG5cdFx0XHRcdC8vIHBhcmVudCBkaWQgd2l0aCB0aGUgZGF0YS5cblx0XHRcdFx0aWYgKCBrZXlzICYmIGtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHRcdGRhdGFbIGtleSBdID0gY2hpbGRbIGtleSBdO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kRm4oIGNoaWxkRm4sIHBhcmVudCApIHtcblx0XHRcdHZhciBwYXJlbnRGbjtcblx0XHRcdGlmICggdHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gY29weSBwcm9wcyB0byBkYXRhXG5cdFx0XHRcdHBhcmVudEZuID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdFx0ZnJvbVByb3BlcnRpZXMoIGRhdGEsIHBhcmVudCApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyZW50Rm4gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHQvLyBnaXZlIHBhcmVudCBmdW5jdGlvbiBpdCdzIG93biB0aGlzLl9zdXBlciBjb250ZXh0LFxuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB0aGlzLl9zdXBlciBpcyBmcm9tIGNoaWxkIGFuZFxuXHRcdFx0XHRcdC8vIGNhdXNlcyBpbmZpbml0ZSBsb29wXG5cdFx0XHRcdFx0cGFyZW50ID0gd3JhcCggcGFyZW50LCBmdW5jdGlvbigpIHt9LCB0cnVlICk7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5jYWxsKCB0aGlzLCBkYXRhICkgfHwgZGF0YTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB3cmFwKCBjaGlsZEZuLCBwYXJlbnRGbiApO1xuXHRcdH1cblx0fSggd3JhcE1ldGhvZCApO1xuXG5cdC8qIGNvbmZpZy9lcnJvcnMuanMgKi9cblx0dmFyIGVycm9ycyA9IHtcblx0XHRtaXNzaW5nUGFyc2VyOiAnTWlzc2luZyBSYWN0aXZlLnBhcnNlIC0gY2Fubm90IHBhcnNlIHRlbXBsYXRlLiBFaXRoZXIgcHJlcGFyc2Ugb3IgdXNlIHRoZSB2ZXJzaW9uIHRoYXQgaW5jbHVkZXMgdGhlIHBhcnNlcicsXG5cdFx0bWVyZ2VDb21wYXJpc29uRmFpbDogJ01lcmdlIG9wZXJhdGlvbjogY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZycsXG5cdFx0bm9Db21wb25lbnRFdmVudEFyZ3VtZW50czogJ0NvbXBvbmVudHMgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBzaW1wbGUgZXZlbnRzIC0geW91IGNhbm5vdCBpbmNsdWRlIGFyZ3VtZW50cy4gU29ycnkhJyxcblx0XHRub1RlbXBsYXRlRm9yUGFydGlhbDogJ0NvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFwie25hbWV9XCInLFxuXHRcdG5vTmVzdGVkUGFydGlhbHM6ICdQYXJ0aWFscyAoe3s+e25hbWV9fX0pIGNhbm5vdCBjb250YWluIG5lc3RlZCBpbmxpbmUgcGFydGlhbHMnLFxuXHRcdGV2YWx1YXRpb25FcnJvcjogJ0Vycm9yIGV2YWx1YXRpbmcgXCJ7dW5pcXVlU3RyaW5nfVwiOiB7ZXJyfScsXG5cdFx0YmFkQXJndW1lbnRzOiAnQmFkIGFyZ3VtZW50cyBcInthcmd1bWVudHN9XCIuIElcXCdtIG5vdCBhbGxvd2VkIHRvIGFyZ3VlIHVubGVzcyB5b3VcXCd2ZSBwYWlkLicsXG5cdFx0ZmFpbGVkQ29tcHV0YXRpb246ICdGYWlsZWQgdG8gY29tcHV0ZSBcIntrZXl9XCI6IHtlcnJ9Jyxcblx0XHRtaXNzaW5nUGx1Z2luOiAnTWlzc2luZyBcIntuYW1lfVwiIHtwbHVnaW59IHBsdWdpbi4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEge3BsdWdpbn0gdmlhIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3BsdWdpbnMje3BsdWdpbn1zJyxcblx0XHRiYWRSYWRpb0lucHV0QmluZGluZzogJ0EgcmFkaW8gaW5wdXQgY2FuIGhhdmUgdHdvLXdheSBiaW5kaW5nIG9uIGl0cyBuYW1lIGF0dHJpYnV0ZSwgb3IgaXRzIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGgnLFxuXHRcdG5vUmVnaXN0cnlGdW5jdGlvblJldHVybjogJ0EgZnVuY3Rpb24gd2FzIHNwZWNpZmllZCBmb3IgXCJ7bmFtZX1cIiB7cmVnaXN0cnl9LCBidXQgbm8ge3JlZ2lzdHJ5fSB3YXMgcmV0dXJuZWQnXG5cdH07XG5cblx0LyogY29uZmlnL3R5cGVzLmpzICovXG5cdHZhciB0eXBlcyA9IHtcblx0XHRURVhUOiAxLFxuXHRcdElOVEVSUE9MQVRPUjogMixcblx0XHRUUklQTEU6IDMsXG5cdFx0U0VDVElPTjogNCxcblx0XHRJTlZFUlRFRDogNSxcblx0XHRDTE9TSU5HOiA2LFxuXHRcdEVMRU1FTlQ6IDcsXG5cdFx0UEFSVElBTDogOCxcblx0XHRDT01NRU5UOiA5LFxuXHRcdERFTElNQ0hBTkdFOiAxMCxcblx0XHRNVVNUQUNIRTogMTEsXG5cdFx0VEFHOiAxMixcblx0XHRBVFRSSUJVVEU6IDEzLFxuXHRcdENMT1NJTkdfVEFHOiAxNCxcblx0XHRDT01QT05FTlQ6IDE1LFxuXHRcdE5VTUJFUl9MSVRFUkFMOiAyMCxcblx0XHRTVFJJTkdfTElURVJBTDogMjEsXG5cdFx0QVJSQVlfTElURVJBTDogMjIsXG5cdFx0T0JKRUNUX0xJVEVSQUw6IDIzLFxuXHRcdEJPT0xFQU5fTElURVJBTDogMjQsXG5cdFx0R0xPQkFMOiAyNixcblx0XHRLRVlfVkFMVUVfUEFJUjogMjcsXG5cdFx0UkVGRVJFTkNFOiAzMCxcblx0XHRSRUZJTkVNRU5UOiAzMSxcblx0XHRNRU1CRVI6IDMyLFxuXHRcdFBSRUZJWF9PUEVSQVRPUjogMzMsXG5cdFx0QlJBQ0tFVEVEOiAzNCxcblx0XHRDT05ESVRJT05BTDogMzUsXG5cdFx0SU5GSVhfT1BFUkFUT1I6IDM2LFxuXHRcdElOVk9DQVRJT046IDQwLFxuXHRcdFNFQ1RJT05fSUY6IDUwLFxuXHRcdFNFQ1RJT05fVU5MRVNTOiA1MSxcblx0XHRTRUNUSU9OX0VBQ0g6IDUyLFxuXHRcdFNFQ1RJT05fV0lUSDogNTNcblx0fTtcblxuXHQvKiB1dGlscy9jcmVhdGUuanMgKi9cblx0dmFyIGNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGNyZWF0ZTtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0Ly8gc2lnaFxuXHRcdFx0Y3JlYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBGID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwcm90bywgcHJvcHMgKSB7XG5cdFx0XHRcdFx0dmFyIG9iajtcblx0XHRcdFx0XHRpZiAoIHByb3RvID09PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0XHRcdG9iaiA9IG5ldyBGKCk7XG5cdFx0XHRcdFx0aWYgKCBwcm9wcyApIHtcblx0XHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBvYmosIHByb3BzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH07XG5cdFx0XHR9KCk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGU7XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL2Vycm9ycy5qcyAqL1xuXHR2YXIgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgPSB7XG5cdFx0ZXhwZWN0ZWRFeHByZXNzaW9uOiAnRXhwZWN0ZWQgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24nLFxuXHRcdGV4cGVjdGVkUGFyZW46ICdFeHBlY3RlZCBjbG9zaW5nIHBhcmVuJ1xuXHR9O1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvbnVtYmVyTGl0ZXJhbC5qcyAqL1xuXHR2YXIgbnVtYmVyTGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdC8vIGJ1bGxldHByb29mIG51bWJlciByZWdleCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1JpY2gtSGFycmlzLzc1NDQzMzBcblx0XHR2YXIgbnVtYmVyUGF0dGVybiA9IC9eKD86WystXT8pKD86KD86KD86MHxbMS05XVxcZCopP1xcLlxcZCspfCg/Oig/OjB8WzEtOV1cXGQqKVxcLil8KD86MHxbMS05XVxcZCopKSg/OltlRV1bKy1dP1xcZCspPy87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYgKCByZXN1bHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBudW1iZXJQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuTlVNQkVSX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvYm9vbGVhbkxpdGVyYWwuanMgKi9cblx0dmFyIGJvb2xlYW5MaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgcmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCA0ICkgPT09ICd0cnVlJyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyArPSA0O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkJPT0xFQU5fTElURVJBTCxcblx0XHRcdFx0XHR2OiAndHJ1ZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggcmVtYWluaW5nLnN1YnN0ciggMCwgNSApID09PSAnZmFsc2UnICkge1xuXHRcdFx0XHRwYXJzZXIucG9zICs9IDU7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQk9PTEVBTl9MSVRFUkFMLFxuXHRcdFx0XHRcdHY6ICdmYWxzZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL21ha2VRdW90ZWRTdHJpbmdNYXRjaGVyLmpzICovXG5cdHZhciBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN0cmluZ01pZGRsZVBhdHRlcm4sIGVzY2FwZVNlcXVlbmNlUGF0dGVybiwgbGluZUNvbnRpbnVhdGlvblBhdHRlcm47XG5cdFx0Ly8gTWF0Y2ggb25lIG9yIG1vcmUgY2hhcmFjdGVycyB1bnRpbDogXCIsICcsIFxcLCBvciBFT0wvRU9GLlxuXHRcdC8vIEVPTC9FT0YgaXMgd3JpdHRlbiBhcyAoPyEuKSAobWVhbmluZyB0aGVyZSdzIG5vIG5vbi1uZXdsaW5lIGNoYXIgbmV4dCkuXG5cdFx0c3RyaW5nTWlkZGxlUGF0dGVybiA9IC9eKD89LilbXlwiJ1xcXFxdKz8oPzooPyEuKXwoPz1bXCInXFxcXF0pKS87XG5cdFx0Ly8gTWF0Y2ggb25lIGVzY2FwZSBzZXF1ZW5jZSwgaW5jbHVkaW5nIHRoZSBiYWNrc2xhc2guXG5cdFx0ZXNjYXBlU2VxdWVuY2VQYXR0ZXJuID0gL15cXFxcKD86WydcIlxcXFxiZm5ydF18MCg/IVswLTldKXx4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fCg/PS4pW151eDAtOV0pLztcblx0XHQvLyBNYXRjaCBvbmUgRVM1IGxpbmUgY29udGludWF0aW9uIChiYWNrc2xhc2ggKyBsaW5lIHRlcm1pbmF0b3IpLlxuXHRcdGxpbmVDb250aW51YXRpb25QYXR0ZXJuID0gL15cXFxcKD86XFxyXFxufFtcXHUwMDBBXFx1MDAwRFxcdTIwMjhcXHUyMDI5XSkvO1xuXHRcdC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgZ2V0RG91YmxlUXVvdGVkU3RyaW5nIGFuZCBnZXRTaW5nbGVRdW90ZWRTdHJpbmcuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBva1F1b3RlICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRcdHZhciBzdGFydCwgbGl0ZXJhbCwgZG9uZSwgbmV4dDtcblx0XHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRsaXRlcmFsID0gJ1wiJztcblx0XHRcdFx0ZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHR3aGlsZSAoICFkb25lICkge1xuXHRcdFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzdHJpbmdNaWRkbGVQYXR0ZXJuICkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybiggZXNjYXBlU2VxdWVuY2VQYXR0ZXJuICkgfHwgcGFyc2VyLm1hdGNoU3RyaW5nKCBva1F1b3RlICk7XG5cdFx0XHRcdFx0aWYgKCBuZXh0ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBuZXh0ID09PSAnXCInICkge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXFxcXCInO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gJ1xcXFxcXCcnICkge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXCcnO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSBuZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbGluZUNvbnRpbnVhdGlvblBhdHRlcm4gKTtcblx0XHRcdFx0XHRcdGlmICggbmV4dCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gY29udmVydCBcXChuZXdsaW5lLWxpa2UpIGludG8gYSBcXHUgZXNjYXBlLCB3aGljaCBpcyBhbGxvd2VkIGluIEpTT05cblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSAnXFxcXHUnICsgKCAnMDAwJyArIG5leHQuY2hhckNvZGVBdCggMSApLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC00ICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGl0ZXJhbCArPSAnXCInO1xuXHRcdFx0XHQvLyB1c2UgSlNPTi5wYXJzZSB0byBpbnRlcnByZXQgZXNjYXBlc1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSggbGl0ZXJhbCApO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL3NpbmdsZVF1b3RlZFN0cmluZy5qcyAqL1xuXHR2YXIgc2luZ2xlUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICkge1xuXG5cdFx0cmV0dXJuIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKCAnXCInICk7XG5cdH0oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL2RvdWJsZVF1b3RlZFN0cmluZy5qcyAqL1xuXHR2YXIgZG91YmxlUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICkge1xuXG5cdFx0cmV0dXJuIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKCAnXFwnJyApO1xuXHR9KCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9fc3RyaW5nTGl0ZXJhbC5qcyAqL1xuXHR2YXIgc3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLCBnZXREb3VibGVRdW90ZWRTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgc3RyaW5nO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdcIicgKSApIHtcblx0XHRcdFx0c3RyaW5nID0gZ2V0RG91YmxlUXVvdGVkU3RyaW5nKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXCInICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuU1RSSU5HX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogc3RyaW5nXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ1xcJycgKSApIHtcblx0XHRcdFx0c3RyaW5nID0gZ2V0U2luZ2xlUXVvdGVkU3RyaW5nKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXFwnJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlNUUklOR19MSVRFUkFMLFxuXHRcdFx0XHRcdHY6IHN0cmluZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMsIHNpbmdsZVF1b3RlZFN0cmluZywgZG91YmxlUXVvdGVkU3RyaW5nICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9wYXR0ZXJucy5qcyAqL1xuXHR2YXIgcGF0dGVybnMgPSB7XG5cdFx0bmFtZTogL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSovXG5cdH07XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9rZXkuanMgKi9cblx0dmFyIGtleSA9IGZ1bmN0aW9uKCBnZXRTdHJpbmdMaXRlcmFsLCBnZXROdW1iZXJMaXRlcmFsLCBwYXR0ZXJucyApIHtcblxuXHRcdHZhciBpZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSokLztcblx0XHQvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXByb3BlcnRpZXNcblx0XHQvLyBjYW4gYmUgYW55IG5hbWUsIHN0cmluZyBsaXRlcmFsLCBvciBudW1iZXIgbGl0ZXJhbFxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRva2VuO1xuXHRcdFx0aWYgKCB0b2tlbiA9IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApICkge1xuXHRcdFx0XHRyZXR1cm4gaWRlbnRpZmllci50ZXN0KCB0b2tlbi52ICkgPyB0b2tlbi52IDogJ1wiJyArIHRva2VuLnYucmVwbGFjZSggL1wiL2csICdcXFxcXCInICkgKyAnXCInO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0b2tlbiA9IGdldE51bWJlckxpdGVyYWwoIHBhcnNlciApICkge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW4udjtcblx0XHRcdH1cblx0XHRcdGlmICggdG9rZW4gPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwYXR0ZXJucy5uYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbjtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBzdHJpbmdMaXRlcmFsLCBudW1iZXJMaXRlcmFsLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9rZXlWYWx1ZVBhaXIuanMgKi9cblx0dmFyIGtleVZhbHVlUGFpciA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0S2V5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGtleSwgdmFsdWU7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJ3snIGFuZCBrZXlcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGtleSA9IGdldEtleSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIGtleSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBrZXkgYW5kICc6J1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSAnOidcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJzonIGFuZCB2YWx1ZVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gbmV4dCBleHByZXNzaW9uIG11c3QgYmUgYSwgd2VsbC4uLiBleHByZXNzaW9uXG5cdFx0XHR2YWx1ZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLktFWV9WQUxVRV9QQUlSLFxuXHRcdFx0XHRrOiBrZXksXG5cdFx0XHRcdHY6IHZhbHVlXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBrZXkgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL29iamVjdExpdGVyYWwva2V5VmFsdWVQYWlycy5qcyAqL1xuXHR2YXIga2V5VmFsdWVQYWlycyA9IGZ1bmN0aW9uKCBnZXRLZXlWYWx1ZVBhaXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0S2V5VmFsdWVQYWlycyggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBwYWlycywgcGFpciwga2V5VmFsdWVQYWlycztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhaXIgPSBnZXRLZXlWYWx1ZVBhaXIoIHBhcnNlciApO1xuXHRcdFx0aWYgKCBwYWlyID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXJzID0gWyBwYWlyIF07XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdGtleVZhbHVlUGFpcnMgPSBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAha2V5VmFsdWVQYWlycyApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhaXJzLmNvbmNhdCgga2V5VmFsdWVQYWlycyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhaXJzO1xuXHRcdH07XG5cdH0oIGtleVZhbHVlUGFpciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9fb2JqZWN0TGl0ZXJhbC5qcyAqL1xuXHR2YXIgb2JqZWN0TGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0S2V5VmFsdWVQYWlycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBrZXlWYWx1ZVBhaXJzO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAneycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGtleVZhbHVlUGFpcnMgPSBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKTtcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBmaW5hbCB2YWx1ZSBhbmQgJ30nXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuT0JKRUNUX0xJVEVSQUwsXG5cdFx0XHRcdG06IGtleVZhbHVlUGFpcnNcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGtleVZhbHVlUGFpcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL2V4cHJlc3Npb25MaXN0LmpzICovXG5cdHZhciBleHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uKCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbnMsIGV4cHIsIG5leHQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRleHByID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoIGV4cHIgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZXhwcmVzc2lvbnMgPSBbIGV4cHIgXTtcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBleHByZXNzaW9uIGFuZCAnLCdcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0bmV4dCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCBuZXh0ID09PSBudWxsICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQuZm9yRWFjaCggYXBwZW5kICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFwcGVuZCggZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0ZXhwcmVzc2lvbnMucHVzaCggZXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuXHRcdH07XG5cdH0oIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9hcnJheUxpdGVyYWwuanMgKi9cblx0dmFyIGFycmF5TGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0RXhwcmVzc2lvbkxpc3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSAnWydcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRleHByZXNzaW9uTGlzdCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5BUlJBWV9MSVRFUkFMLFxuXHRcdFx0XHRtOiBleHByZXNzaW9uTGlzdFxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgZXhwcmVzc2lvbkxpc3QgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL19saXRlcmFsLmpzICovXG5cdHZhciBsaXRlcmFsID0gZnVuY3Rpb24oIGdldE51bWJlckxpdGVyYWwsIGdldEJvb2xlYW5MaXRlcmFsLCBnZXRTdHJpbmdMaXRlcmFsLCBnZXRPYmplY3RMaXRlcmFsLCBnZXRBcnJheUxpdGVyYWwgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBsaXRlcmFsID0gZ2V0TnVtYmVyTGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0Qm9vbGVhbkxpdGVyYWwoIHBhcnNlciApIHx8IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApIHx8IGdldE9iamVjdExpdGVyYWwoIHBhcnNlciApIHx8IGdldEFycmF5TGl0ZXJhbCggcGFyc2VyICk7XG5cdFx0XHRyZXR1cm4gbGl0ZXJhbDtcblx0XHR9O1xuXHR9KCBudW1iZXJMaXRlcmFsLCBib29sZWFuTGl0ZXJhbCwgc3RyaW5nTGl0ZXJhbCwgb2JqZWN0TGl0ZXJhbCwgYXJyYXlMaXRlcmFsICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvcmVmZXJlbmNlLmpzICovXG5cdHZhciByZWZlcmVuY2UgPSBmdW5jdGlvbiggdHlwZXMsIHBhdHRlcm5zICkge1xuXG5cdFx0dmFyIGRvdFJlZmluZW1lbnRQYXR0ZXJuLCBhcnJheU1lbWJlclBhdHRlcm4sIGdldEFycmF5UmVmaW5lbWVudCwgZ2xvYmFscywga2V5d29yZHM7XG5cdFx0ZG90UmVmaW5lbWVudFBhdHRlcm4gPSAvXlxcLlthLXpBLVpfJDAtOV0rLztcblx0XHRnZXRBcnJheVJlZmluZW1lbnQgPSBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIG51bSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGFycmF5TWVtYmVyUGF0dGVybiApO1xuXHRcdFx0aWYgKCBudW0gKSB7XG5cdFx0XHRcdHJldHVybiAnLicgKyBudW07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdGFycmF5TWVtYmVyUGF0dGVybiA9IC9eXFxbKDB8WzEtOV1bMC05XSopXFxdLztcblx0XHQvLyBpZiBhIHJlZmVyZW5jZSBpcyBhIGJyb3dzZXIgZ2xvYmFsLCB3ZSBkb24ndCBkZWZlcmVuY2UgaXQgbGF0ZXIsIHNvIGl0IG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50XG5cdFx0Z2xvYmFscyA9IC9eKD86QXJyYXl8RGF0ZXxSZWdFeHB8ZGVjb2RlVVJJQ29tcG9uZW50fGRlY29kZVVSSXxlbmNvZGVVUklDb21wb25lbnR8ZW5jb2RlVVJJfGlzRmluaXRlfGlzTmFOfHBhcnNlRmxvYXR8cGFyc2VJbnR8SlNPTnxNYXRofE5hTnx1bmRlZmluZWR8bnVsbCkkLztcblx0XHQvLyBrZXl3b3JkcyBhcmUgbm90IHZhbGlkIHJlZmVyZW5jZXMsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgdGhpc2Bcblx0XHRrZXl3b3JkcyA9IC9eKD86YnJlYWt8Y2FzZXxjYXRjaHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fHJldHVybnxzd2l0Y2h8dGhyb3d8dHJ5fHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRoKSQvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0UG9zLCBhbmNlc3RvciwgbmFtZSwgZG90LCBjb21ibywgcmVmaW5lbWVudCwgbGFzdERvdEluZGV4O1xuXHRcdFx0c3RhcnRQb3MgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gd2UgbWlnaHQgaGF2ZSBhIHJvb3QtbGV2ZWwgcmVmZXJlbmNlXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ34vJyApICkge1xuXHRcdFx0XHRhbmNlc3RvciA9ICd+Lyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGFuY2VzdG9yIHJlZnMuLi5cblx0XHRcdFx0YW5jZXN0b3IgPSAnJztcblx0XHRcdFx0d2hpbGUgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcuLi8nICkgKSB7XG5cdFx0XHRcdFx0YW5jZXN0b3IgKz0gJy4uLyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIWFuY2VzdG9yICkge1xuXHRcdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGFuIGltcGxpY2l0IGl0ZXJhdG9yIG9yIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Vcblx0XHRcdFx0ZG90ID0gcGFyc2VyLm1hdGNoU3RyaW5nKCAnLicgKSB8fCAnJztcblx0XHRcdH1cblx0XHRcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCAvXkAoPzppbmRleHxrZXkpLyApIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBhdHRlcm5zLm5hbWUgKSB8fCAnJztcblx0XHRcdC8vIGJ1ZyBvdXQgaWYgaXQncyBhIGtleXdvcmRcblx0XHRcdGlmICgga2V5d29yZHMudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3M7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGJyb3dzZXIgZ2xvYmFsLCBzdG9wIGhlcmVcblx0XHRcdGlmICggIWFuY2VzdG9yICYmICFkb3QgJiYgZ2xvYmFscy50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuR0xPQkFMLFxuXHRcdFx0XHRcdHY6IG5hbWVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGNvbWJvID0gKCBhbmNlc3RvciB8fCBkb3QgKSArIG5hbWU7XG5cdFx0XHRpZiAoICFjb21ibyApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoIHJlZmluZW1lbnQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkb3RSZWZpbmVtZW50UGF0dGVybiApIHx8IGdldEFycmF5UmVmaW5lbWVudCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdGNvbWJvICs9IHJlZmluZW1lbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJygnICkgKSB7XG5cdFx0XHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgaW52b2NhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIGZ1bmN0aW9uKSB3ZSBuZWVkXG5cdFx0XHRcdC8vIHRvIHN0cmlwIHRoZSBtZXRob2QgbmFtZSBmcm9tIHRoZSByZWZlcmVuY2UgY29tYm8sIGVsc2UgdGhlIGNvbnRleHRcblx0XHRcdFx0Ly8gd2lsbCBiZSB3cm9uZ1xuXHRcdFx0XHRsYXN0RG90SW5kZXggPSBjb21iby5sYXN0SW5kZXhPZiggJy4nICk7XG5cdFx0XHRcdGlmICggbGFzdERvdEluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRjb21ibyA9IGNvbWJvLnN1YnN0ciggMCwgbGFzdERvdEluZGV4ICk7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zICsgY29tYm8ubGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgLT0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuUkVGRVJFTkNFLFxuXHRcdFx0XHRuOiBjb21iby5yZXBsYWNlKCAvXnRoaXNcXC4vLCAnLi8nICkucmVwbGFjZSggL150aGlzJC8sICcuJyApXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2JyYWNrZXRlZEV4cHJlc3Npb24uanMgKi9cblx0dmFyIGJyYWNrZXRlZEV4cHJlc3Npb24gPSBmdW5jdGlvbiggdHlwZXMsIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnKCcgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRleHByID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoICFleHByICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJyknICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkUGFyZW4gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLkJSQUNLRVRFRCxcblx0XHRcdFx0eDogZXhwclxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9fcHJpbWFyeS5qcyAqL1xuXHR2YXIgcHJpbWFyeSA9IGZ1bmN0aW9uKCBnZXRMaXRlcmFsLCBnZXRSZWZlcmVuY2UsIGdldEJyYWNrZXRlZEV4cHJlc3Npb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHJldHVybiBnZXRMaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRSZWZlcmVuY2UoIHBhcnNlciApIHx8IGdldEJyYWNrZXRlZEV4cHJlc3Npb24oIHBhcnNlciApO1xuXHRcdH07XG5cdH0oIGxpdGVyYWwsIHJlZmVyZW5jZSwgYnJhY2tldGVkRXhwcmVzc2lvbiApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvcmVmaW5lbWVudC5qcyAqL1xuXHR2YXIgcmVmaW5lbWVudCA9IGZ1bmN0aW9uKCB0eXBlcywgZXJyb3JzLCBwYXR0ZXJucyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRSZWZpbmVtZW50KCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIG5hbWUsIGV4cHI7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBcIi5cIiBuYW1lXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJy4nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0aWYgKCBuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggcGF0dGVybnMubmFtZSApICkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5SRUZJTkVNRU5ULFxuXHRcdFx0XHRcdFx0bjogbmFtZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gXCJbXCIgZXhwcmVzc2lvbiBcIl1cIlxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdbJyApICkge1xuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGV4cHIgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdFx0aWYgKCAhZXhwciApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgXFwnXVxcJycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlJFRklORU1FTlQsXG5cdFx0XHRcdFx0eDogZXhwclxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9tZW1iZXJPckludm9jYXRpb24uanMgKi9cblx0dmFyIG1lbWJlck9ySW52b2NhdGlvbiA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0UHJpbWFyeSwgZ2V0RXhwcmVzc2lvbkxpc3QsIGdldFJlZmluZW1lbnQsIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIGN1cnJlbnQsIGV4cHJlc3Npb24sIHJlZmluZW1lbnQsIGV4cHJlc3Npb25MaXN0O1xuXHRcdFx0ZXhwcmVzc2lvbiA9IGdldFByaW1hcnkoIHBhcnNlciApO1xuXHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoIGV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRpZiAoIHJlZmluZW1lbnQgPSBnZXRSZWZpbmVtZW50KCBwYXJzZXIgKSApIHtcblx0XHRcdFx0XHRleHByZXNzaW9uID0ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuTUVNQkVSLFxuXHRcdFx0XHRcdFx0eDogZXhwcmVzc2lvbixcblx0XHRcdFx0XHRcdHI6IHJlZmluZW1lbnRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcoJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRleHByZXNzaW9uTGlzdCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnKScgKSApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkUGFyZW4gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLklOVk9DQVRJT04sXG5cdFx0XHRcdFx0XHR4OiBleHByZXNzaW9uXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiAoIGV4cHJlc3Npb25MaXN0ICkge1xuXHRcdFx0XHRcdFx0ZXhwcmVzc2lvbi5vID0gZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcblx0XHR9O1xuXHR9KCB0eXBlcywgcHJpbWFyeSwgZXhwcmVzc2lvbkxpc3QsIHJlZmluZW1lbnQsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3R5cGVvZi5qcyAqL1xuXHR2YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKCB0eXBlcywgZXJyb3JzLCBnZXRNZW1iZXJPckludm9jYXRpb24gKSB7XG5cblx0XHR2YXIgZ2V0VHlwZW9mLCBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyO1xuXHRcdG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiggc3ltYm9sLCBmYWxsdGhyb3VnaCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0XHR2YXIgZXhwcmVzc2lvbjtcblx0XHRcdFx0aWYgKCBleHByZXNzaW9uID0gZmFsbHRocm91Z2goIHBhcnNlciApICkge1xuXHRcdFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggc3ltYm9sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRleHByZXNzaW9uID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRzOiBzeW1ib2wsXG5cdFx0XHRcdFx0bzogZXhwcmVzc2lvbixcblx0XHRcdFx0XHR0OiB0eXBlcy5QUkVGSVhfT1BFUkFUT1Jcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHQvLyBjcmVhdGUgYWxsIHByZWZpeCBzZXF1ZW5jZSBtYXRjaGVycywgcmV0dXJuIGdldFR5cGVvZlxuXHRcdCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBwcmVmaXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXHRcdFx0cHJlZml4T3BlcmF0b3JzID0gJyEgfiArIC0gdHlwZW9mJy5zcGxpdCggJyAnICk7XG5cdFx0XHRmYWxsdGhyb3VnaCA9IGdldE1lbWJlck9ySW52b2NhdGlvbjtcblx0XHRcdGZvciAoIGkgPSAwLCBsZW4gPSBwcmVmaXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG1hdGNoZXIgPSBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyKCBwcmVmaXhPcGVyYXRvcnNbIGkgXSwgZmFsbHRocm91Z2ggKTtcblx0XHRcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb24sIHNvIHByb3ZpZGVzIHRoZVxuXHRcdFx0Ly8gZmFsbHRocm91Z2ggZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBzZXF1ZW5jZSBtYXRjaGVyIHdlJ3JlIGFib3V0IHRvIGNyZWF0ZVxuXHRcdFx0Ly8gKHdlJ3JlIHNraXBwaW5nIHZvaWQgYW5kIGRlbGV0ZSlcblx0XHRcdGdldFR5cGVvZiA9IGZhbGx0aHJvdWdoO1xuXHRcdH0oKSApO1xuXHRcdHJldHVybiBnZXRUeXBlb2Y7XG5cdH0oIHR5cGVzLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycywgbWVtYmVyT3JJbnZvY2F0aW9uICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL2xvZ2ljYWxPci5qcyAqL1xuXHR2YXIgbG9naWNhbE9yID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRUeXBlb2YgKSB7XG5cblx0XHR2YXIgZ2V0TG9naWNhbE9yLCBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXI7XG5cdFx0bWFrZUluZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24oIHN5bWJvbCwgZmFsbHRocm91Z2ggKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdFx0dmFyIHN0YXJ0LCBsZWZ0LCByaWdodDtcblx0XHRcdFx0bGVmdCA9IGZhbGx0aHJvdWdoKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhbGVmdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBMb29wIHRvIGhhbmRsZSBsZWZ0LXJlY3Vyc2lvbiBpbiBhIGNhc2UgbGlrZSBgYSAqIGIgKiBjYCBhbmQgcHJvZHVjZVxuXHRcdFx0XHQvLyBsZWZ0IGFzc29jaWF0aW9uLCBpLmUuIGAoYSAqIGIpICogY2AuICBUaGUgbWF0Y2hlciBjYW4ndCBjYWxsIGl0c2VsZlxuXHRcdFx0XHQvLyB0byBwYXJzZSBgbGVmdGAgYmVjYXVzZSB0aGF0IHdvdWxkIGJlIGluZmluaXRlIHJlZ3Jlc3MuXG5cdFx0XHRcdHdoaWxlICggdHJ1ZSApIHtcblx0XHRcdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggc3ltYm9sICkgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW4gb3BlcmF0b3IgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgW2EtekEtWl8kMC05XVxuXHRcdFx0XHRcdGlmICggc3ltYm9sID09PSAnaW4nICYmIC9bYS16QS1aXyQwLTldLy50ZXN0KCBwYXJzZXIucmVtYWluaW5nKCkuY2hhckF0KCAwICkgKSApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdHJldHVybiBsZWZ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0Ly8gcmlnaHQgb3BlcmFuZCBtdXN0IGFsc28gY29uc2lzdCBvZiBvbmx5IGhpZ2hlci1wcmVjZWRlbmNlIG9wZXJhdG9yc1xuXHRcdFx0XHRcdHJpZ2h0ID0gZmFsbHRocm91Z2goIHBhcnNlciApO1xuXHRcdFx0XHRcdGlmICggIXJpZ2h0ICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxlZnQgPSB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5JTkZJWF9PUEVSQVRPUixcblx0XHRcdFx0XHRcdHM6IHN5bWJvbCxcblx0XHRcdFx0XHRcdG86IFtcblx0XHRcdFx0XHRcdFx0bGVmdCxcblx0XHRcdFx0XHRcdFx0cmlnaHRcblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Ly8gY3JlYXRlIGFsbCBpbmZpeCBzZXF1ZW5jZSBtYXRjaGVycywgYW5kIHJldHVybiBnZXRMb2dpY2FsT3Jcblx0XHQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGksIGxlbiwgbWF0Y2hlciwgaW5maXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXHRcdFx0Ly8gQWxsIHRoZSBpbmZpeCBvcGVyYXRvcnMgb24gb3JkZXIgb2YgcHJlY2VkZW5jZSAoc291cmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9PcGVyYXRvcl9QcmVjZWRlbmNlKVxuXHRcdFx0Ly8gRWFjaCBzZXF1ZW5jZSBtYXRjaGVyIHdpbGwgaW5pdGlhbGx5IGZhbGwgdGhyb3VnaCB0byBpdHMgaGlnaGVyIHByZWNlZGVuY2Vcblx0XHRcdC8vIG5laWdoYm91ciwgYW5kIG9ubHkgYXR0ZW1wdCB0byBtYXRjaCBpZiBvbmUgb2YgdGhlIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9yc1xuXHRcdFx0Ly8gKG9yLCB1bHRpbWF0ZWx5LCBhIGxpdGVyYWwsIHJlZmVyZW5jZSwgb3IgYnJhY2tldGVkIGV4cHJlc3Npb24pIGFscmVhZHkgbWF0Y2hlZFxuXHRcdFx0aW5maXhPcGVyYXRvcnMgPSAnKiAvICUgKyAtIDw8ID4+ID4+PiA8IDw9ID4gPj0gaW4gaW5zdGFuY2VvZiA9PSAhPSA9PT0gIT09ICYgXiB8ICYmIHx8Jy5zcGxpdCggJyAnICk7XG5cdFx0XHQvLyBBIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uXG5cdFx0XHRmYWxsdGhyb3VnaCA9IGdldFR5cGVvZjtcblx0XHRcdGZvciAoIGkgPSAwLCBsZW4gPSBpbmZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bWF0Y2hlciA9IG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlciggaW5maXhPcGVyYXRvcnNbIGkgXSwgZmFsbHRocm91Z2ggKTtcblx0XHRcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTG9naWNhbCBPUiBpcyB0aGUgZmFsbHRocm91Z2ggZm9yIHRoZSBjb25kaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRnZXRMb2dpY2FsT3IgPSBmYWxsdGhyb3VnaDtcblx0XHR9KCkgKTtcblx0XHRyZXR1cm4gZ2V0TG9naWNhbE9yO1xuXHR9KCB0eXBlcywgX3R5cGVvZiApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9jb25kaXRpb25hbC5qcyAqL1xuXHR2YXIgY29uZGl0aW9uYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldExvZ2ljYWxPciwgZXJyb3JzICkge1xuXG5cdFx0Ly8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciwgc28gd2Ugc3RhcnQgaGVyZVxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2U7XG5cdFx0XHRleHByZXNzaW9uID0gZ2V0TG9naWNhbE9yKCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmVHJ1ZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhaWZUcnVlICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIFwiOlwiJyApO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWZGYWxzZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhaWZGYWxzZSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5DT05ESVRJT05BTCxcblx0XHRcdFx0bzogW1xuXHRcdFx0XHRcdGV4cHJlc3Npb24sXG5cdFx0XHRcdFx0aWZUcnVlLFxuXHRcdFx0XHRcdGlmRmFsc2Vcblx0XHRcdFx0XVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgbG9naWNhbE9yLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci91dGlscy9mbGF0dGVuRXhwcmVzc2lvbi5qcyAqL1xuXHR2YXIgZmxhdHRlbkV4cHJlc3Npb24gPSBmdW5jdGlvbiggdHlwZXMsIGlzT2JqZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBleHByZXNzaW9uICkge1xuXHRcdFx0dmFyIHJlZnMgPSBbXSxcblx0XHRcdFx0ZmxhdHRlbmVkO1xuXHRcdFx0ZXh0cmFjdFJlZnMoIGV4cHJlc3Npb24sIHJlZnMgKTtcblx0XHRcdGZsYXR0ZW5lZCA9IHtcblx0XHRcdFx0cjogcmVmcyxcblx0XHRcdFx0czogc3RyaW5naWZ5KCB0aGlzLCBleHByZXNzaW9uLCByZWZzIClcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZmxhdHRlbmVkO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBxdW90ZVN0cmluZ0xpdGVyYWwoIHN0ciApIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggU3RyaW5nKCBzdHIgKSApO1xuXHRcdH1cblx0XHQvLyBUT0RPIG1heWJlIHJlZmFjdG9yIHRoaXM/XG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFJlZnMoIG5vZGUsIHJlZnMgKSB7XG5cdFx0XHR2YXIgaSwgbGlzdDtcblx0XHRcdGlmICggbm9kZS50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdGlmICggcmVmcy5pbmRleE9mKCBub2RlLm4gKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0cmVmcy51bnNoaWZ0KCBub2RlLm4gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGlzdCA9IG5vZGUubyB8fCBub2RlLm07XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggaXNPYmplY3QoIGxpc3QgKSApIHtcblx0XHRcdFx0XHRleHRyYWN0UmVmcyggbGlzdCwgcmVmcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGV4dHJhY3RSZWZzKCBsaXN0WyBpIF0sIHJlZnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS54ICkge1xuXHRcdFx0XHRleHRyYWN0UmVmcyggbm9kZS54LCByZWZzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUuciApIHtcblx0XHRcdFx0ZXh0cmFjdFJlZnMoIG5vZGUuciwgcmVmcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBub2RlLnYgKSB7XG5cdFx0XHRcdGV4dHJhY3RSZWZzKCBub2RlLnYsIHJlZnMgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZSwgcmVmcyApIHtcblx0XHRcdHZhciBzdHJpbmdpZnlBbGwgPSBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBpdGVtLCByZWZzICk7XG5cdFx0XHR9O1xuXHRcdFx0c3dpdGNoICggbm9kZS50ICkge1xuXHRcdFx0XHRjYXNlIHR5cGVzLkJPT0xFQU5fTElURVJBTDpcblx0XHRcdFx0Y2FzZSB0eXBlcy5HTE9CQUw6XG5cdFx0XHRcdGNhc2UgdHlwZXMuTlVNQkVSX0xJVEVSQUw6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUudjtcblx0XHRcdFx0Y2FzZSB0eXBlcy5TVFJJTkdfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gcXVvdGVTdHJpbmdMaXRlcmFsKCBub2RlLnYgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5BUlJBWV9MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiAnWycgKyAoIG5vZGUubSA/IG5vZGUubS5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICddJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5PQkpFQ1RfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gJ3snICsgKCBub2RlLm0gPyBub2RlLm0ubWFwKCBzdHJpbmdpZnlBbGwgKS5qb2luKCAnLCcgKSA6ICcnICkgKyAnfSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuS0VZX1ZBTFVFX1BBSVI6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuayArICc6JyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLnYsIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5QUkVGSVhfT1BFUkFUT1I6XG5cdFx0XHRcdFx0cmV0dXJuICggbm9kZS5zID09PSAndHlwZW9mJyA/ICd0eXBlb2YgJyA6IG5vZGUucyApICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUubywgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLklORklYX09QRVJBVE9SOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAwIF0sIHJlZnMgKSArICggbm9kZS5zLnN1YnN0ciggMCwgMiApID09PSAnaW4nID8gJyAnICsgbm9kZS5zICsgJyAnIDogbm9kZS5zICkgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAxIF0sIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5JTlZPQ0FUSU9OOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyAnKCcgKyAoIG5vZGUubyA/IG5vZGUuby5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICcpJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5CUkFDS0VURUQ6XG5cdFx0XHRcdFx0cmV0dXJuICcoJyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICcpJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5NRU1CRVI6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLnIsIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5SRUZJTkVNRU5UOlxuXHRcdFx0XHRcdHJldHVybiBub2RlLm4gPyAnLicgKyBub2RlLm4gOiAnWycgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyAnXSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQ09ORElUSU9OQUw6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDAgXSwgcmVmcyApICsgJz8nICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMSBdLCByZWZzICkgKyAnOicgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAyIF0sIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5SRUZFUkVOQ0U6XG5cdFx0XHRcdFx0cmV0dXJuICckeycgKyByZWZzLmluZGV4T2YoIG5vZGUubiApICsgJ30nO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGxlZ2FsIEphdmFTY3JpcHQnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCB0eXBlcywgaXNPYmplY3QgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvX1BhcnNlci5qcyAqL1xuXHR2YXIgUGFyc2VyID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBjcmVhdGUsIGhhc093blByb3BlcnR5LCBnZXRDb25kaXRpb25hbCwgZmxhdHRlbkV4cHJlc3Npb24gKSB7XG5cblx0XHR2YXIgUGFyc2VyLCBQYXJzZUVycm9yLCBsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy87XG5cdFx0UGFyc2VFcnJvciA9IGZ1bmN0aW9uKCBtZXNzYWdlICkge1xuXHRcdFx0dGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InO1xuXHRcdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cdFx0UGFyc2VyID0gZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBpdGVtcywgaXRlbTtcblx0XHRcdHRoaXMuc3RyID0gc3RyO1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdHRoaXMucG9zID0gMDtcblx0XHRcdC8vIEN1c3RvbSBpbml0IGxvZ2ljXG5cdFx0XHRpZiAoIHRoaXMuaW5pdCApXG5cdFx0XHRcdHRoaXMuaW5pdCggc3RyLCBvcHRpb25zICk7XG5cdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0d2hpbGUgKCB0aGlzLnBvcyA8IHRoaXMuc3RyLmxlbmd0aCAmJiAoIGl0ZW0gPSB0aGlzLnJlYWQoKSApICkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKCBpdGVtICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlZnRvdmVyID0gdGhpcy5yZW1haW5pbmcoKTtcblx0XHRcdHRoaXMucmVzdWx0ID0gdGhpcy5wb3N0UHJvY2VzcyA/IHRoaXMucG9zdFByb2Nlc3MoIGl0ZW1zLCBvcHRpb25zICkgOiBpdGVtcztcblx0XHR9O1xuXHRcdFBhcnNlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZWFkOiBmdW5jdGlvbiggY29udmVydGVycyApIHtcblx0XHRcdFx0dmFyIHBvcywgaSwgbGVuLCBpdGVtO1xuXHRcdFx0XHRpZiAoICFjb252ZXJ0ZXJzIClcblx0XHRcdFx0XHRjb252ZXJ0ZXJzID0gdGhpcy5jb252ZXJ0ZXJzO1xuXHRcdFx0XHRwb3MgPSB0aGlzLnBvcztcblx0XHRcdFx0bGVuID0gY29udmVydGVycy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgPSBwb3M7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgZm9yIGVhY2ggYXR0ZW1wdFxuXHRcdFx0XHRcdGlmICggaXRlbSA9IGNvbnZlcnRlcnNbIGkgXSggdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblx0XHRcdHJlYWRFeHByZXNzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciAoZXhjZXB0IHlpZWxkLFxuXHRcdFx0XHQvLyBhc3NpZ25tZW50IG9wZXJhdG9ycywgYW5kIGNvbW1hcywgbm9uZSBvZiB3aGljaCBhcmUgc3VwcG9ydGVkKSwgc28gd2Vcblx0XHRcdFx0Ly8gc3RhcnQgdGhlcmUuIElmIGl0IGRvZXNuJ3QgbWF0Y2gsIGl0ICdmYWxscyB0aHJvdWdoJyB0byBwcm9ncmVzc2l2ZWx5XG5cdFx0XHRcdC8vIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9ycywgdW50aWwgaXQgZXZlbnR1YWxseSBtYXRjaGVzIChvciBmYWlscyB0b1xuXHRcdFx0XHQvLyBtYXRjaCkgYSAncHJpbWFyeScgLSBhIGxpdGVyYWwgb3IgYSByZWZlcmVuY2UuIFRoaXMgd2F5LCB0aGUgYWJzdHJhY3Qgc3ludGF4XG5cdFx0XHRcdC8vIHRyZWUgaGFzIGV2ZXJ5dGhpbmcgaW4gaXRzIHByb3BlciBwbGFjZSwgaS5lLiAyICsgMyAqIDQgPT09IDE0LCBub3QgMjAuXG5cdFx0XHRcdHJldHVybiBnZXRDb25kaXRpb25hbCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGZsYXR0ZW5FeHByZXNzaW9uOiBmbGF0dGVuRXhwcmVzc2lvbixcblx0XHRcdGdldExpbmVQb3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbGluZXMsIGN1cnJlbnRMaW5lLCBjdXJyZW50TGluZUVuZCwgbmV4dExpbmVFbmQsIGxpbmVOdW0sIGNvbHVtbk51bTtcblx0XHRcdFx0bGluZXMgPSB0aGlzLnN0ci5zcGxpdCggJ1xcbicgKTtcblx0XHRcdFx0bGluZU51bSA9IC0xO1xuXHRcdFx0XHRuZXh0TGluZUVuZCA9IDA7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRjdXJyZW50TGluZUVuZCA9IG5leHRMaW5lRW5kO1xuXHRcdFx0XHRcdGxpbmVOdW0rKztcblx0XHRcdFx0XHRjdXJyZW50TGluZSA9IGxpbmVzWyBsaW5lTnVtIF07XG5cdFx0XHRcdFx0bmV4dExpbmVFbmQgKz0gY3VycmVudExpbmUubGVuZ3RoICsgMTtcblx0XHRcdFx0fSB3aGlsZSAoIG5leHRMaW5lRW5kIDw9IHRoaXMucG9zICk7XG5cdFx0XHRcdGNvbHVtbk51bSA9IHRoaXMucG9zIC0gY3VycmVudExpbmVFbmQ7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bGluZTogbGluZU51bSArIDEsXG5cdFx0XHRcdFx0Y2g6IGNvbHVtbk51bSArIDEsXG5cdFx0XHRcdFx0dGV4dDogY3VycmVudExpbmUsXG5cdFx0XHRcdFx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdHRoaXMubGluZSxcblx0XHRcdFx0XHRcdFx0dGhpcy5jaFxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiAnbGluZSAnICsgdGhpcy5saW5lICsgJyBjaGFyYWN0ZXIgJyArIHRoaXMuY2ggKyAnOlxcbicgKyB0aGlzLnRleHQgKyAnXFxuJyArIHRoaXMudGV4dC5zdWJzdHIoIDAsIHRoaXMuY2ggLSAxICkucmVwbGFjZSggL1tcXFNdL2csICcgJyApICsgJ14tLS0tJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKCBlcnIgKSB7XG5cdFx0XHRcdHZhciBwb3MsIG1lc3NhZ2U7XG5cdFx0XHRcdHBvcyA9IHRoaXMuZ2V0TGluZVBvcygpO1xuXHRcdFx0XHRtZXNzYWdlID0gZXJyICsgJyBhdCAnICsgcG9zO1xuXHRcdFx0XHR0aHJvdyBuZXcgUGFyc2VFcnJvciggbWVzc2FnZSApO1xuXHRcdFx0fSxcblx0XHRcdG1hdGNoU3RyaW5nOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc3RyLnN1YnN0ciggdGhpcy5wb3MsIHN0cmluZy5sZW5ndGggKSA9PT0gc3RyaW5nICkge1xuXHRcdFx0XHRcdHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1hdGNoUGF0dGVybjogZnVuY3Rpb24oIHBhdHRlcm4gKSB7XG5cdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0aWYgKCBtYXRjaCA9IHBhdHRlcm4uZXhlYyggdGhpcy5yZW1haW5pbmcoKSApICkge1xuXHRcdFx0XHRcdHRoaXMucG9zICs9IG1hdGNoWyAwIF0ubGVuZ3RoO1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaFsgMSBdIHx8IG1hdGNoWyAwIF07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhbGxvd1doaXRlc3BhY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm1hdGNoUGF0dGVybiggbGVhZGluZ1doaXRlc3BhY2UgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1haW5pbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIuc3Vic3RyaW5nKCB0aGlzLnBvcyApO1xuXHRcdFx0fSxcblx0XHRcdG5leHRDaGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyLmNoYXJBdCggdGhpcy5wb3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiggcHJvdG8gKSB7XG5cdFx0XHR2YXIgUGFyZW50ID0gdGhpcyxcblx0XHRcdFx0Q2hpbGQsIGtleTtcblx0XHRcdENoaWxkID0gZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdFx0UGFyc2VyLmNhbGwoIHRoaXMsIHN0ciwgb3B0aW9ucyApO1xuXHRcdFx0fTtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXHRcdFx0Zm9yICgga2V5IGluIHByb3RvICkge1xuXHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIHByb3RvLCBrZXkgKSApIHtcblx0XHRcdFx0XHRDaGlsZC5wcm90b3R5cGVbIGtleSBdID0gcHJvdG9bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRDaGlsZC5leHRlbmQgPSBQYXJzZXIuZXh0ZW5kO1xuXHRcdFx0cmV0dXJuIENoaWxkO1xuXHRcdH07XG5cdFx0Y2lyY3VsYXIuUGFyc2VyID0gUGFyc2VyO1xuXHRcdHJldHVybiBQYXJzZXI7XG5cdH0oIGNpcmN1bGFyLCBjcmVhdGUsIGhhc093biwgY29uZGl0aW9uYWwsIGZsYXR0ZW5FeHByZXNzaW9uICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9kZWxpbWl0ZXJDaGFuZ2UuanMgKi9cblx0dmFyIGRlbGltaXRlckNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gPSAvXlteXFxzPV0rLyxcblx0XHRcdHdoaXRlc3BhY2VQYXR0ZXJuID0gL15cXHMrLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgb3BlbmluZywgY2xvc2luZztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgbmV3IG9wZW5pbmcgZGVsaW1pdGVyXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRvcGVuaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhb3BlbmluZyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgKGluIGZhY3QsIGl0J3MgbmVjZXNzYXJ5Li4uKVxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoUGF0dGVybiggd2hpdGVzcGFjZVBhdHRlcm4gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRjbG9zaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhY2xvc2luZyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3NpbmcgJz0nXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0b3BlbmluZyxcblx0XHRcdFx0Y2xvc2luZ1xuXHRcdFx0XTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9kZWxpbWl0ZXJUeXBlcy5qcyAqL1xuXHR2YXIgZGVsaW1pdGVyVHlwZXMgPSBbIHtcblx0XHRkZWxpbWl0ZXJzOiAnZGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IGZhbHNlLFxuXHRcdGlzU3RhdGljOiBmYWxzZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3RyaXBsZURlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiB0cnVlLFxuXHRcdGlzU3RhdGljOiBmYWxzZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3N0YXRpY0RlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiBmYWxzZSxcblx0XHRpc1N0YXRpYzogdHJ1ZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3N0YXRpY1RyaXBsZURlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiB0cnVlLFxuXHRcdGlzU3RhdGljOiB0cnVlXG5cdH0gXTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL3R5cGUuanMgKi9cblx0dmFyIHR5cGUgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgbXVzdGFjaGVUeXBlcyA9IHtcblx0XHRcdCcjJzogdHlwZXMuU0VDVElPTixcblx0XHRcdCdeJzogdHlwZXMuSU5WRVJURUQsXG5cdFx0XHQnLyc6IHR5cGVzLkNMT1NJTkcsXG5cdFx0XHQnPic6IHR5cGVzLlBBUlRJQUwsXG5cdFx0XHQnISc6IHR5cGVzLkNPTU1FTlQsXG5cdFx0XHQnJic6IHR5cGVzLlRSSVBMRVxuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdHlwZSA9IG11c3RhY2hlVHlwZXNbIHBhcnNlci5zdHIuY2hhckF0KCBwYXJzZXIucG9zICkgXTtcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLnBvcyArPSAxO1xuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2hhbmRsZWJhcnNCbG9ja0NvZGVzLmpzICovXG5cdHZhciBoYW5kbGViYXJzQmxvY2tDb2RlcyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHQnaWYnOiB0eXBlcy5TRUNUSU9OX0lGLFxuXHRcdFx0J3VubGVzcyc6IHR5cGVzLlNFQ1RJT05fVU5MRVNTLFxuXHRcdFx0J3dpdGgnOiB0eXBlcy5TRUNUSU9OX1dJVEgsXG5cdFx0XHQnZWFjaCc6IHR5cGVzLlNFQ1RJT05fRUFDSFxuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogZW1wdHkvbGVnYWN5LmpzICovXG5cdHZhciBsZWdhY3kgPSBudWxsO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvY29udGVudC5qcyAqL1xuXHR2YXIgY29udGVudCA9IGZ1bmN0aW9uKCB0eXBlcywgbXVzdGFjaGVUeXBlLCBoYW5kbGViYXJzQmxvY2tDb2RlcyApIHtcblxuXHRcdHZhciBpbmRleFJlZlBhdHRlcm4gPSAvXlxccyo6XFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopLyxcblx0XHRcdGFycmF5TWVtYmVyUGF0dGVybiA9IC9eWzAtOV1bMS05XSokLyxcblx0XHRcdGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXignICsgT2JqZWN0LmtleXMoIGhhbmRsZWJhcnNCbG9ja0NvZGVzICkuam9pbiggJ3wnICkgKyAnKVxcXFxiJyApLFxuXHRcdFx0bGVnYWxSZWZlcmVuY2U7XG5cdFx0bGVnYWxSZWZlcmVuY2UgPSAvXlthLXpBLVokXzAtOV0rKD86KFxcLlthLXpBLVokXzAtOV0rKXwoXFxbW2EtekEtWiRfMC05XStcXF0pKSokLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApIHtcblx0XHRcdHZhciBzdGFydCwgcG9zLCBtdXN0YWNoZSwgdHlwZSwgYmxvY2ssIGV4cHJlc3Npb24sIGksIHJlbWFpbmluZywgaW5kZXgsIGRlbGltaXRlcnMsIHJlZmVyZW5jZUV4cHJlc3Npb247XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRtdXN0YWNoZSA9IHt9O1xuXHRcdFx0ZGVsaW1pdGVycyA9IHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF07XG5cdFx0XHRpZiAoIGRlbGltaXRlclR5cGUuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGV0ZXJtaW5lIG11c3RhY2hlIHR5cGVcblx0XHRcdGlmICggZGVsaW1pdGVyVHlwZS5pc1RyaXBsZSApIHtcblx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLlRSSVBMRTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gdGVzdCBmb3IgZXhwcmVzc2lvbnMgYmVmb3JlIHdlIHRlc3QgZm9yIG11c3RhY2hlIHR5cGUsIGJlY2F1c2Vcblx0XHRcdFx0Ly8gYW4gZXhwcmVzc2lvbiB0aGF0IGJlZ2lucyAnIScgbG9va3MgYSBsb3QgbGlrZSBhIGNvbW1lbnRcblx0XHRcdFx0aWYgKCBwYXJzZXIucmVtYWluaW5nKClbIDAgXSA9PT0gJyEnICYmICggZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpICkgKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdFx0XHQvLyBXYXMgaXQgYWN0dWFsbHkgYW4gZXhwcmVzc2lvbiwgb3IgYSBjb21tZW50IGJsb2NrIGluIGRpc2d1aXNlP1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggZGVsaW1pdGVyc1sgMSBdICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBleHByZXNzaW9uXG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zIC09IGRlbGltaXRlcnNbIDEgXS5sZW5ndGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGNvbW1lbnQgYmxvY2tcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdGV4cHJlc3Npb24gPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRcdHR5cGUgPSBtdXN0YWNoZVR5cGUoIHBhcnNlciApO1xuXHRcdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlIHx8IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdFx0XHQvLyBkZWZhdWx0XG5cdFx0XHRcdFx0Ly8gU2VlIGlmIHRoZXJlJ3MgYW4gZXhwbGljaXQgc2VjdGlvbiB0eXBlIGUuZy4ge3sjd2l0aH19Li4ue3svd2l0aH19XG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHRcdFx0aWYgKCBibG9jayA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gKSApIHtcblx0XHRcdFx0XHRcdFx0bXVzdGFjaGUubiA9IGJsb2NrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHR5cGVzLkNPTU1FTlQgfHwgdHlwZSA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdG11c3RhY2hlLnIgPSByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApO1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlXG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0Ly8gZ2V0IGV4cHJlc3Npb25cblx0XHRcdFx0ZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHQvLyBXaXRoIGNlcnRhaW4gdmFsaWQgcmVmZXJlbmNlcyB0aGF0IGFyZW4ndCB2YWxpZCBleHByZXNzaW9ucyxcblx0XHRcdFx0Ly8gZS5nLiB7ezEuZm9vfX0sIHdlIGhhdmUgYSBwcm9ibGVtOiBpdCBsb29rcyBsaWtlIHdlJ3ZlIGdvdCBhblxuXHRcdFx0XHQvLyBleHByZXNzaW9uLCBidXQgdGhlIGV4cHJlc3Npb24gZGlkbid0IGNvbnN1bWUgdGhlIGVudGlyZVxuXHRcdFx0XHQvLyByZWZlcmVuY2UuIFNvIHdlIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGUgbXVzdGFjaGUgZGVsaW1pdGVyc1xuXHRcdFx0XHQvLyBhcHBlYXIgbmV4dCwgdW5sZXNzIHRoZXJlJ3MgYW4gaW5kZXggcmVmZXJlbmNlIChpLmUuIGEgY29sb24pXG5cdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCBkZWxpbWl0ZXJzWyAxIF0ubGVuZ3RoICkgIT09IGRlbGltaXRlcnNbIDEgXSAmJiByZW1haW5pbmcuY2hhckF0KCAwICkgIT09ICc6JyApIHtcblx0XHRcdFx0XHRwb3MgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICk7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yID0gcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKS50cmltKCk7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpdCdzIGEgbGVnYWwgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRpZiAoICFsZWdhbFJlZmVyZW5jZS50ZXN0KCBtdXN0YWNoZS5yICkgKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGEgbGVnYWwgTXVzdGFjaGUgcmVmZXJlbmNlJyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdFx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBleHByZXNzaW9uICkge1xuXHRcdFx0XHR3aGlsZSAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuQlJBQ0tFVEVEICYmIGV4cHJlc3Npb24ueCApIHtcblx0XHRcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGludGVnZXJzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFycmF5IG1lbWJlcnMgcmVmZXJlbmNlcyxcblx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gYXMgZXhwcmVzc2lvbnMgaW4gdGhlaXIgb3duIHJpZ2h0XG5cdFx0XHRcdGlmICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24ubjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuTlVNQkVSX0xJVEVSQUwgJiYgYXJyYXlNZW1iZXJQYXR0ZXJuLnRlc3QoIGV4cHJlc3Npb24udiApICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24udjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCByZWZlcmVuY2VFeHByZXNzaW9uID0gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uICkgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yeCA9IHJlZmVyZW5jZUV4cHJlc3Npb247XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnggPSBwYXJzZXIuZmxhdHRlbkV4cHJlc3Npb24oIGV4cHJlc3Npb24gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIG9wdGlvbmFsIGluZGV4IHJlZmVyZW5jZVxuXHRcdFx0aWYgKCBpID0gcGFyc2VyLm1hdGNoUGF0dGVybiggaW5kZXhSZWZQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdG11c3RhY2hlLmkgPSBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdH07XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0aGlzISBpdCdzIGJld2lsZGVyaW5nXG5cdFx0ZnVuY3Rpb24gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uICkge1xuXHRcdFx0dmFyIG1lbWJlcnMgPSBbXSxcblx0XHRcdFx0cmVmaW5lbWVudDtcblx0XHRcdHdoaWxlICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5NRU1CRVIgJiYgZXhwcmVzc2lvbi5yLnQgPT09IHR5cGVzLlJFRklORU1FTlQgKSB7XG5cdFx0XHRcdHJlZmluZW1lbnQgPSBleHByZXNzaW9uLnI7XG5cdFx0XHRcdGlmICggcmVmaW5lbWVudC54ICkge1xuXHRcdFx0XHRcdGlmICggcmVmaW5lbWVudC54LnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcmVmaW5lbWVudC54ICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcGFyc2VyLmZsYXR0ZW5FeHByZXNzaW9uKCByZWZpbmVtZW50LnggKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQoIHJlZmluZW1lbnQubiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGV4cHJlc3Npb24udCAhPT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHI6IGV4cHJlc3Npb24ubixcblx0XHRcdFx0bTogbWVtYmVyc1xuXHRcdFx0fTtcblx0XHR9XG5cdH0oIHR5cGVzLCB0eXBlLCBoYW5kbGViYXJzQmxvY2tDb2RlcywgbGVnYWN5ICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS5qcyAqL1xuXHR2YXIgbXVzdGFjaGUgPSBmdW5jdGlvbiggdHlwZXMsIGRlbGltaXRlckNoYW5nZSwgZGVsaW1pdGVyVHlwZXMsIG11c3RhY2hlQ29udGVudCwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKSB7XG5cblx0XHR2YXIgZGVsaW1pdGVyQ2hhbmdlVG9rZW4gPSB7XG5cdFx0XHRcdHQ6IHR5cGVzLkRFTElNQ0hBTkdFLFxuXHRcdFx0XHRleGNsdWRlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlYmFyc0luZGV4UmVmUGF0dGVybiA9IC9eQCg/OmluZGV4fGtleSkkLztcblx0XHRyZXR1cm4gZ2V0TXVzdGFjaGU7XG5cblx0XHRmdW5jdGlvbiBnZXRNdXN0YWNoZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHR5cGVzO1xuXHRcdFx0dHlwZXMgPSBkZWxpbWl0ZXJUeXBlcy5zbGljZSgpLnNvcnQoIGZ1bmN0aW9uIGNvbXBhcmUoIGEsIGIgKSB7XG5cdFx0XHRcdC8vIFNvcnQgaW4gb3JkZXIgb2YgZGVzY2VuZGluZyBvcGVuaW5nIGRlbGltaXRlciBsZW5ndGggKGxvbmdlciBmaXJzdCksXG5cdFx0XHRcdC8vIHRvIHByb3RlY3QgYWdhaW5zdCBvcGVuaW5nIGRlbGltaXRlcnMgYmVpbmcgc3Vic3RyaW5ncyBvZiBlYWNoIG90aGVyXG5cdFx0XHRcdHJldHVybiBwYXJzZXJbIGIuZGVsaW1pdGVycyBdWyAwIF0ubGVuZ3RoIC0gcGFyc2VyWyBhLmRlbGltaXRlcnMgXVsgMCBdLmxlbmd0aDtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiByKCB0eXBlICkge1xuXHRcdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBnZXRNdXN0YWNoZU9mVHlwZSggcGFyc2VyLCB0eXBlICkgfHwgciggdHlwZXMuc2hpZnQoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KCB0eXBlcy5zaGlmdCgpICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TXVzdGFjaGVPZlR5cGUoIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApIHtcblx0XHRcdHZhciBzdGFydCwgc3RhcnRQb3MsIG11c3RhY2hlLCBkZWxpbWl0ZXJzLCBjaGlsZHJlbiwgZXhwZWN0ZWRDbG9zZSwgZWxzZUNoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIGNoaWxkLCBpbmRleFJlZjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHN0YXJ0UG9zID0gcGFyc2VyLmdldExpbmVQb3MoKTtcblx0XHRcdGRlbGltaXRlcnMgPSBwYXJzZXJbIGRlbGltaXRlclR5cGUuZGVsaW1pdGVycyBdO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAwIF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBkZWxpbWl0ZXIgY2hhbmdlP1xuXHRcdFx0aWYgKCBtdXN0YWNoZSA9IGRlbGltaXRlckNoYW5nZSggcGFyc2VyICkgKSB7XG5cdFx0XHRcdC8vIGZpbmQgY2xvc2luZyBkZWxpbWl0ZXIgb3IgYWJvcnQuLi5cblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAxIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyAuLi50aGVuIG1ha2UgdGhlIHN3aXRjaFxuXHRcdFx0XHRwYXJzZXJbIGRlbGltaXRlclR5cGUuZGVsaW1pdGVycyBdID0gbXVzdGFjaGU7XG5cdFx0XHRcdHJldHVybiBkZWxpbWl0ZXJDaGFuZ2VUb2tlbjtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdG11c3RhY2hlID0gbXVzdGFjaGVDb250ZW50KCBwYXJzZXIsIGRlbGltaXRlclR5cGUgKTtcblx0XHRcdGlmICggbXVzdGFjaGUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nIGRlbGltaXRlclxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAxIF0gKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgXFwnJyArIGRlbGltaXRlcnNbIDEgXSArICdcXCcgYWZ0ZXIgcmVmZXJlbmNlJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5DT01NRU5UICkge1xuXHRcdFx0XHRtdXN0YWNoZS5leGNsdWRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0cGFyc2VyLnNlY3Rpb25EZXB0aCAtPSAxO1xuXHRcdFx0XHRpZiAoIHBhcnNlci5zZWN0aW9uRGVwdGggPCAwICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdBdHRlbXB0ZWQgdG8gY2xvc2UgYSBzZWN0aW9uIHRoYXQgd2FzblxcJ3Qgb3BlbicgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gc2VjdGlvbiBjaGlsZHJlblxuXHRcdFx0aWYgKCBpc1NlY3Rpb24oIG11c3RhY2hlICkgKSB7XG5cdFx0XHRcdHBhcnNlci5zZWN0aW9uRGVwdGggKz0gMTtcblx0XHRcdFx0Y2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0Y3VycmVudENoaWxkcmVuID0gY2hpbGRyZW47XG5cdFx0XHRcdGV4cGVjdGVkQ2xvc2UgPSBtdXN0YWNoZS5uO1xuXHRcdFx0XHR3aGlsZSAoIGNoaWxkID0gcGFyc2VyLnJlYWQoKSApIHtcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGV4cGVjdGVkQ2xvc2UgJiYgY2hpbGQuciAhPT0gZXhwZWN0ZWRDbG9zZSApIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQge3svJyArIGV4cGVjdGVkQ2xvc2UgKyAnfX0nICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8ge3tlbHNlfX0gdGFncyByZXF1aXJlIHNwZWNpYWwgdHJlYXRtZW50XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5JTlRFUlBPTEFUT1IgJiYgY2hpbGQuciA9PT0gJ2Vsc2UnICkge1xuXHRcdFx0XHRcdFx0c3dpdGNoICggbXVzdGFjaGUubiApIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAndW5sZXNzJzpcblx0XHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICd7e2Vsc2V9fSBub3QgYWxsb3dlZCBpbiB7eyN1bmxlc3N9fScgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnd2l0aCc6XG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAne3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjd2l0aH19JyApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRDaGlsZHJlbiA9IGVsc2VDaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50Q2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5mID0gY2hpbGRyZW47XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiAnZWFjaCcgc2VjdGlvbiwgYW5kIGl0IGNvbnRhaW5zIGFuIHt7QGluZGV4fX0gb3Ige3tAa2V5fX0sXG5cdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBzZXQgdGhlIGluZGV4IHJlZmVyZW5jZSBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdGlmICggIW11c3RhY2hlLmkgJiYgbXVzdGFjaGUubiA9PT0gJ2VhY2gnICYmICggaW5kZXhSZWYgPSBoYW5kbGViYXJzSW5kZXhSZWYoIG11c3RhY2hlLmYgKSApICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuaSA9IGluZGV4UmVmO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsc2VDaGlsZHJlbiAmJiBlbHNlQ2hpbGRyZW4ubGVuZ3RoICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLmwgPSBlbHNlQ2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRtdXN0YWNoZS5wID0gc3RhcnRQb3MudG9KU09OKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZXBsYWNlIGJsb2NrIG5hbWUgd2l0aCBjb2RlXG5cdFx0XHRpZiAoIG11c3RhY2hlLm4gKSB7XG5cdFx0XHRcdG11c3RhY2hlLm4gPSBoYW5kbGViYXJzQmxvY2tDb2Rlc1sgbXVzdGFjaGUubiBdO1xuXHRcdFx0fSBlbHNlIGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuSU5WRVJURUQgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5TRUNUSU9OO1xuXHRcdFx0XHRtdXN0YWNoZS5uID0gdHlwZXMuU0VDVElPTl9VTkxFU1M7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlYmFyc0luZGV4UmVmKCBmcmFnbWVudCApIHtcblx0XHRcdHZhciBpLCBjaGlsZCwgaW5kZXhSZWY7XG5cdFx0XHRpID0gZnJhZ21lbnQubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGNoaWxkID0gZnJhZ21lbnRbIGkgXTtcblx0XHRcdFx0Ly8gUmVjdXJzZSBpbnRvIGVsZW1lbnRzIChidXQgbm90IHNlY3Rpb25zKVxuXHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLkVMRU1FTlQgJiYgY2hpbGQuZiAmJiAoIGluZGV4UmVmID0gaGFuZGxlYmFyc0luZGV4UmVmKCBjaGlsZC5mICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5kZXhSZWY7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTXVzdGFjaGU/XG5cdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuSU5URVJQT0xBVE9SIHx8IGNoaWxkLnQgPT09IHR5cGVzLlRSSVBMRSB8fCBjaGlsZC50ID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHRcdC8vIE5vcm1hbCByZWZlcmVuY2U/XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC5yICYmIGhhbmRsZWJhcnNJbmRleFJlZlBhdHRlcm4udGVzdCggY2hpbGQuciApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNoaWxkLnI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEV4cHJlc3Npb24/XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC54ICYmICggaW5kZXhSZWYgPSBpbmRleFJlZkNvbnRhaW5lZEluRXhwcmVzc2lvbiggY2hpbGQueCApICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaW5kZXhSZWY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFJlZmVyZW5jZSBleHByZXNzaW9uP1xuXHRcdFx0XHRcdGlmICggY2hpbGQucnggJiYgKCBpbmRleFJlZiA9IGluZGV4UmVmQ29udGFpbmVkSW5SZWZlcmVuY2VFeHByZXNzaW9uKCBjaGlsZC5yeCApICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaW5kZXhSZWY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5kZXhSZWZDb250YWluZWRJbkV4cHJlc3Npb24oIGV4cHJlc3Npb24gKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdGkgPSBleHByZXNzaW9uLnIubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggaGFuZGxlYmFyc0luZGV4UmVmUGF0dGVybi50ZXN0KCBleHByZXNzaW9uLnJbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiBleHByZXNzaW9uLnJbIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluZGV4UmVmQ29udGFpbmVkSW5SZWZlcmVuY2VFeHByZXNzaW9uKCByZWZlcmVuY2VFeHByZXNzaW9uICkge1xuXHRcdFx0dmFyIGksIGluZGV4UmVmLCBtZW1iZXI7XG5cdFx0XHRpID0gcmVmZXJlbmNlRXhwcmVzc2lvbi5tLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRtZW1iZXIgPSByZWZlcmVuY2VFeHByZXNzaW9uLm1bIGkgXTtcblx0XHRcdFx0aWYgKCBtZW1iZXIuciAmJiAoIGluZGV4UmVmID0gaW5kZXhSZWZDb250YWluZWRJbkV4cHJlc3Npb24oIG1lbWJlciApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluZGV4UmVmO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWVtYmVyLnQgPT09IHR5cGVzLlJFRkVSRU5DRSAmJiBoYW5kbGViYXJzSW5kZXhSZWZQYXR0ZXJuLnRlc3QoIG1lbWJlci5uICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1lbWJlci5uO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTZWN0aW9uKCBtdXN0YWNoZSApIHtcblx0XHRcdHJldHVybiBtdXN0YWNoZS50ID09PSB0eXBlcy5TRUNUSU9OIHx8IG11c3RhY2hlLnQgPT09IHR5cGVzLklOVkVSVEVEO1xuXHRcdH1cblx0fSggdHlwZXMsIGRlbGltaXRlckNoYW5nZSwgZGVsaW1pdGVyVHlwZXMsIGNvbnRlbnQsIGhhbmRsZWJhcnNCbG9ja0NvZGVzICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9jb21tZW50LmpzICovXG5cdHZhciBjb21tZW50ID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIE9QRU5fQ09NTUVOVCA9ICc8IS0tJyxcblx0XHRcdENMT1NFX0NPTU1FTlQgPSAnLS0+Jztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydFBvcywgY29udGVudCwgcmVtYWluaW5nLCBlbmRJbmRleCwgY29tbWVudDtcblx0XHRcdHN0YXJ0UG9zID0gcGFyc2VyLmdldExpbmVQb3MoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggT1BFTl9DT01NRU5UICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0ZW5kSW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggQ0xPU0VfQ09NTUVOVCApO1xuXHRcdFx0aWYgKCBlbmRJbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgSFRNTCAtIGV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCBzZXF1ZW5jZSAoXFwnLS0+XFwnKScgKTtcblx0XHRcdH1cblx0XHRcdGNvbnRlbnQgPSByZW1haW5pbmcuc3Vic3RyKCAwLCBlbmRJbmRleCApO1xuXHRcdFx0cGFyc2VyLnBvcyArPSBlbmRJbmRleCArIDM7XG5cdFx0XHRjb21tZW50ID0ge1xuXHRcdFx0XHR0OiB0eXBlcy5DT01NRU5ULFxuXHRcdFx0XHRjOiBjb250ZW50XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMgKSB7XG5cdFx0XHRcdGNvbW1lbnQucCA9IHN0YXJ0UG9zLnRvSlNPTigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbW1lbnQ7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBjb25maWcvdm9pZEVsZW1lbnROYW1lcy5qcyAqL1xuXHR2YXIgdm9pZEVsZW1lbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHZvaWRFbGVtZW50TmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxkb2N0eXBlfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC9pO1xuXHRcdHJldHVybiB2b2lkRWxlbWVudE5hbWVzO1xuXHR9KCk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy91dGlscy9nZXRMb3dlc3RJbmRleC5qcyAqL1xuXHR2YXIgZ2V0TG93ZXN0SW5kZXggPSBmdW5jdGlvbiggaGF5c3RhY2ssIG5lZWRsZXMgKSB7XG5cdFx0dmFyIGksIGluZGV4LCBsb3dlc3Q7XG5cdFx0aSA9IG5lZWRsZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0aW5kZXggPSBoYXlzdGFjay5pbmRleE9mKCBuZWVkbGVzWyBpIF0gKTtcblx0XHRcdC8vIHNob3J0IGNpcmN1aXRcblx0XHRcdGlmICggIWluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmICggIWxvd2VzdCB8fCBpbmRleCA8IGxvd2VzdCApIHtcblx0XHRcdFx0bG93ZXN0ID0gaW5kZXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsb3dlc3QgfHwgLTE7XG5cdH07XG5cblx0LyogcGFyc2UvY29udmVydGVycy91dGlscy9kZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzLmpzICovXG5cdHZhciBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaHRtbEVudGl0aWVzLCBjb250cm9sQ2hhcmFjdGVycywgbmFtZWRFbnRpdHlQYXR0ZXJuLCBoZXhFbnRpdHlQYXR0ZXJuLCBkZWNpbWFsRW50aXR5UGF0dGVybjtcblx0XHRodG1sRW50aXRpZXMgPSB7XG5cdFx0XHRxdW90OiAzNCxcblx0XHRcdGFtcDogMzgsXG5cdFx0XHRhcG9zOiAzOSxcblx0XHRcdGx0OiA2MCxcblx0XHRcdGd0OiA2Mixcblx0XHRcdG5ic3A6IDE2MCxcblx0XHRcdGlleGNsOiAxNjEsXG5cdFx0XHRjZW50OiAxNjIsXG5cdFx0XHRwb3VuZDogMTYzLFxuXHRcdFx0Y3VycmVuOiAxNjQsXG5cdFx0XHR5ZW46IDE2NSxcblx0XHRcdGJydmJhcjogMTY2LFxuXHRcdFx0c2VjdDogMTY3LFxuXHRcdFx0dW1sOiAxNjgsXG5cdFx0XHRjb3B5OiAxNjksXG5cdFx0XHRvcmRmOiAxNzAsXG5cdFx0XHRsYXF1bzogMTcxLFxuXHRcdFx0bm90OiAxNzIsXG5cdFx0XHRzaHk6IDE3Myxcblx0XHRcdHJlZzogMTc0LFxuXHRcdFx0bWFjcjogMTc1LFxuXHRcdFx0ZGVnOiAxNzYsXG5cdFx0XHRwbHVzbW46IDE3Nyxcblx0XHRcdHN1cDI6IDE3OCxcblx0XHRcdHN1cDM6IDE3OSxcblx0XHRcdGFjdXRlOiAxODAsXG5cdFx0XHRtaWNybzogMTgxLFxuXHRcdFx0cGFyYTogMTgyLFxuXHRcdFx0bWlkZG90OiAxODMsXG5cdFx0XHRjZWRpbDogMTg0LFxuXHRcdFx0c3VwMTogMTg1LFxuXHRcdFx0b3JkbTogMTg2LFxuXHRcdFx0cmFxdW86IDE4Nyxcblx0XHRcdGZyYWMxNDogMTg4LFxuXHRcdFx0ZnJhYzEyOiAxODksXG5cdFx0XHRmcmFjMzQ6IDE5MCxcblx0XHRcdGlxdWVzdDogMTkxLFxuXHRcdFx0QWdyYXZlOiAxOTIsXG5cdFx0XHRBYWN1dGU6IDE5Myxcblx0XHRcdEFjaXJjOiAxOTQsXG5cdFx0XHRBdGlsZGU6IDE5NSxcblx0XHRcdEF1bWw6IDE5Nixcblx0XHRcdEFyaW5nOiAxOTcsXG5cdFx0XHRBRWxpZzogMTk4LFxuXHRcdFx0Q2NlZGlsOiAxOTksXG5cdFx0XHRFZ3JhdmU6IDIwMCxcblx0XHRcdEVhY3V0ZTogMjAxLFxuXHRcdFx0RWNpcmM6IDIwMixcblx0XHRcdEV1bWw6IDIwMyxcblx0XHRcdElncmF2ZTogMjA0LFxuXHRcdFx0SWFjdXRlOiAyMDUsXG5cdFx0XHRJY2lyYzogMjA2LFxuXHRcdFx0SXVtbDogMjA3LFxuXHRcdFx0RVRIOiAyMDgsXG5cdFx0XHROdGlsZGU6IDIwOSxcblx0XHRcdE9ncmF2ZTogMjEwLFxuXHRcdFx0T2FjdXRlOiAyMTEsXG5cdFx0XHRPY2lyYzogMjEyLFxuXHRcdFx0T3RpbGRlOiAyMTMsXG5cdFx0XHRPdW1sOiAyMTQsXG5cdFx0XHR0aW1lczogMjE1LFxuXHRcdFx0T3NsYXNoOiAyMTYsXG5cdFx0XHRVZ3JhdmU6IDIxNyxcblx0XHRcdFVhY3V0ZTogMjE4LFxuXHRcdFx0VWNpcmM6IDIxOSxcblx0XHRcdFV1bWw6IDIyMCxcblx0XHRcdFlhY3V0ZTogMjIxLFxuXHRcdFx0VEhPUk46IDIyMixcblx0XHRcdHN6bGlnOiAyMjMsXG5cdFx0XHRhZ3JhdmU6IDIyNCxcblx0XHRcdGFhY3V0ZTogMjI1LFxuXHRcdFx0YWNpcmM6IDIyNixcblx0XHRcdGF0aWxkZTogMjI3LFxuXHRcdFx0YXVtbDogMjI4LFxuXHRcdFx0YXJpbmc6IDIyOSxcblx0XHRcdGFlbGlnOiAyMzAsXG5cdFx0XHRjY2VkaWw6IDIzMSxcblx0XHRcdGVncmF2ZTogMjMyLFxuXHRcdFx0ZWFjdXRlOiAyMzMsXG5cdFx0XHRlY2lyYzogMjM0LFxuXHRcdFx0ZXVtbDogMjM1LFxuXHRcdFx0aWdyYXZlOiAyMzYsXG5cdFx0XHRpYWN1dGU6IDIzNyxcblx0XHRcdGljaXJjOiAyMzgsXG5cdFx0XHRpdW1sOiAyMzksXG5cdFx0XHRldGg6IDI0MCxcblx0XHRcdG50aWxkZTogMjQxLFxuXHRcdFx0b2dyYXZlOiAyNDIsXG5cdFx0XHRvYWN1dGU6IDI0Myxcblx0XHRcdG9jaXJjOiAyNDQsXG5cdFx0XHRvdGlsZGU6IDI0NSxcblx0XHRcdG91bWw6IDI0Nixcblx0XHRcdGRpdmlkZTogMjQ3LFxuXHRcdFx0b3NsYXNoOiAyNDgsXG5cdFx0XHR1Z3JhdmU6IDI0OSxcblx0XHRcdHVhY3V0ZTogMjUwLFxuXHRcdFx0dWNpcmM6IDI1MSxcblx0XHRcdHV1bWw6IDI1Mixcblx0XHRcdHlhY3V0ZTogMjUzLFxuXHRcdFx0dGhvcm46IDI1NCxcblx0XHRcdHl1bWw6IDI1NSxcblx0XHRcdE9FbGlnOiAzMzgsXG5cdFx0XHRvZWxpZzogMzM5LFxuXHRcdFx0U2Nhcm9uOiAzNTIsXG5cdFx0XHRzY2Fyb246IDM1Myxcblx0XHRcdFl1bWw6IDM3Nixcblx0XHRcdGZub2Y6IDQwMixcblx0XHRcdGNpcmM6IDcxMCxcblx0XHRcdHRpbGRlOiA3MzIsXG5cdFx0XHRBbHBoYTogOTEzLFxuXHRcdFx0QmV0YTogOTE0LFxuXHRcdFx0R2FtbWE6IDkxNSxcblx0XHRcdERlbHRhOiA5MTYsXG5cdFx0XHRFcHNpbG9uOiA5MTcsXG5cdFx0XHRaZXRhOiA5MTgsXG5cdFx0XHRFdGE6IDkxOSxcblx0XHRcdFRoZXRhOiA5MjAsXG5cdFx0XHRJb3RhOiA5MjEsXG5cdFx0XHRLYXBwYTogOTIyLFxuXHRcdFx0TGFtYmRhOiA5MjMsXG5cdFx0XHRNdTogOTI0LFxuXHRcdFx0TnU6IDkyNSxcblx0XHRcdFhpOiA5MjYsXG5cdFx0XHRPbWljcm9uOiA5MjcsXG5cdFx0XHRQaTogOTI4LFxuXHRcdFx0UmhvOiA5MjksXG5cdFx0XHRTaWdtYTogOTMxLFxuXHRcdFx0VGF1OiA5MzIsXG5cdFx0XHRVcHNpbG9uOiA5MzMsXG5cdFx0XHRQaGk6IDkzNCxcblx0XHRcdENoaTogOTM1LFxuXHRcdFx0UHNpOiA5MzYsXG5cdFx0XHRPbWVnYTogOTM3LFxuXHRcdFx0YWxwaGE6IDk0NSxcblx0XHRcdGJldGE6IDk0Nixcblx0XHRcdGdhbW1hOiA5NDcsXG5cdFx0XHRkZWx0YTogOTQ4LFxuXHRcdFx0ZXBzaWxvbjogOTQ5LFxuXHRcdFx0emV0YTogOTUwLFxuXHRcdFx0ZXRhOiA5NTEsXG5cdFx0XHR0aGV0YTogOTUyLFxuXHRcdFx0aW90YTogOTUzLFxuXHRcdFx0a2FwcGE6IDk1NCxcblx0XHRcdGxhbWJkYTogOTU1LFxuXHRcdFx0bXU6IDk1Nixcblx0XHRcdG51OiA5NTcsXG5cdFx0XHR4aTogOTU4LFxuXHRcdFx0b21pY3JvbjogOTU5LFxuXHRcdFx0cGk6IDk2MCxcblx0XHRcdHJobzogOTYxLFxuXHRcdFx0c2lnbWFmOiA5NjIsXG5cdFx0XHRzaWdtYTogOTYzLFxuXHRcdFx0dGF1OiA5NjQsXG5cdFx0XHR1cHNpbG9uOiA5NjUsXG5cdFx0XHRwaGk6IDk2Nixcblx0XHRcdGNoaTogOTY3LFxuXHRcdFx0cHNpOiA5NjgsXG5cdFx0XHRvbWVnYTogOTY5LFxuXHRcdFx0dGhldGFzeW06IDk3Nyxcblx0XHRcdHVwc2loOiA5NzgsXG5cdFx0XHRwaXY6IDk4Mixcblx0XHRcdGVuc3A6IDgxOTQsXG5cdFx0XHRlbXNwOiA4MTk1LFxuXHRcdFx0dGhpbnNwOiA4MjAxLFxuXHRcdFx0enduajogODIwNCxcblx0XHRcdHp3ajogODIwNSxcblx0XHRcdGxybTogODIwNixcblx0XHRcdHJsbTogODIwNyxcblx0XHRcdG5kYXNoOiA4MjExLFxuXHRcdFx0bWRhc2g6IDgyMTIsXG5cdFx0XHRsc3F1bzogODIxNixcblx0XHRcdHJzcXVvOiA4MjE3LFxuXHRcdFx0c2JxdW86IDgyMTgsXG5cdFx0XHRsZHF1bzogODIyMCxcblx0XHRcdHJkcXVvOiA4MjIxLFxuXHRcdFx0YmRxdW86IDgyMjIsXG5cdFx0XHRkYWdnZXI6IDgyMjQsXG5cdFx0XHREYWdnZXI6IDgyMjUsXG5cdFx0XHRidWxsOiA4MjI2LFxuXHRcdFx0aGVsbGlwOiA4MjMwLFxuXHRcdFx0cGVybWlsOiA4MjQwLFxuXHRcdFx0cHJpbWU6IDgyNDIsXG5cdFx0XHRQcmltZTogODI0Myxcblx0XHRcdGxzYXF1bzogODI0OSxcblx0XHRcdHJzYXF1bzogODI1MCxcblx0XHRcdG9saW5lOiA4MjU0LFxuXHRcdFx0ZnJhc2w6IDgyNjAsXG5cdFx0XHRldXJvOiA4MzY0LFxuXHRcdFx0aW1hZ2U6IDg0NjUsXG5cdFx0XHR3ZWllcnA6IDg0NzIsXG5cdFx0XHRyZWFsOiA4NDc2LFxuXHRcdFx0dHJhZGU6IDg0ODIsXG5cdFx0XHRhbGVmc3ltOiA4NTAxLFxuXHRcdFx0bGFycjogODU5Mixcblx0XHRcdHVhcnI6IDg1OTMsXG5cdFx0XHRyYXJyOiA4NTk0LFxuXHRcdFx0ZGFycjogODU5NSxcblx0XHRcdGhhcnI6IDg1OTYsXG5cdFx0XHRjcmFycjogODYyOSxcblx0XHRcdGxBcnI6IDg2NTYsXG5cdFx0XHR1QXJyOiA4NjU3LFxuXHRcdFx0ckFycjogODY1OCxcblx0XHRcdGRBcnI6IDg2NTksXG5cdFx0XHRoQXJyOiA4NjYwLFxuXHRcdFx0Zm9yYWxsOiA4NzA0LFxuXHRcdFx0cGFydDogODcwNixcblx0XHRcdGV4aXN0OiA4NzA3LFxuXHRcdFx0ZW1wdHk6IDg3MDksXG5cdFx0XHRuYWJsYTogODcxMSxcblx0XHRcdGlzaW46IDg3MTIsXG5cdFx0XHRub3RpbjogODcxMyxcblx0XHRcdG5pOiA4NzE1LFxuXHRcdFx0cHJvZDogODcxOSxcblx0XHRcdHN1bTogODcyMSxcblx0XHRcdG1pbnVzOiA4NzIyLFxuXHRcdFx0bG93YXN0OiA4NzI3LFxuXHRcdFx0cmFkaWM6IDg3MzAsXG5cdFx0XHRwcm9wOiA4NzMzLFxuXHRcdFx0aW5maW46IDg3MzQsXG5cdFx0XHRhbmc6IDg3MzYsXG5cdFx0XHRhbmQ6IDg3NDMsXG5cdFx0XHRvcjogODc0NCxcblx0XHRcdGNhcDogODc0NSxcblx0XHRcdGN1cDogODc0Nixcblx0XHRcdCdpbnQnOiA4NzQ3LFxuXHRcdFx0dGhlcmU0OiA4NzU2LFxuXHRcdFx0c2ltOiA4NzY0LFxuXHRcdFx0Y29uZzogODc3Myxcblx0XHRcdGFzeW1wOiA4Nzc2LFxuXHRcdFx0bmU6IDg4MDAsXG5cdFx0XHRlcXVpdjogODgwMSxcblx0XHRcdGxlOiA4ODA0LFxuXHRcdFx0Z2U6IDg4MDUsXG5cdFx0XHRzdWI6IDg4MzQsXG5cdFx0XHRzdXA6IDg4MzUsXG5cdFx0XHRuc3ViOiA4ODM2LFxuXHRcdFx0c3ViZTogODgzOCxcblx0XHRcdHN1cGU6IDg4MzksXG5cdFx0XHRvcGx1czogODg1Myxcblx0XHRcdG90aW1lczogODg1NSxcblx0XHRcdHBlcnA6IDg4NjksXG5cdFx0XHRzZG90OiA4OTAxLFxuXHRcdFx0bGNlaWw6IDg5NjgsXG5cdFx0XHRyY2VpbDogODk2OSxcblx0XHRcdGxmbG9vcjogODk3MCxcblx0XHRcdHJmbG9vcjogODk3MSxcblx0XHRcdGxhbmc6IDkwMDEsXG5cdFx0XHRyYW5nOiA5MDAyLFxuXHRcdFx0bG96OiA5Njc0LFxuXHRcdFx0c3BhZGVzOiA5ODI0LFxuXHRcdFx0Y2x1YnM6IDk4MjcsXG5cdFx0XHRoZWFydHM6IDk4MjksXG5cdFx0XHRkaWFtczogOTgzMFxuXHRcdH07XG5cdFx0Y29udHJvbENoYXJhY3RlcnMgPSBbXG5cdFx0XHQ4MzY0LFxuXHRcdFx0MTI5LFxuXHRcdFx0ODIxOCxcblx0XHRcdDQwMixcblx0XHRcdDgyMjIsXG5cdFx0XHQ4MjMwLFxuXHRcdFx0ODIyNCxcblx0XHRcdDgyMjUsXG5cdFx0XHQ3MTAsXG5cdFx0XHQ4MjQwLFxuXHRcdFx0MzUyLFxuXHRcdFx0ODI0OSxcblx0XHRcdDMzOCxcblx0XHRcdDE0MSxcblx0XHRcdDM4MSxcblx0XHRcdDE0Myxcblx0XHRcdDE0NCxcblx0XHRcdDgyMTYsXG5cdFx0XHQ4MjE3LFxuXHRcdFx0ODIyMCxcblx0XHRcdDgyMjEsXG5cdFx0XHQ4MjI2LFxuXHRcdFx0ODIxMSxcblx0XHRcdDgyMTIsXG5cdFx0XHQ3MzIsXG5cdFx0XHQ4NDgyLFxuXHRcdFx0MzUzLFxuXHRcdFx0ODI1MCxcblx0XHRcdDMzOSxcblx0XHRcdDE1Nyxcblx0XHRcdDM4Mixcblx0XHRcdDM3NlxuXHRcdF07XG5cdFx0bmFtZWRFbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJyYoJyArIE9iamVjdC5rZXlzKCBodG1sRW50aXRpZXMgKS5qb2luKCAnfCcgKSArICcpOz8nLCAnZycgKTtcblx0XHRoZXhFbnRpdHlQYXR0ZXJuID0gLyYjeChbMC05XSspOz8vZztcblx0XHRkZWNpbWFsRW50aXR5UGF0dGVybiA9IC8mIyhbMC05XSspOz8vZztcblx0XHRyZXR1cm4gZnVuY3Rpb24gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyggaHRtbCApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cdFx0XHQvLyBuYW1lZCBlbnRpdGllc1xuXHRcdFx0cmVzdWx0ID0gaHRtbC5yZXBsYWNlKCBuYW1lZEVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwgbmFtZSApIHtcblx0XHRcdFx0aWYgKCBodG1sRW50aXRpZXNbIG5hbWUgXSApIHtcblx0XHRcdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSggaHRtbEVudGl0aWVzWyBuYW1lIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBoZXggcmVmZXJlbmNlc1xuXHRcdFx0cmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoIGhleEVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwgaGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSggdmFsaWRhdGVDb2RlKCBwYXJzZUludCggaGV4LCAxNiApICkgKTtcblx0XHRcdH0gKTtcblx0XHRcdC8vIGRlY2ltYWwgcmVmZXJlbmNlc1xuXHRcdFx0cmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoIGRlY2ltYWxFbnRpdHlQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsIGNoYXJDb2RlICkge1xuXHRcdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSggdmFsaWRhdGVDb2RlKCBjaGFyQ29kZSApICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0Ly8gc29tZSBjb2RlIHBvaW50cyBhcmUgdmVyYm90ZW4uIElmIHdlIHdlcmUgaW5zZXJ0aW5nIEhUTUwsIHRoZSBicm93c2VyIHdvdWxkIHJlcGxhY2UgdGhlIGlsbGVnYWxcblx0XHQvLyBjb2RlIHBvaW50cyB3aXRoIGFsdGVybmF0aXZlcyBpbiBzb21lIGNhc2VzIC0gc2luY2Ugd2UncmUgYnlwYXNzaW5nIHRoYXQgbWVjaGFuaXNtLCB3ZSBuZWVkXG5cdFx0Ly8gdG8gcmVwbGFjZSB0aGVtIG91cnNlbHZlc1xuXHRcdC8vXG5cdFx0Ly8gU291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYXJhY3Rlcl9lbmNvZGluZ3NfaW5fSFRNTCNJbGxlZ2FsX2NoYXJhY3RlcnNcblx0XHRmdW5jdGlvbiB2YWxpZGF0ZUNvZGUoIGNvZGUgKSB7XG5cdFx0XHRpZiAoICFjb2RlICkge1xuXHRcdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0XHR9XG5cdFx0XHQvLyBsaW5lIGZlZWQgYmVjb21lcyBnZW5lcmljIHdoaXRlc3BhY2Vcblx0XHRcdGlmICggY29kZSA9PT0gMTAgKSB7XG5cdFx0XHRcdHJldHVybiAzMjtcblx0XHRcdH1cblx0XHRcdC8vIEFTQ0lJIHJhbmdlLiAoV2h5IHNvbWVvbmUgd291bGQgdXNlIEhUTUwgZW50aXRpZXMgZm9yIEFTQ0lJIGNoYXJhY3RlcnMgSSBkb24ndCBrbm93LCBidXQuLi4pXG5cdFx0XHRpZiAoIGNvZGUgPCAxMjggKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29kZSBwb2ludHMgMTI4LTE1OSBhcmUgZGVhbHQgd2l0aCBsZW5pZW50bHkgYnkgYnJvd3NlcnMsIGJ1dCB0aGV5J3JlIGluY29ycmVjdC4gV2UgbmVlZFxuXHRcdFx0Ly8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cblx0XHRcdGlmICggY29kZSA8PSAxNTkgKSB7XG5cdFx0XHRcdHJldHVybiBjb250cm9sQ2hhcmFjdGVyc1sgY29kZSAtIDEyOCBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG5cdFx0XHRpZiAoIGNvZGUgPCA1NTI5NiApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHQvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuXHRcdFx0aWYgKCBjb2RlIDw9IDU3MzQzICkge1xuXHRcdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0XHR9XG5cdFx0XHQvLyByZXN0IG9mIHRoZSBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcblx0XHRcdGlmICggY29kZSA8PSA2NTUzNSApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0fVxuXHR9KCBsZWdhY3kgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL3RleHQuanMgKi9cblx0dmFyIHRleHQgPSBmdW5jdGlvbiggZ2V0TG93ZXN0SW5kZXgsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBpbmRleCwgcmVtYWluaW5nLCBkaXNhbGxvd2VkLCBiYXJyaWVyO1xuXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0YmFycmllciA9IHBhcnNlci5pbnNpZGUgPyAnPC8nICsgcGFyc2VyLmluc2lkZSA6ICc8Jztcblx0XHRcdGlmICggcGFyc2VyLmluc2lkZSAmJiAhcGFyc2VyLmludGVycG9sYXRlWyBwYXJzZXIuaW5zaWRlIF0gKSB7XG5cdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGJhcnJpZXIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FsbG93ZWQgPSBbXG5cdFx0XHRcdFx0YmFycmllcixcblx0XHRcdFx0XHRwYXJzZXIuZGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRcdHBhcnNlci50cmlwbGVEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdFx0cGFyc2VyLnN0YXRpY0RlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0XHRwYXJzZXIuc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sgMCBdXG5cdFx0XHRcdF07XG5cdFx0XHRcdC8vIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LWF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKCBwYXJzZXIuaW5BdHRyaWJ1dGUgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0Ly8gd2UncmUgaW5zaWRlIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVxuXHRcdFx0XHRcdGRpc2FsbG93ZWQucHVzaCggJ1wiJywgJ1xcJycsICc9JywgJz4nLCAnYCcgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggcGFyc2VyLmluQXR0cmlidXRlICkge1xuXHRcdFx0XHRcdGRpc2FsbG93ZWQucHVzaCggcGFyc2VyLmluQXR0cmlidXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleCggcmVtYWluaW5nLCBkaXNhbGxvd2VkICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdHJldHVybiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApICk7XG5cdFx0fTtcblx0fSggZ2V0TG93ZXN0SW5kZXgsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQvY2xvc2luZ1RhZy5qcyAqL1xuXHR2YXIgY2xvc2luZ1RhZyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBjbG9zaW5nVGFnUGF0dGVybiA9IC9eKFthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qKVxccypcXD4vO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRhZztcblx0XHRcdC8vIGFyZSB3ZSBsb29raW5nIGF0IGEgY2xvc2luZyB0YWc/XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc8LycgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRhZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGNsb3NpbmdUYWdQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQ0xPU0lOR19UQUcsXG5cdFx0XHRcdFx0ZTogdGFnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSBoYXZlIGFuIGlsbGVnYWwgY2xvc2luZyB0YWcsIHJlcG9ydCBpdFxuXHRcdFx0cGFyc2VyLnBvcyAtPSAyO1xuXHRcdFx0cGFyc2VyLmVycm9yKCAnSWxsZWdhbCBjbG9zaW5nIHRhZycgKTtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9hdHRyaWJ1dGUuanMgKi9cblx0dmFyIGF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBnZXRMb3dlc3RJbmRleCwgZ2V0TXVzdGFjaGUgKSB7XG5cblx0XHR2YXIgYXR0cmlidXRlTmFtZVBhdHRlcm4gPSAvXlteXFxzXCInPlxcLz1dKy8sXG5cdFx0XHR1bnF1b3RlZEF0dHJpYnV0ZVZhbHVlVGV4dFBhdHRlcm4gPSAvXlteXFxzXCInPTw+YF0rLztcblx0XHRyZXR1cm4gZ2V0QXR0cmlidXRlO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgYXR0ciwgbmFtZSwgdmFsdWU7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggYXR0cmlidXRlTmFtZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIW5hbWUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0YXR0ciA9IHtcblx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0fTtcblx0XHRcdHZhbHVlID0gZ2V0QXR0cmlidXRlVmFsdWUoIHBhcnNlciApO1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0YXR0ci52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGF0dHI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFsdWUoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgdmFsdWVTdGFydCwgc3RhcnREZXB0aCwgdmFsdWU7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0dmFsdWVTdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRzdGFydERlcHRoID0gcGFyc2VyLnNlY3Rpb25EZXB0aDtcblx0XHRcdHZhbHVlID0gZ2V0UXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciwgJ1xcJycgKSB8fCBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCAnXCInICkgfHwgZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIHBhcnNlci5zZWN0aW9uRGVwdGggIT09IHN0YXJ0RGVwdGggKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSB2YWx1ZVN0YXJ0O1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdBbiBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBjb250YWluIGFzIG1hbnkgb3BlbmluZyBzZWN0aW9uIHRhZ3MgYXMgY2xvc2luZyBzZWN0aW9uIHRhZ3MnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZhbHVlWyAwIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVbIDAgXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgdGV4dCwgaW5kZXg7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHR0ZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggdW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICF0ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggKCBpbmRleCA9IHRleHQuaW5kZXhPZiggcGFyc2VyLmRlbGltaXRlcnNbIDAgXSApICkgIT09IC0xICkge1xuXHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHIoIDAsIGluZGV4ICk7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRva2VucywgdG9rZW47XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSB0cnVlO1xuXHRcdFx0dG9rZW5zID0gW107XG5cdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4oIHBhcnNlciApO1xuXHRcdFx0d2hpbGUgKCB0b2tlbiAhPT0gbnVsbCApIHtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF0b2tlbnMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRva2Vucztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCBxdW90ZU1hcmsgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHRva2VucywgdG9rZW47XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHF1b3RlTWFyayApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHF1b3RlTWFyaztcblx0XHRcdHRva2VucyA9IFtdO1xuXHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0UXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICk7XG5cdFx0XHR3aGlsZSAoIHRva2VuICE9PSBudWxsICkge1xuXHRcdFx0XHR0b2tlbnMucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0UXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHF1b3RlTWFyayApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFF1b3RlZFN0cmluZ1Rva2VuKCBwYXJzZXIsIHF1b3RlTWFyayApIHtcblx0XHRcdHZhciBzdGFydCwgaW5kZXgsIHJlbWFpbmluZztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIHJlbWFpbmluZywgW1xuXHRcdFx0XHRxdW90ZU1hcmssXG5cdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAxIF1cblx0XHRcdF0gKTtcblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdRdW90ZWQgYXR0cmlidXRlIHZhbHVlIG11c3QgaGF2ZSBhIGNsb3NpbmcgcXVvdGUnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0cmV0dXJuIHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICk7XG5cdFx0fVxuXHR9KCBnZXRMb3dlc3RJbmRleCwgbXVzdGFjaGUgKTtcblxuXHQvKiB1dGlscy9wYXJzZUpTT04uanMgKi9cblx0dmFyIHBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBQYXJzZXIsIGdldFN0cmluZ0xpdGVyYWwsIGdldEtleSApIHtcblxuXHRcdC8vIHNpbXBsZSBKU09OIHBhcnNlciwgd2l0aG91dCB0aGUgcmVzdHJpY3Rpb25zIG9mIEpTT04gcGFyc2Vcblx0XHQvLyAoaS5lLiBoYXZpbmcgdG8gZG91YmxlLXF1b3RlIGtleXMpLlxuXHRcdC8vXG5cdFx0Ly8gSWYgcGFzc2VkIGEgaGFzaCBvZiB2YWx1ZXMgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgJHtwbGFjZWhvbGRlcnN9XG5cdFx0Ly8gd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRob3NlIHZhbHVlc1xuXHRcdHZhciBKc29uUGFyc2VyLCBzcGVjaWFscywgc3BlY2lhbHNQYXR0ZXJuLCBudW1iZXJQYXR0ZXJuLCBwbGFjZWhvbGRlclBhdHRlcm4sIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4sIG9ubHlXaGl0ZXNwYWNlO1xuXHRcdHNwZWNpYWxzID0ge1xuXHRcdFx0J3RydWUnOiB0cnVlLFxuXHRcdFx0J2ZhbHNlJzogZmFsc2UsXG5cdFx0XHQndW5kZWZpbmVkJzogdW5kZWZpbmVkLFxuXHRcdFx0J251bGwnOiBudWxsXG5cdFx0fTtcblx0XHRzcGVjaWFsc1BhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXig/OicgKyBPYmplY3Qua2V5cyggc3BlY2lhbHMgKS5qb2luKCAnfCcgKSArICcpJyApO1xuXHRcdG51bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KSg/Oig/Oig/OjB8WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuXHRcdHBsYWNlaG9sZGVyUGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcblx0XHRwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuID0gL15cXCRcXHsoW15cXH1dKylcXH0vO1xuXHRcdG9ubHlXaGl0ZXNwYWNlID0gL15cXHMqJC87XG5cdFx0SnNvblBhcnNlciA9IFBhcnNlci5leHRlbmQoIHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBzdHIsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG5cdFx0XHR9LFxuXHRcdFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uKCByZXN1bHQgKSB7XG5cdFx0XHRcdGlmICggcmVzdWx0Lmxlbmd0aCAhPT0gMSB8fCAhb25seVdoaXRlc3BhY2UudGVzdCggdGhpcy5sZWZ0b3ZlciApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHJlc3VsdFsgMCBdLnZcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRjb252ZXJ0ZXJzOiBbXG5cblx0XHRcdFx0ZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgcGxhY2Vob2xkZXI7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLnZhbHVlcyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwbGFjZWhvbGRlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gKTtcblx0XHRcdFx0XHRpZiAoIHBsYWNlaG9sZGVyICYmIHBhcnNlci52YWx1ZXMuaGFzT3duUHJvcGVydHkoIHBsYWNlaG9sZGVyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBwYXJzZXIudmFsdWVzWyBwbGFjZWhvbGRlciBdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0U3BlY2lhbCggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBzcGVjaWFsO1xuXHRcdFx0XHRcdGlmICggc3BlY2lhbCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHNwZWNpYWxzUGF0dGVybiApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogc3BlY2lhbHNbIHNwZWNpYWwgXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldE51bWJlciggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBudW1iZXI7XG5cdFx0XHRcdFx0aWYgKCBudW1iZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBudW1iZXJQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiArbnVtYmVyXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0U3RyaW5nKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHN0cmluZ0xpdGVyYWwgPSBnZXRTdHJpbmdMaXRlcmFsKCBwYXJzZXIgKSxcblx0XHRcdFx0XHRcdHZhbHVlcztcblx0XHRcdFx0XHRpZiAoIHN0cmluZ0xpdGVyYWwgJiYgKCB2YWx1ZXMgPSBwYXJzZXIudmFsdWVzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBzdHJpbmdMaXRlcmFsLnYucmVwbGFjZSggcGxhY2Vob2xkZXJQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAkMSBpbiB2YWx1ZXMgPyB2YWx1ZXNbICQxIF0gOiAkMTtcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nTGl0ZXJhbDtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0T2JqZWN0KCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCwgcGFpcjtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd7JyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ30nICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggcGFpciA9IGdldEtleVZhbHVlUGFpciggcGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRbIHBhaXIua2V5IF0gPSBwYWlyLnZhbHVlO1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRBcnJheSggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciByZXN1bHQsIHZhbHVlVG9rZW47XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goIHZhbHVlVG9rZW4udiApO1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSApO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0S2V5VmFsdWVQYWlyKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIga2V5LCB2YWx1ZVRva2VuLCBwYWlyO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0a2V5ID0gZ2V0S2V5KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWtleSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYWlyID0ge1xuXHRcdFx0XHRrZXk6IGtleVxuXHRcdFx0fTtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0dmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCk7XG5cdFx0XHRpZiAoICF2YWx1ZVRva2VuICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXIudmFsdWUgPSB2YWx1ZVRva2VuLnY7XG5cdFx0XHRyZXR1cm4gcGFpcjtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHIsIHZhbHVlcyApIHtcblx0XHRcdHZhciBwYXJzZXIgPSBuZXcgSnNvblBhcnNlciggc3RyLCB7XG5cdFx0XHRcdHZhbHVlczogdmFsdWVzXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcGFyc2VyLnJlc3VsdDtcblx0XHR9O1xuXHR9KCBQYXJzZXIsIHN0cmluZ0xpdGVyYWwsIGtleSApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9wcm9jZXNzRGlyZWN0aXZlLmpzICovXG5cdHZhciBwcm9jZXNzRGlyZWN0aXZlID0gZnVuY3Rpb24oIHBhcnNlSlNPTiApIHtcblxuXHRcdC8vIFRPRE8gY2xlYW4gdGhpcyB1cCwgaXQncyBzaG9ja2luZ1xuXHRcdHJldHVybiBmdW5jdGlvbiggdG9rZW5zICkge1xuXHRcdFx0dmFyIHJlc3VsdCwgdG9rZW4sIGNvbG9uSW5kZXgsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MsIHBhcnNlZDtcblx0XHRcdGlmICggdHlwZW9mIHRva2VucyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGlmICggdG9rZW5zLmluZGV4T2YoICc6JyApID09PSAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLnRyaW0oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b2tlbnMgPSBbIHRva2VucyBdO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRkaXJlY3RpdmVOYW1lID0gW107XG5cdFx0XHRkaXJlY3RpdmVBcmdzID0gW107XG5cdFx0XHR3aGlsZSAoIHRva2Vucy5sZW5ndGggKSB7XG5cdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRjb2xvbkluZGV4ID0gdG9rZW4uaW5kZXhPZiggJzonICk7XG5cdFx0XHRcdFx0aWYgKCBjb2xvbkluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gaXMgdGhlIGNvbG9uIHRoZSBmaXJzdCBjaGFyYWN0ZXI/XG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9uSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG5vXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCggdG9rZW4uc3Vic3RyKCAwLCBjb2xvbkluZGV4ICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGFueXRoaW5nIGFmdGVyIHRoZSBjb2xvbiBpbiB0aGlzIHRva2VuLCB0cmVhdFxuXHRcdFx0XHRcdFx0Ly8gaXQgYXMgdGhlIGZpcnN0IHRva2VuIG9mIHRoZSBkaXJlY3RpdmVBcmdzIGZyYWdtZW50XG5cdFx0XHRcdFx0XHRpZiAoIHRva2VuLmxlbmd0aCA+IGNvbG9uSW5kZXggKyAxICkge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3RpdmVBcmdzWyAwIF0gPSB0b2tlbi5zdWJzdHJpbmcoIGNvbG9uSW5kZXggKyAxICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkaXJlY3RpdmVBcmdzID0gZGlyZWN0aXZlQXJncy5jb25jYXQoIHRva2VucyApO1xuXHRcdFx0aWYgKCBkaXJlY3RpdmVBcmdzLmxlbmd0aCB8fCB0eXBlb2YgZGlyZWN0aXZlTmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0XHQvLyBUT0RPIGlzIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT8ganVzdCB1c2UgdGhlIGFycmF5XG5cdFx0XHRcdFx0bjogZGlyZWN0aXZlTmFtZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZU5hbWVbIDAgXSA9PT0gJ3N0cmluZycgPyBkaXJlY3RpdmVOYW1lWyAwIF0gOiBkaXJlY3RpdmVOYW1lXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggZGlyZWN0aXZlQXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZUFyZ3NbIDAgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCAnWycgKyBkaXJlY3RpdmVBcmdzWyAwIF0gKyAnXScgKTtcblx0XHRcdFx0XHRyZXN1bHQuYSA9IHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IGRpcmVjdGl2ZUFyZ3NbIDAgXS50cmltKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0LmQgPSBkaXJlY3RpdmVBcmdzO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgPSBkaXJlY3RpdmVOYW1lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9KCBwYXJzZUpTT04gKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQuanMgKi9cblx0dmFyIGVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZXMsIHZvaWRFbGVtZW50TmFtZXMsIGdldE11c3RhY2hlLCBnZXRDb21tZW50LCBnZXRUZXh0LCBnZXRDbG9zaW5nVGFnLCBnZXRBdHRyaWJ1dGUsIHByb2Nlc3NEaXJlY3RpdmUgKSB7XG5cblx0XHR2YXIgdGFnTmFtZVBhdHRlcm4gPSAvXlthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qLyxcblx0XHRcdHZhbGlkVGFnTmFtZUZvbGxvd2VyID0gL15bXFxzXFxuXFwvPl0vLFxuXHRcdFx0b25QYXR0ZXJuID0gL15vbi8sXG5cdFx0XHRwcm94eUV2ZW50UGF0dGVybiA9IC9eb24tKFthLXpBLVokX11bYS16QS1aJF8wLTlcXC1dKykkLyxcblx0XHRcdHJlc2VydmVkRXZlbnROYW1lcyA9IC9eKD86Y2hhbmdlfHJlc2V0fHRlYXJkb3dufHVwZGF0ZSkkLyxcblx0XHRcdGRpcmVjdGl2ZXMgPSB7XG5cdFx0XHRcdCdpbnRyby1vdXRybyc6ICd0MCcsXG5cdFx0XHRcdGludHJvOiAndDEnLFxuXHRcdFx0XHRvdXRybzogJ3QyJyxcblx0XHRcdFx0ZGVjb3JhdG9yOiAnbydcblx0XHRcdH0sXG5cdFx0XHRleGNsdWRlID0ge1xuXHRcdFx0XHRleGNsdWRlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0Y29udmVydGVycztcblx0XHQvLyBEaWZmZXJlbnQgc2V0IG9mIGNvbnZlcnRlcnMsIGJlY2F1c2UgdGhpcyB0aW1lIHdlJ3JlIGxvb2tpbmcgZm9yIGNsb3NpbmcgdGFnc1xuXHRcdGNvbnZlcnRlcnMgPSBbXG5cdFx0XHRnZXRNdXN0YWNoZSxcblx0XHRcdGdldENvbW1lbnQsXG5cdFx0XHRnZXRFbGVtZW50LFxuXHRcdFx0Z2V0VGV4dCxcblx0XHRcdGdldENsb3NpbmdUYWdcblx0XHRdO1xuXHRcdHJldHVybiBnZXRFbGVtZW50O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RWxlbWVudCggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBzdGFydFBvcywgZWxlbWVudCwgbG93ZXJDYXNlTmFtZSwgZGlyZWN0aXZlTmFtZSwgbWF0Y2gsIGFkZFByb3h5RXZlbnQsIGF0dHJpYnV0ZSwgZGlyZWN0aXZlLCBzZWxmQ2xvc2luZywgY2hpbGRyZW4sIGNoaWxkO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0c3RhcnRQb3MgPSBwYXJzZXIuZ2V0TGluZVBvcygpO1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5zaWRlICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzwnICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGNsb3NpbmcgdGFnLCBhYm9ydCBzdHJhaWdodCBhd2F5XG5cdFx0XHRpZiAoIHBhcnNlci5uZXh0Q2hhcigpID09PSAnLycgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudCA9IHtcblx0XHRcdFx0dDogdHlwZXMuRUxFTUVOVFxuXHRcdFx0fTtcblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRlbGVtZW50LnAgPSBzdGFydFBvcy50b0pTT04oKTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnIScgKSApIHtcblx0XHRcdFx0ZWxlbWVudC55ID0gMTtcblx0XHRcdH1cblx0XHRcdC8vIGVsZW1lbnQgbmFtZVxuXHRcdFx0ZWxlbWVudC5lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggdGFnTmFtZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIWVsZW1lbnQuZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIHdoaXRlc3BhY2UsIGNsb3Npbmcgc29saWR1cyBvciAnPidcblx0XHRcdGlmICggIXZhbGlkVGFnTmFtZUZvbGxvd2VyLnRlc3QoIHBhcnNlci5uZXh0Q2hhcigpICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgdGFnIG5hbWUnICk7XG5cdFx0XHR9XG5cdFx0XHRhZGRQcm94eUV2ZW50ID0gZnVuY3Rpb24oIG5hbWUsIGRpcmVjdGl2ZSApIHtcblx0XHRcdFx0dmFyIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmUubiB8fCBkaXJlY3RpdmU7XG5cdFx0XHRcdGlmICggcmVzZXJ2ZWRFdmVudE5hbWVzLnRlc3QoIGRpcmVjdGl2ZU5hbWUgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zIC09IGRpcmVjdGl2ZU5hbWUubGVuZ3RoO1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0Nhbm5vdCB1c2UgcmVzZXJ2ZWQgZXZlbnQgbmFtZXMgKGNoYW5nZSwgcmVzZXQsIHRlYXJkb3duLCB1cGRhdGUpJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQudlsgbmFtZSBdID0gZGlyZWN0aXZlO1xuXHRcdFx0fTtcblx0XHRcdC8vIGRpcmVjdGl2ZXMgYW5kIGF0dHJpYnV0ZXNcblx0XHRcdHdoaWxlICggYXR0cmlidXRlID0gZ2V0QXR0cmlidXRlKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Ly8gaW50cm8sIG91dHJvLCBkZWNvcmF0b3Jcblx0XHRcdFx0aWYgKCBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlc1sgYXR0cmlidXRlLm5hbWUgXSApIHtcblx0XHRcdFx0XHRlbGVtZW50WyBkaXJlY3RpdmVOYW1lIF0gPSBwcm9jZXNzRGlyZWN0aXZlKCBhdHRyaWJ1dGUudmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2ggPSBwcm94eUV2ZW50UGF0dGVybi5leGVjKCBhdHRyaWJ1dGUubmFtZSApICkge1xuXHRcdFx0XHRcdGlmICggIWVsZW1lbnQudiApXG5cdFx0XHRcdFx0XHRlbGVtZW50LnYgPSB7fTtcblx0XHRcdFx0XHRkaXJlY3RpdmUgPSBwcm9jZXNzRGlyZWN0aXZlKCBhdHRyaWJ1dGUudmFsdWUgKTtcblx0XHRcdFx0XHRhZGRQcm94eUV2ZW50KCBtYXRjaFsgMSBdLCBkaXJlY3RpdmUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgfHwgIW9uUGF0dGVybi50ZXN0KCBhdHRyaWJ1dGUubmFtZSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhZWxlbWVudC5hIClcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5hID0ge307XG5cdFx0XHRcdFx0XHRlbGVtZW50LmFbIGF0dHJpYnV0ZS5uYW1lIF0gPSBhdHRyaWJ1dGUudmFsdWUgfHwgMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3Npbmcgc29saWR1c1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gc2VsZi1jbG9zaW5nIHNvbGlkdXM/XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJy8nICkgKSB7XG5cdFx0XHRcdHNlbGZDbG9zaW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIGNsb3NpbmcgYW5nbGUgYnJhY2tldFxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPicgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRsb3dlckNhc2VOYW1lID0gZWxlbWVudC5lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZiAoICFzZWxmQ2xvc2luZyAmJiAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KCBlbGVtZW50LmUgKSApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaWYgd2Ugb3BlbiBhIHNjcmlwdCBlbGVtZW50LCBmdXJ0aGVyIHRhZ3Mgc2hvdWxkXG5cdFx0XHRcdC8vIGJlIGlnbm9yZWQgdW5sZXNzIHRoZXkncmUgYSBjbG9zaW5nIHNjcmlwdCBlbGVtZW50XG5cdFx0XHRcdGlmICggbG93ZXJDYXNlTmFtZSA9PT0gJ3NjcmlwdCcgfHwgbG93ZXJDYXNlTmFtZSA9PT0gJ3N0eWxlJyApIHtcblx0XHRcdFx0XHRwYXJzZXIuaW5zaWRlID0gbG93ZXJDYXNlTmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIGNoaWxkID0gcGFyc2VyLnJlYWQoIGNvbnZlcnRlcnMgKSApIHtcblx0XHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBjbG9zaW5nIHNlY3Rpb24gdGFnXG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuQ0xPU0lOR19UQUcgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRlbGVtZW50LmYgPSBjaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluc2lkZSA9IG51bGw7XG5cdFx0XHRpZiAoIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzICYmIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzLmluZGV4T2YoIGxvd2VyQ2FzZU5hbWUgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybiBleGNsdWRlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0fVxuXHR9KCB0eXBlcywgdm9pZEVsZW1lbnROYW1lcywgbXVzdGFjaGUsIGNvbW1lbnQsIHRleHQsIGNsb3NpbmdUYWcsIGF0dHJpYnV0ZSwgcHJvY2Vzc0RpcmVjdGl2ZSApO1xuXG5cdC8qIHBhcnNlL3V0aWxzL3RyaW1XaGl0ZXNwYWNlLmpzICovXG5cdHZhciB0cmltV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gL15bIFxcdFxcZlxcclxcbl0rLyxcblx0XHRcdHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBpdGVtcywgbGVhZGluZywgdHJhaWxpbmcgKSB7XG5cdFx0XHR2YXIgaXRlbTtcblx0XHRcdGlmICggbGVhZGluZyApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyAwIF07XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UoIGxlYWRpbmdXaGl0ZXNwYWNlLCAnJyApO1xuXHRcdFx0XHRcdGlmICggIWl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRpdGVtcy5zaGlmdCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgMCBdID0gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggdHJhaWxpbmcgKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKCB0cmFpbGluZ1doaXRlc3BhY2UsICcnICk7XG5cdFx0XHRcdFx0aWYgKCAhaXRlbSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnBvcCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdID0gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvdXRpbHMvc3RyaXBTdGFuZGFsb25lcy5qcyAqL1xuXHR2YXIgc3RyaXBTdGFuZGFsb25lcyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBsZWFkaW5nTGluZWJyZWFrID0gL15cXHMqXFxyP1xcbi8sXG5cdFx0XHR0cmFpbGluZ0xpbmVicmVhayA9IC9cXHI/XFxuXFxzKiQvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggaXRlbXMgKSB7XG5cdFx0XHR2YXIgaSwgY3VycmVudCwgYmFja09uZSwgYmFja1R3bywgbGFzdFNlY3Rpb25JdGVtO1xuXHRcdFx0Zm9yICggaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0Y3VycmVudCA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdGJhY2tPbmUgPSBpdGVtc1sgaSAtIDEgXTtcblx0XHRcdFx0YmFja1R3byA9IGl0ZW1zWyBpIC0gMiBdO1xuXHRcdFx0XHQvLyBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIGEgW3RleHRdW2NvbW1lbnRdW3RleHRdIHNlcXVlbmNlLi4uXG5cdFx0XHRcdGlmICggaXNTdHJpbmcoIGN1cnJlbnQgKSAmJiBpc0NvbW1lbnQoIGJhY2tPbmUgKSAmJiBpc1N0cmluZyggYmFja1R3byApICkge1xuXHRcdFx0XHRcdC8vIC4uLiBhbmQgdGhlIGNvbW1lbnQgaXMgYSBzdGFuZGFsb25lIChpLmUuIGxpbmUgYnJlYWtzIGVpdGhlciBzaWRlKS4uLlxuXHRcdFx0XHRcdGlmICggdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggYmFja1R3byApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudCApICkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uIHRoZW4gd2Ugd2FudCB0byByZW1vdmUgdGhlIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGZpcnN0IGxpbmUgYnJlYWtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIC0gMiBdID0gYmFja1R3by5yZXBsYWNlKCB0cmFpbGluZ0xpbmVicmVhaywgJ1xcbicgKTtcblx0XHRcdFx0XHRcdC8vIGFuZCB0aGUgbGVhZGluZyBsaW5lIGJyZWFrIG9mIHRoZSBzZWNvbmQgdGV4dCB0b2tlblxuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGN1cnJlbnQucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBwcmVjZWRlZCBieSBhIGxpbmVicmVhaywgYW5kXG5cdFx0XHRcdC8vIGl0cyBmaXJzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG5cdFx0XHRcdGlmICggaXNTZWN0aW9uKCBjdXJyZW50ICkgJiYgaXNTdHJpbmcoIGJhY2tPbmUgKSApIHtcblx0XHRcdFx0XHRpZiAoIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGJhY2tPbmUgKSAmJiBpc1N0cmluZyggY3VycmVudC5mWyAwIF0gKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoIGN1cnJlbnQuZlsgMCBdICkgKSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaSAtIDEgXSA9IGJhY2tPbmUucmVwbGFjZSggdHJhaWxpbmdMaW5lYnJlYWssICdcXG4nICk7XG5cdFx0XHRcdFx0XHRjdXJyZW50LmZbIDAgXSA9IGN1cnJlbnQuZlsgMCBdLnJlcGxhY2UoIGxlYWRpbmdMaW5lYnJlYWssICcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHRoZSBsYXN0IGl0ZW0gd2FzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIGZvbGxvd2VkIGJ5IGEgbGluZWJyZWFrLCBhbmRcblx0XHRcdFx0Ly8gaXRzIGxhc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuXHRcdFx0XHRpZiAoIGlzU3RyaW5nKCBjdXJyZW50ICkgJiYgaXNTZWN0aW9uKCBiYWNrT25lICkgKSB7XG5cdFx0XHRcdFx0bGFzdFNlY3Rpb25JdGVtID0gYmFja09uZS5mWyBiYWNrT25lLmYubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRcdGlmICggaXNTdHJpbmcoIGxhc3RTZWN0aW9uSXRlbSApICYmIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGxhc3RTZWN0aW9uSXRlbSApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudCApICkge1xuXHRcdFx0XHRcdFx0YmFja09uZS5mWyBiYWNrT25lLmYubGVuZ3RoIC0gMSBdID0gbGFzdFNlY3Rpb25JdGVtLnJlcGxhY2UoIHRyYWlsaW5nTGluZWJyZWFrLCAnXFxuJyApO1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGN1cnJlbnQucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTdHJpbmcoIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ29tbWVudCggaXRlbSApIHtcblx0XHRcdHJldHVybiBpdGVtLnQgPT09IHR5cGVzLkNPTU1FTlQgfHwgaXRlbS50ID09PSB0eXBlcy5ERUxJTUNIQU5HRTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1NlY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpdGVtLnQgPT09IHR5cGVzLlNFQ1RJT04gfHwgaXRlbS50ID09PSB0eXBlcy5JTlZFUlRFRCApICYmIGl0ZW0uZjtcblx0XHR9XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvX3BhcnNlLmpzICovXG5cdHZhciBwYXJzZSA9IGZ1bmN0aW9uKCB0eXBlcywgUGFyc2VyLCBtdXN0YWNoZSwgY29tbWVudCwgZWxlbWVudCwgdGV4dCwgdHJpbVdoaXRlc3BhY2UsIHN0cmlwU3RhbmRhbG9uZXMgKSB7XG5cblx0XHQvLyBSYWN0aXZlLnBhcnNlXG5cdFx0Ly8gPT09PT09PT09PT09PT09XG5cdFx0Ly9cblx0XHQvLyBUYWtlcyBpbiBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcGFyc2VkIHRlbXBsYXRlLlxuXHRcdC8vIEEgcGFyc2VkIHRlbXBsYXRlIGlzIGFuIGFycmF5IG9mIDEgb3IgbW9yZSAndGVtcGxhdGVzJywgd2hpY2ggaW4gc29tZVxuXHRcdC8vIGNhc2VzIGhhdmUgY2hpbGRyZW4uXG5cdFx0Ly9cblx0XHQvLyBUaGUgZm9ybWF0IGlzIG9wdGltaXNlZCBmb3Igc2l6ZSwgbm90IHJlYWRhYmlsaXR5LCBob3dldmVyIGZvciByZWZlcmVuY2UgdGhlXG5cdFx0Ly8ga2V5cyBmb3IgZWFjaCB0ZW1wbGF0ZSBhcmUgYXMgZm9sbG93czpcblx0XHQvL1xuXHRcdC8vICogciAtIFJlZmVyZW5jZSwgZS5nLiAnbXVzdGFjaGUnIGluIHt7bXVzdGFjaGV9fVxuXHRcdC8vICogdCAtIFR5cGUgY29kZSAoZS5nLiAxIGlzIHRleHQsIDIgaXMgaW50ZXJwb2xhdG9yLi4uKVxuXHRcdC8vICogZiAtIEZyYWdtZW50LiBDb250YWlucyBhIHRlbXBsYXRlJ3MgY2hpbGRyZW5cblx0XHQvLyAqIGwgLSBlTHNlIGZyYWdtZW50LiBDb250YWlucyBhIHRlbXBsYXRlJ3MgY2hpbGRyZW4gaW4gdGhlIGVsc2UgY2FzZVxuXHRcdC8vICogZSAtIEVsZW1lbnQgbmFtZVxuXHRcdC8vICogYSAtIG1hcCBvZiBlbGVtZW50IEF0dHJpYnV0ZXMsIG9yIHByb3h5IGV2ZW50L3RyYW5zaXRpb24gQXJndW1lbnRzXG5cdFx0Ly8gKiBkIC0gRHluYW1pYyBwcm94eSBldmVudC90cmFuc2l0aW9uIGFyZ3VtZW50c1xuXHRcdC8vICogbiAtIGluZGljYXRlcyBhbiBpTnZlcnRlZCBzZWN0aW9uXG5cdFx0Ly8gKiBpIC0gSW5kZXggcmVmZXJlbmNlLCBlLmcuICdudW0nIGluIHt7I3NlY3Rpb246bnVtfX1jb250ZW50e3svc2VjdGlvbn19XG5cdFx0Ly8gKiB2IC0gZVZlbnQgcHJveGllcyAoaS5lLiB3aGVuIHVzZXIgZS5nLiBjbGlja3Mgb24gYSBub2RlLCBmaXJlIHByb3h5IGV2ZW50KVxuXHRcdC8vICogeCAtIGVYcHJlc3Npb25zXG5cdFx0Ly8gKiBzIC0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGV4cHJlc3Npb24gZnVuY3Rpb25cblx0XHQvLyAqIHQwIC0gaW50cm8vb3V0cm8gVHJhbnNpdGlvblxuXHRcdC8vICogdDEgLSBpbnRybyBUcmFuc2l0aW9uXG5cdFx0Ly8gKiB0MiAtIG91dHJvIFRyYW5zaXRpb25cblx0XHQvLyAqIG8gLSBkZWNPcmF0b3Jcblx0XHQvLyAqIHkgLSBpcyBkb2N0WXBlXG5cdFx0Ly8gKiBjIC0gaXMgQ29udGVudCAoZS5nLiBvZiBhIGNvbW1lbnQgbm9kZSlcblx0XHQvLyAqIHAgLSBsaW5lIFBvc2l0aW9uIGluZm9ybWF0aW9uIC0gYXJyYXkgd2l0aCBsaW5lIG51bWJlciBhbmQgY2hhcmFjdGVyIHBvc2l0aW9uIG9mIGVhY2ggbm9kZVxuXHRcdHZhciBTdGFuZGFyZFBhcnNlciwgcGFyc2UsIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSsvZyxcblx0XHRcdGlubGluZVBhcnRpYWxTdGFydCA9IC88IS0tXFxzKlxce1xce1xccyo+XFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFxzKn1cXH1cXHMqLS0+Lyxcblx0XHRcdGlubGluZVBhcnRpYWxFbmQgPSAvPCEtLVxccypcXHtcXHtcXHMqXFwvXFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFxzKn1cXH1cXHMqLS0+Lyxcblx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzID0gL14oPzpwcmV8c2NyaXB0fHN0eWxlfHRleHRhcmVhKSQvaSxcblx0XHRcdGxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLyxcblx0XHRcdHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9cXHMrJC87XG5cdFx0U3RhbmRhcmRQYXJzZXIgPSBQYXJzZXIuZXh0ZW5kKCB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0XHQvLyBjb25maWdcblx0XHRcdFx0dGhpcy5kZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0XHQne3snLFxuXHRcdFx0XHRcdCd9fSdcblx0XHRcdFx0XTtcblx0XHRcdFx0dGhpcy50cmlwbGVEZWxpbWl0ZXJzID0gb3B0aW9ucy50cmlwbGVEZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0XHQne3t7Jyxcblx0XHRcdFx0XHQnfX19J1xuXHRcdFx0XHRdO1xuXHRcdFx0XHR0aGlzLnN0YXRpY0RlbGltaXRlcnMgPSBvcHRpb25zLnN0YXRpY0RlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHRcdCdbWycsXG5cdFx0XHRcdFx0J11dJ1xuXHRcdFx0XHRdO1xuXHRcdFx0XHR0aGlzLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgPSBvcHRpb25zLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHRcdCdbW1snLFxuXHRcdFx0XHRcdCddXV0nXG5cdFx0XHRcdF07XG5cdFx0XHRcdHRoaXMuc2VjdGlvbkRlcHRoID0gMDtcblx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0ZSA9IHtcblx0XHRcdFx0XHRzY3JpcHQ6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc2NyaXB0ICE9PSBmYWxzZSxcblx0XHRcdFx0XHRzdHlsZTogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zdHlsZSAhPT0gZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLnNhbml0aXplID09PSB0cnVlICkge1xuXHRcdFx0XHRcdG9wdGlvbnMuc2FuaXRpemUgPSB7XG5cdFx0XHRcdFx0XHQvLyBibGFja2xpc3QgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1jYWphL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvY2FqYS9sYW5nL2h0bWwvaHRtbDQtZWxlbWVudHMtd2hpdGVsaXN0Lmpzb25cblx0XHRcdFx0XHRcdGVsZW1lbnRzOiAnYXBwbGV0IGJhc2UgYmFzZWZvbnQgYm9keSBmcmFtZSBmcmFtZXNldCBoZWFkIGh0bWwgaXNpbmRleCBsaW5rIG1ldGEgbm9mcmFtZXMgbm9zY3JpcHQgb2JqZWN0IHBhcmFtIHNjcmlwdCBzdHlsZSB0aXRsZScuc3BsaXQoICcgJyApLFxuXHRcdFx0XHRcdFx0ZXZlbnRBdHRyaWJ1dGVzOiB0cnVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNhbml0aXplRWxlbWVudHMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZWxlbWVudHM7XG5cdFx0XHRcdHRoaXMuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZXZlbnRBdHRyaWJ1dGVzO1xuXHRcdFx0XHR0aGlzLmluY2x1ZGVMaW5lUG9zaXRpb25zID0gb3B0aW9ucy5pbmNsdWRlTGluZVBvc2l0aW9ucztcblx0XHRcdH0sXG5cdFx0XHRwb3N0UHJvY2VzczogZnVuY3Rpb24oIGl0ZW1zLCBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc2VjdGlvbkRlcHRoID4gMCApIHtcblx0XHRcdFx0XHR0aGlzLmVycm9yKCAnQSBzZWN0aW9uIHdhcyBsZWZ0IG9wZW4nICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xlYW51cCggaXRlbXMsIG9wdGlvbnMuc3RyaXBDb21tZW50cyAhPT0gZmFsc2UsIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAhb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICFvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgb3B0aW9ucy5yZXdyaXRlRWxzZSAhPT0gZmFsc2UgKTtcblx0XHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdFx0fSxcblx0XHRcdGNvbnZlcnRlcnM6IFtcblx0XHRcdFx0bXVzdGFjaGUsXG5cdFx0XHRcdGNvbW1lbnQsXG5cdFx0XHRcdGVsZW1lbnQsXG5cdFx0XHRcdHRleHRcblx0XHRcdF1cblx0XHR9ICk7XG5cdFx0cGFyc2UgPSBmdW5jdGlvbiggdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHR2YXIgcmVzdWx0LCByZW1haW5pbmcsIHBhcnRpYWxzLCBuYW1lLCBzdGFydE1hdGNoLCBlbmRNYXRjaDtcblx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0djogMVxuXHRcdFx0fTtcblx0XHRcdGlmICggaW5saW5lUGFydGlhbFN0YXJ0LnRlc3QoIHRlbXBsYXRlICkgKSB7XG5cdFx0XHRcdHJlbWFpbmluZyA9IHRlbXBsYXRlO1xuXHRcdFx0XHR0ZW1wbGF0ZSA9ICcnO1xuXHRcdFx0XHR3aGlsZSAoIHN0YXJ0TWF0Y2ggPSBpbmxpbmVQYXJ0aWFsU3RhcnQuZXhlYyggcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IHN0YXJ0TWF0Y2hbIDEgXTtcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSByZW1haW5pbmcuc3Vic3RyKCAwLCBzdGFydE1hdGNoLmluZGV4ICk7XG5cdFx0XHRcdFx0cmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggc3RhcnRNYXRjaC5pbmRleCArIHN0YXJ0TWF0Y2hbIDAgXS5sZW5ndGggKTtcblx0XHRcdFx0XHRlbmRNYXRjaCA9IGlubGluZVBhcnRpYWxFbmQuZXhlYyggcmVtYWluaW5nICk7XG5cdFx0XHRcdFx0aWYgKCAhZW5kTWF0Y2ggfHwgZW5kTWF0Y2hbIDEgXSAhPT0gbmFtZSApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0lubGluZSBwYXJ0aWFscyBtdXN0IGhhdmUgYSBjbG9zaW5nIGRlbGltaXRlciwgYW5kIGNhbm5vdCBiZSBuZXN0ZWQnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCggcGFydGlhbHMgfHwgKCBwYXJ0aWFscyA9IHt9ICkgKVsgbmFtZSBdID0gbmV3IFN0YW5kYXJkUGFyc2VyKCByZW1haW5pbmcuc3Vic3RyKCAwLCBlbmRNYXRjaC5pbmRleCApLCBvcHRpb25zICkucmVzdWx0O1xuXHRcdFx0XHRcdHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGVuZE1hdGNoLmluZGV4ICsgZW5kTWF0Y2hbIDAgXS5sZW5ndGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQucCA9IHBhcnRpYWxzO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnQgPSBuZXcgU3RhbmRhcmRQYXJzZXIoIHRlbXBsYXRlLCBvcHRpb25zICkucmVzdWx0O1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdHJldHVybiBwYXJzZTtcblxuXHRcdGZ1bmN0aW9uIGNsZWFudXAoIGl0ZW1zLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UsIHJld3JpdGVFbHNlICkge1xuXHRcdFx0dmFyIGksIGl0ZW0sIHByZXZpb3VzSXRlbSwgbmV4dEl0ZW0sIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgdW5sZXNzQmxvY2ssIGtleTtcblx0XHRcdC8vIEZpcnN0IHBhc3MgLSByZW1vdmUgc3RhbmRhbG9uZXMgYW5kIGNvbW1lbnRzIGV0Y1xuXHRcdFx0c3RyaXBTdGFuZGFsb25lcyggaXRlbXMgKTtcblx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdC8vIFJlbW92ZSBkZWxpbWl0ZXIgY2hhbmdlcywgdW5zYWZlIGVsZW1lbnRzIGV0Y1xuXHRcdFx0XHRpZiAoIGl0ZW0uZXhjbHVkZSApIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggc3RyaXBDb21tZW50cyAmJiBpdGVtLnQgPT09IHR5cGVzLkNPTU1FTlQgKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIG5lY2Vzc2FyeSwgcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Vcblx0XHRcdHRyaW1XaGl0ZXNwYWNlKCBpdGVtcywgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSApO1xuXHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0Ly8gUmVjdXJzZVxuXHRcdFx0XHRpZiAoIGl0ZW0uZiApIHtcblx0XHRcdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHByZXNlcnZlV2hpdGVzcGFjZSB8fCBpdGVtLnQgPT09IHR5cGVzLkVMRU1FTlQgJiYgcHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMudGVzdCggaXRlbS5lICk7XG5cdFx0XHRcdFx0aWYgKCAhcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRwcmV2aW91c0l0ZW0gPSBpdGVtc1sgaSAtIDEgXTtcblx0XHRcdFx0XHRcdG5leHRJdGVtID0gaXRlbXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgcHJldmlvdXMgaXRlbSB3YXMgYSB0ZXh0IGl0ZW0gd2l0aCB0cmFpbGluZyB3aGl0ZXNwYWNlLFxuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZSBpbnNpZGUgdGhlIGZyYWdtZW50XG5cdFx0XHRcdFx0XHRpZiAoICFwcmV2aW91c0l0ZW0gfHwgdHlwZW9mIHByZXZpb3VzSXRlbSA9PT0gJ3N0cmluZycgJiYgdHJhaWxpbmdXaGl0ZXNwYWNlLnRlc3QoIHByZXZpb3VzSXRlbSApICkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGFuZCB2aWNlIHZlcnNhXG5cdFx0XHRcdFx0XHRpZiAoICFuZXh0SXRlbSB8fCB0eXBlb2YgbmV4dEl0ZW0gPT09ICdzdHJpbmcnICYmIGxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIG5leHRJdGVtICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2xlYW51cCggaXRlbS5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdFx0Ly8gU3BsaXQgaWYtZWxzZSBibG9ja3MgaW50byB0d28gKGFuIGlmLCBhbmQgYW4gdW5sZXNzKVxuXHRcdFx0XHRcdGlmICggaXRlbS5sICkge1xuXHRcdFx0XHRcdFx0Y2xlYW51cCggaXRlbS5sLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZXdyaXRlRWxzZSApO1xuXHRcdFx0XHRcdFx0aWYgKCByZXdyaXRlRWxzZSApIHtcblx0XHRcdFx0XHRcdFx0dW5sZXNzQmxvY2sgPSB7XG5cdFx0XHRcdFx0XHRcdFx0dDogNCxcblx0XHRcdFx0XHRcdFx0XHRuOiB0eXBlcy5TRUNUSU9OX1VOTEVTUyxcblx0XHRcdFx0XHRcdFx0XHRmOiBpdGVtLmxcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0Ly8gY29weSB0aGUgY29uZGl0aW9uYWwgYmFzZWQgb24gaXRzIHR5cGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpdGVtLnIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dW5sZXNzQmxvY2suciA9IGl0ZW0ucjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIGl0ZW0ueCApIHtcblx0XHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jay54ID0gaXRlbS54O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICggaXRlbS5yeCApIHtcblx0XHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jay5yeCA9IGl0ZW0ucng7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpICsgMSwgMCwgdW5sZXNzQmxvY2sgKTtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGl0ZW0ubDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQ2xlYW4gdXAgZWxlbWVudCBhdHRyaWJ1dGVzXG5cdFx0XHRcdGlmICggaXRlbS5hICkge1xuXHRcdFx0XHRcdGZvciAoIGtleSBpbiBpdGVtLmEgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0uYS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdHlwZW9mIGl0ZW0uYVsga2V5IF0gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0XHRjbGVhbnVwKCBpdGVtLmFbIGtleSBdLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBmaW5hbCBwYXNzIC0gZnVzZSB0ZXh0IG5vZGVzIHRvZ2V0aGVyXG5cdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW1zWyBpIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIGl0ZW1zWyBpICsgMSBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBpdGVtc1sgaSBdICsgaXRlbXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGkgKyAxLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXByZXNlcnZlV2hpdGVzcGFjZSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBpdGVtc1sgaSBdLnJlcGxhY2UoIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlLCAnICcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBpdGVtc1sgaSBdID09PSAnJyApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSggdHlwZXMsIFBhcnNlciwgbXVzdGFjaGUsIGNvbW1lbnQsIGVsZW1lbnQsIHRleHQsIHRyaW1XaGl0ZXNwYWNlLCBzdHJpcFN0YW5kYWxvbmVzICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZ3JvdXBzL29wdGlvbkdyb3VwLmpzICovXG5cdHZhciBvcHRpb25Hcm91cCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbkdyb3VwKCBrZXlzLCBjb25maWcgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBrZXlzLm1hcCggY29uZmlnICk7XG5cdFx0XHRrZXlzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXksIGkgKSB7XG5cdFx0XHRcdGdyb3VwWyBrZXkgXSA9IGdyb3VwWyBpIF07XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gZ3JvdXA7XG5cdFx0fTtcblx0fSggbGVnYWN5ICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZ3JvdXBzL3BhcnNlT3B0aW9ucy5qcyAqL1xuXHR2YXIgcGFyc2VPcHRpb25zID0gZnVuY3Rpb24oIG9wdGlvbkdyb3VwICkge1xuXG5cdFx0dmFyIGtleXMsIHBhcnNlT3B0aW9ucztcblx0XHRrZXlzID0gW1xuXHRcdFx0J3ByZXNlcnZlV2hpdGVzcGFjZScsXG5cdFx0XHQnc2FuaXRpemUnLFxuXHRcdFx0J3N0cmlwQ29tbWVudHMnLFxuXHRcdFx0J2RlbGltaXRlcnMnLFxuXHRcdFx0J3RyaXBsZURlbGltaXRlcnMnXG5cdFx0XTtcblx0XHRwYXJzZU9wdGlvbnMgPSBvcHRpb25Hcm91cCgga2V5cywgZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fSApO1xuXHRcdHJldHVybiBwYXJzZU9wdGlvbnM7XG5cdH0oIG9wdGlvbkdyb3VwICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvdGVtcGxhdGUvcGFyc2VyLmpzICovXG5cdHZhciBwYXJzZXIgPSBmdW5jdGlvbiggZXJyb3JzLCBpc0NsaWVudCwgcGFyc2UsIGNyZWF0ZSwgcGFyc2VPcHRpb25zICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHtcblx0XHRcdHBhcnNlOiBkb1BhcnNlLFxuXHRcdFx0ZnJvbUlkOiBmcm9tSWQsXG5cdFx0XHRpc0hhc2hlZElkOiBpc0hhc2hlZElkLFxuXHRcdFx0aXNQYXJzZWQ6IGlzUGFyc2VkLFxuXHRcdFx0Z2V0UGFyc2VPcHRpb25zOiBnZXRQYXJzZU9wdGlvbnMsXG5cdFx0XHRjcmVhdGVIZWxwZXI6IGNyZWF0ZUhlbHBlclxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVIZWxwZXIoIHBhcnNlT3B0aW9ucyApIHtcblx0XHRcdHZhciBoZWxwZXIgPSBjcmVhdGUoIHBhcnNlciApO1xuXHRcdFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24oIHRlbXBsYXRlLCBvcHRpb25zICkge1xuXHRcdFx0XHRyZXR1cm4gZG9QYXJzZSggdGVtcGxhdGUsIG9wdGlvbnMgfHwgcGFyc2VPcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGhlbHBlcjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkb1BhcnNlKCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zICkge1xuXHRcdFx0aWYgKCAhcGFyc2UgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JzLm1pc3NpbmdQYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJzZSggdGVtcGxhdGUsIHBhcnNlT3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tSWQoIGlkLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHRlbXBsYXRlO1xuXHRcdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCByZXRyaWV2ZSB0ZW1wbGF0ZSAjJyArIGlkICsgJyBhcyBSYWN0aXZlIGlzIG5vdCBydW5uaW5nIGluIGEgYnJvd3Nlci4nICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGlzSGFzaGVkSWQoIGlkICkgKSB7XG5cdFx0XHRcdGlkID0gaWQuc3Vic3RyaW5nKCAxICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICEoIHRlbXBsYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGlkICkgKSApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICMnICsgaWQgKTtcblx0XHRcdH1cblx0XHRcdC8vIERvIHdlIHdhbnQgdG8gdHVybiB0aGlzIG9uP1xuXHRcdFx0LypcbiAgICAgICAgICAgIFx0aWYgKCB0ZW1wbGF0ZS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdTQ1JJUFQnICkpIHtcbiAgICAgICAgICAgIFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93ICkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgIycgKyBpZCArICcsIG11c3QgYmUgYSA8c2NyaXB0PiBlbGVtZW50JyApO1xuICAgICAgICAgICAgXHR9XG4gICAgICAgICAgICBcdCovXG5cdFx0XHRyZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzSGFzaGVkSWQoIGlkICkge1xuXHRcdFx0cmV0dXJuIGlkLmNoYXJBdCggMCApID09PSAnIyc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQYXJzZWQoIHRlbXBsYXRlICkge1xuXHRcdFx0cmV0dXJuICEoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSB7XG5cdFx0XHQvLyBDb3VsZCBiZSBSYWN0aXZlIG9yIGEgQ29tcG9uZW50XG5cdFx0XHRpZiAoIHJhY3RpdmUuZGVmYXVsdHMgKSB7XG5cdFx0XHRcdHJhY3RpdmUgPSByYWN0aXZlLmRlZmF1bHRzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnNlT3B0aW9ucy5yZWR1Y2UoIGZ1bmN0aW9uKCB2YWwsIGtleSApIHtcblx0XHRcdFx0dmFsWyBrZXkgXSA9IHJhY3RpdmVbIGtleSBdO1xuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fSwge30gKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlcjtcblx0fSggZXJyb3JzLCBpc0NsaWVudCwgcGFyc2UsIGNyZWF0ZSwgcGFyc2VPcHRpb25zICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvdGVtcGxhdGUvdGVtcGxhdGUuanMgKi9cblx0dmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oIHBhcnNlciwgcGFyc2UgKSB7XG5cblx0XHR2YXIgdGVtcGxhdGVDb25maWcgPSB7XG5cdFx0XHRuYW1lOiAndGVtcGxhdGUnLFxuXHRcdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciB0ZW1wbGF0ZTtcblx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZXhpc3RzXG5cdFx0XHRcdGlmICggJ3RlbXBsYXRlJyBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyggdGVtcGxhdGUsIHByb3RvICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24gaW5pdCggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgdGVtcGxhdGUsIGZuO1xuXHRcdFx0XHQvLyBUT0RPIGJlY2F1c2Ugb2YgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgd2UgbWlnaHQganVzdCBiZSBhYmxlIHRvIHVzZVxuXHRcdFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlLCBhbmQgbm90IGJvdGhlciBwYXNzaW5nIHRocm91Z2ggdGhlIFBhcmVudCBvYmplY3QuXG5cdFx0XHRcdC8vIEF0IHByZXNlbnQgdGhhdCBicmVha3MgdGhlIHRlc3QgbW9ja3MnIGV4cGVjdGF0aW9uc1xuXHRcdFx0XHR0ZW1wbGF0ZSA9ICd0ZW1wbGF0ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGVtcGxhdGUgOiBQYXJlbnQucHJvdG90eXBlLnRlbXBsYXRlO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRmbiA9IHRlbXBsYXRlO1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gZ2V0RHluYW1pY1RlbXBsYXRlKCByYWN0aXZlLCBmbiApO1xuXHRcdFx0XHRcdHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSA9IHtcblx0XHRcdFx0XHRcdGZuOiBmbixcblx0XHRcdFx0XHRcdHJlc3VsdDogdGVtcGxhdGVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyggdGVtcGxhdGUsIHJhY3RpdmUgKTtcblx0XHRcdFx0Ly8gVE9ETyB0aGUgbmFtaW5nIG9mIHRoaXMgaXMgY29uZnVzaW5nIC0gcmFjdGl2ZS50ZW1wbGF0ZSByZWZlcnMgdG8gWy4uLl0sXG5cdFx0XHRcdC8vIGJ1dCBDb21wb25lbnQucHJvdG90eXBlLnRlbXBsYXRlIHJlZmVycyB0byB7djoxLHQ6W10scDpbXX0uLi5cblx0XHRcdFx0Ly8gaXQncyB1bm5lY2Vzc2FyeSwgYmVjYXVzZSB0aGUgZGV2ZWxvcGVyIG5ldmVyIG5lZWRzIHRvIGFjY2Vzc1xuXHRcdFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlXG5cdFx0XHRcdHJhY3RpdmUudGVtcGxhdGUgPSB0ZW1wbGF0ZS50O1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlLnAgKSB7XG5cdFx0XHRcdFx0ZXh0ZW5kUGFydGlhbHMoIHJhY3RpdmUucGFydGlhbHMsIHRlbXBsYXRlLnAgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlc2V0OiBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHJlc2V0VmFsdWUoIHJhY3RpdmUgKSxcblx0XHRcdFx0XHRwYXJzZWQ7XG5cdFx0XHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0XHRcdHBhcnNlZCA9IHBhcnNlSWZTdHJpbmcoIHJlc3VsdCwgcmFjdGl2ZSApO1xuXHRcdFx0XHRcdHJhY3RpdmUudGVtcGxhdGUgPSBwYXJzZWQudDtcblx0XHRcdFx0XHRleHRlbmRQYXJ0aWFscyggcmFjdGl2ZS5wYXJ0aWFscywgcGFyc2VkLnAsIHRydWUgKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNldFZhbHVlKCByYWN0aXZlICkge1xuXHRcdFx0dmFyIGluaXRpYWwgPSByYWN0aXZlLl9jb25maWcudGVtcGxhdGUsXG5cdFx0XHRcdHJlc3VsdDtcblx0XHRcdC8vIElmIHRoaXMgaXNuJ3QgYSBkeW5hbWljIHRlbXBsYXRlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cblx0XHRcdGlmICggIWluaXRpYWwgfHwgIWluaXRpYWwuZm4gKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHJlc3VsdCA9IGdldER5bmFtaWNUZW1wbGF0ZSggcmFjdGl2ZSwgaW5pdGlhbC5mbiApO1xuXHRcdFx0Ly8gVE9ETyBkZWVwIGVxdWFsaXR5IGNoZWNrIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyaW5nXG5cdFx0XHQvLyBpbiB0aGUgY2FzZSBvZiBhbHJlYWR5LXBhcnNlZCB0ZW1wbGF0ZXNcblx0XHRcdGlmICggcmVzdWx0ICE9PSBpbml0aWFsLnJlc3VsdCApIHtcblx0XHRcdFx0aW5pdGlhbC5yZXN1bHQgPSByZXN1bHQ7XG5cdFx0XHRcdHJlc3VsdCA9IHBhcnNlSWZTdHJpbmcoIHJlc3VsdCwgcmFjdGl2ZSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldER5bmFtaWNUZW1wbGF0ZSggcmFjdGl2ZSwgZm4gKSB7XG5cdFx0XHR2YXIgaGVscGVyID0gcGFyc2VyLmNyZWF0ZUhlbHBlciggcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApICk7XG5cdFx0XHRyZXR1cm4gZm4uY2FsbCggcmFjdGl2ZSwgcmFjdGl2ZS5kYXRhLCBoZWxwZXIgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUlmU3RyaW5nKCB0ZW1wbGF0ZSwgcmFjdGl2ZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0Ly8gSUQgb2YgYW4gZWxlbWVudCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZT9cblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZVsgMCBdID09PSAnIycgKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZXIuZnJvbUlkKCB0ZW1wbGF0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlID0gcGFyc2UoIHRlbXBsYXRlLCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLnYgIT09IDEgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ01pc21hdGNoZWQgdGVtcGxhdGUgdmVyc2lvbiEgUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiBSYWN0aXZlLmpzIGluIHlvdXIgYnVpbGQgcHJvY2VzcyBhcyB3ZWxsIGFzIGluIHlvdXIgYXBwJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRlbXBsYXRlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4dGVuZFBhcnRpYWxzKCBleGlzdGluZ1BhcnRpYWxzLCBuZXdQYXJ0aWFscywgb3ZlcndyaXRlICkge1xuXHRcdFx0aWYgKCAhbmV3UGFydGlhbHMgKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHQvLyBUT0RPIHRoZXJlJ3MgYW4gYW1iaWd1aXR5IGhlcmUgLSB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSBpbiB0aGUgYHJlc2V0KClgXG5cdFx0XHQvLyBjYXNlLCBidXQgbm90IGluaXRpYWxseS4uLlxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBuZXdQYXJ0aWFscyApIHtcblx0XHRcdFx0aWYgKCBvdmVyd3JpdGUgfHwgIWV4aXN0aW5nUGFydGlhbHMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdGV4aXN0aW5nUGFydGlhbHNbIGtleSBdID0gbmV3UGFydGlhbHNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0ZW1wbGF0ZUNvbmZpZztcblx0fSggcGFyc2VyLCBwYXJzZSApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL1JlZ2lzdHJ5LmpzICovXG5cdHZhciBSZWdpc3RyeSA9IGZ1bmN0aW9uKCBjcmVhdGUgKSB7XG5cblx0XHRmdW5jdGlvbiBSZWdpc3RyeSggbmFtZSwgdXNlRGVmYXVsdHMgKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdFx0dGhpcy51c2VEZWZhdWx0cyA9IHVzZURlZmF1bHRzO1xuXHRcdH1cblx0XHRSZWdpc3RyeS5wcm90b3R5cGUgPSB7XG5cdFx0XHRjb25zdHJ1Y3RvcjogUmVnaXN0cnksXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmNvbmZpZ3VyZSggdGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCwgdGhpcy51c2VEZWZhdWx0cyA/IHByb3RvIDogcHJvdG8uY29uc3RydWN0b3IsIG9wdGlvbnMgKTtcblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbiggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmNvbmZpZ3VyZSggdGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0fSxcblx0XHRcdGNvbmZpZ3VyZTogZnVuY3Rpb24oIFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IHRoaXMubmFtZSxcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBuYW1lIF0sXG5cdFx0XHRcdFx0cmVnaXN0cnk7XG5cdFx0XHRcdHJlZ2lzdHJ5ID0gY3JlYXRlKCBQYXJlbnRbIG5hbWUgXSApO1xuXHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIG9wdGlvbiApIHtcblx0XHRcdFx0XHRyZWdpc3RyeVsga2V5IF0gPSBvcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gcmVnaXN0cnk7XG5cdFx0XHR9LFxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0XHR2YXIgcmVnaXN0cnkgPSByYWN0aXZlWyB0aGlzLm5hbWUgXTtcblx0XHRcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0T2JqZWN0LmtleXMoIHJlZ2lzdHJ5ICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHJlZ2lzdHJ5WyBrZXkgXTtcblx0XHRcdFx0XHRpZiAoIGl0ZW0uX2ZuICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLl9mbi5pc093bmVyICkge1xuXHRcdFx0XHRcdFx0XHRyZWdpc3RyeVsga2V5IF0gPSBpdGVtLl9mbjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSByZWdpc3RyeVsga2V5IF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZE93bmVyOiBmdW5jdGlvbiggcmFjdGl2ZSwga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gcmFjdGl2ZVsgdGhpcy5uYW1lIF0uaGFzT3duUHJvcGVydHkoIGtleSApID8gcmFjdGl2ZSA6IHRoaXMuZmluZENvbnN0cnVjdG9yKCByYWN0aXZlLmNvbnN0cnVjdG9yLCBrZXkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQ29uc3RydWN0b3I6IGZ1bmN0aW9uKCBjb25zdHJ1Y3Rvciwga2V5ICkge1xuXHRcdFx0XHRpZiAoICFjb25zdHJ1Y3RvciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvbnN0cnVjdG9yWyB0aGlzLm5hbWUgXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgPyBjb25zdHJ1Y3RvciA6IHRoaXMuZmluZENvbnN0cnVjdG9yKCBjb25zdHJ1Y3Rvci5fcGFyZW50LCBrZXkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kOiBmdW5jdGlvbiggcmFjdGl2ZSwga2V5ICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0cmV0dXJuIHJlY3Vyc2VGaW5kKCByYWN0aXZlLCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRyZXR1cm4gclsgdGhpcyQwLm5hbWUgXVsga2V5IF07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kSW5zdGFuY2U6IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXkgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZUZpbmQoIHJhY3RpdmUsIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdHJldHVybiByWyB0aGlzJDAubmFtZSBdWyBrZXkgXSA/IHIgOiB2b2lkIDA7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVjdXJzZUZpbmQoIHJhY3RpdmUsIGZuICkge1xuXHRcdFx0dmFyIGZpbmQsIHBhcmVudDtcblx0XHRcdGlmICggZmluZCA9IGZuKCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdHJldHVybiBmaW5kO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcmFjdGl2ZS5pc29sYXRlZCAmJiAoIHBhcmVudCA9IHJhY3RpdmUuX3BhcmVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZUZpbmQoIHBhcmVudCwgZm4gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFJlZ2lzdHJ5O1xuXHR9KCBjcmVhdGUsIGxlZ2FjeSApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2dyb3Vwcy9yZWdpc3RyaWVzLmpzICovXG5cdHZhciByZWdpc3RyaWVzID0gZnVuY3Rpb24oIG9wdGlvbkdyb3VwLCBSZWdpc3RyeSApIHtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0XHQnYWRhcHRvcnMnLFxuXHRcdFx0XHQnY29tcG9uZW50cycsXG5cdFx0XHRcdCdjb21wdXRlZCcsXG5cdFx0XHRcdCdkZWNvcmF0b3JzJyxcblx0XHRcdFx0J2Vhc2luZycsXG5cdFx0XHRcdCdldmVudHMnLFxuXHRcdFx0XHQnaW50ZXJwb2xhdG9ycycsXG5cdFx0XHRcdCdwYXJ0aWFscycsXG5cdFx0XHRcdCd0cmFuc2l0aW9ucydcblx0XHRcdF0sXG5cdFx0XHRyZWdpc3RyaWVzID0gb3B0aW9uR3JvdXAoIGtleXMsIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnaXN0cnkoIGtleSwga2V5ID09PSAnY29tcHV0ZWQnICk7XG5cdFx0XHR9ICk7XG5cdFx0cmV0dXJuIHJlZ2lzdHJpZXM7XG5cdH0oIG9wdGlvbkdyb3VwLCBSZWdpc3RyeSApO1xuXG5cdC8qIHV0aWxzL25vb3AuanMgKi9cblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qIHV0aWxzL3dyYXBQcm90b3R5cGVNZXRob2QuanMgKi9cblx0dmFyIHdyYXBQcm90b3R5cGVNZXRob2QgPSBmdW5jdGlvbiggbm9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB3cmFwKCBwYXJlbnQsIG5hbWUsIG1ldGhvZCApIHtcblx0XHRcdGlmICggIS9fc3VwZXIvLnRlc3QoIG1ldGhvZCApICkge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwU3VwZXIoKSB7XG5cdFx0XHRcdHZhciBzdXBlck1ldGhvZCA9IGdldFN1cGVyTWV0aG9kKCB3cmFwcGVyLl9wYXJlbnQsIG5hbWUgKSxcblx0XHRcdFx0XHRoYXNTdXBlciA9ICdfc3VwZXInIGluIHRoaXMsXG5cdFx0XHRcdFx0b2xkU3VwZXIgPSB0aGlzLl9zdXBlcixcblx0XHRcdFx0XHRyZXN1bHQ7XG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cdFx0XHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGlmICggaGFzU3VwZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBvbGRTdXBlcjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fc3VwZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0XHR3cmFwcGVyLl9wYXJlbnQgPSBwYXJlbnQ7XG5cdFx0XHR3cmFwcGVyLl9tZXRob2QgPSBtZXRob2Q7XG5cdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0U3VwZXJNZXRob2QoIHBhcmVudCwgbmFtZSApIHtcblx0XHRcdHZhciBtZXRob2Q7XG5cdFx0XHRpZiAoIG5hbWUgaW4gcGFyZW50ICkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJlbnRbIG5hbWUgXTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0bWV0aG9kID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWV0aG9kID0gZnVuY3Rpb24gcmV0dXJuVmFsdWUoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWV0aG9kID0gbm9vcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXRob2Q7XG5cdFx0fVxuXHR9KCBub29wICk7XG5cblx0LyogY29uZmlnL2RlcHJlY2F0ZS5qcyAqL1xuXHR2YXIgZGVwcmVjYXRlID0gZnVuY3Rpb24oIHdhcm4sIGlzQXJyYXkgKSB7XG5cblx0XHRmdW5jdGlvbiBkZXByZWNhdGUoIG9wdGlvbnMsIGRlcHJlY2F0ZWQsIGNvcnJlY3QgKSB7XG5cdFx0XHRpZiAoIGRlcHJlY2F0ZWQgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCAhKCBjb3JyZWN0IGluIG9wdGlvbnMgKSApIHtcblx0XHRcdFx0XHR3YXJuKCBnZXRNZXNzYWdlKCBkZXByZWNhdGVkLCBjb3JyZWN0ICkgKTtcblx0XHRcdFx0XHRvcHRpb25zWyBjb3JyZWN0IF0gPSBvcHRpb25zWyBkZXByZWNhdGVkIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBnZXRNZXNzYWdlKCBkZXByZWNhdGVkLCBjb3JyZWN0LCB0cnVlICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWQsIGNvcnJlY3QsIGlzRXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gJ29wdGlvbnMuJyArIGRlcHJlY2F0ZWQgKyAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdGlvbnMuJyArIGNvcnJlY3QgKyAnLicgKyAoIGlzRXJyb3IgPyAnIFlvdSBjYW5ub3Qgc3BlY2lmeSBib3RoIG9wdGlvbnMsIHBsZWFzZSB1c2Ugb3B0aW9ucy4nICsgY29ycmVjdCArICcuJyA6ICcnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVwcmVjYXRlRXZlbnREZWZpbml0aW9ucyggb3B0aW9ucyApIHtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2V2ZW50RGVmaW5pdGlvbnMnLCAnZXZlbnRzJyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlcHJlY2F0ZUFkYXB0b3JzKCBvcHRpb25zICkge1xuXHRcdFx0Ly8gVXNpbmcgZXh0ZW5kIHdpdGggQ29tcG9uZW50IGluc3RlYWQgb2Ygb3B0aW9ucyxcblx0XHRcdC8vIGxpa2UgSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKSBtZWFucyBhZGFwdG9ycyBhcyBhIHJlZ2lzdHJ5XG5cdFx0XHQvLyBnZXRzIGNvcGllZCB0byBvcHRpb25zLiBTbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIGFjdHVhbGx5IGFuIGFycmF5XG5cdFx0XHRpZiAoIGlzQXJyYXkoIG9wdGlvbnMuYWRhcHRvcnMgKSApIHtcblx0XHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnYWRhcHRvcnMnLCAnYWRhcHQnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbiBkZXByZWNhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHRcdFx0ZGVwcmVjYXRlRXZlbnREZWZpbml0aW9ucyggb3B0aW9ucyApO1xuXHRcdFx0ZGVwcmVjYXRlQWRhcHRvcnMoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHR9KCB3YXJuLCBpc0FycmF5ICk7XG5cblx0LyogY29uZmlnL2NvbmZpZy5qcyAqL1xuXHR2YXIgY29uZmlnID0gZnVuY3Rpb24oIGNzcywgZGF0YSwgZGVmYXVsdHMsIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMsIHJlZ2lzdHJpZXMsIHdyYXAsIGRlcHJlY2F0ZSApIHtcblxuXHRcdHZhciBjdXN0b20sIG9wdGlvbnMsIGNvbmZpZztcblx0XHRjdXN0b20gPSB7XG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRcdFx0Y3NzOiBjc3Ncblx0XHR9O1xuXHRcdG9wdGlvbnMgPSBPYmplY3Qua2V5cyggZGVmYXVsdHMgKS5maWx0ZXIoIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gIXJlZ2lzdHJpZXNbIGtleSBdICYmICFjdXN0b21bIGtleSBdICYmICFwYXJzZU9wdGlvbnNbIGtleSBdO1xuXHRcdH0gKTtcblx0XHQvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyOlxuXHRcdGNvbmZpZyA9IFtdLmNvbmNhdCggY3VzdG9tLmRhdGEsIHBhcnNlT3B0aW9ucywgb3B0aW9ucywgcmVnaXN0cmllcywgY3VzdG9tLnRlbXBsYXRlLCBjdXN0b20uY3NzICk7XG5cdFx0Zm9yICggdmFyIGtleSBpbiBjdXN0b20gKSB7XG5cdFx0XHRjb25maWdbIGtleSBdID0gY3VzdG9tWyBrZXkgXTtcblx0XHR9XG5cdFx0Ly8gZm9yIGl0ZXJhdGlvblxuXHRcdGNvbmZpZy5rZXlzID0gT2JqZWN0LmtleXMoIGRlZmF1bHRzICkuY29uY2F0KCByZWdpc3RyaWVzLm1hcCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRyZXR1cm4gci5uYW1lO1xuXHRcdH0gKSApLmNvbmNhdCggWyAnY3NzJyBdICk7XG5cdFx0Y29uZmlnLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcblx0XHRjb25maWcucmVnaXN0cmllcyA9IHJlZ2lzdHJpZXM7XG5cblx0XHRmdW5jdGlvbiBjdXN0b21Db25maWcoIG1ldGhvZCwga2V5LCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICkge1xuXHRcdFx0Y3VzdG9tWyBrZXkgXVsgbWV0aG9kIF0oIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHR9XG5cdFx0Y29uZmlnLmV4dGVuZCA9IGZ1bmN0aW9uKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0Y29uZmlndXJlKCAnZXh0ZW5kJywgUGFyZW50LCBwcm90bywgb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0Y29uZmlnLmluaXQgPSBmdW5jdGlvbiggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0Y29uZmlndXJlKCAnaW5pdCcsIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0aWYgKCByYWN0aXZlLl9jb25maWcgKSB7XG5cdFx0XHRcdHJhY3RpdmUuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY29uZmlndXJlKCBtZXRob2QsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKSB7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMgKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAnZGF0YScsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdGNvbmZpZy5wYXJzZU9wdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0aWYgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0XHRpbnN0YW5jZVsga2V5IF0gPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIGtleSBpbiBkZWZhdWx0cyAmJiAhKCBrZXkgaW4gY29uZmlnLnBhcnNlT3B0aW9ucyApICYmICEoIGtleSBpbiBjdXN0b20gKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0XHRpbnN0YW5jZVsga2V5IF0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB3cmFwKCBQYXJlbnQucHJvdG90eXBlLCBrZXksIHZhbHVlICkgOiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uZmlnLnJlZ2lzdHJpZXMuZm9yRWFjaCggZnVuY3Rpb24oIHJlZ2lzdHJ5ICkge1xuXHRcdFx0XHRyZWdpc3RyeVsgbWV0aG9kIF0oIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdH0gKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAndGVtcGxhdGUnLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHRjdXN0b21Db25maWcoIG1ldGhvZCwgJ2NzcycsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHR9XG5cdFx0Y29uZmlnLnJlc2V0ID0gZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRyZXR1cm4gY29uZmlnLmZpbHRlciggZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHRcdHJldHVybiBjLnJlc2V0ICYmIGMucmVzZXQoIHJhY3RpdmUgKTtcblx0XHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0XHRyZXR1cm4gYy5uYW1lO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0cmV0dXJuIGNvbmZpZztcblx0fSggY3NzLCBkYXRhLCBvcHRpb25zLCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zLCByZWdpc3RyaWVzLCB3cmFwUHJvdG90eXBlTWV0aG9kLCBkZXByZWNhdGUgKTtcblxuXHQvKiBzaGFyZWQvaW50ZXJwb2xhdGUuanMgKi9cblx0dmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24oIGNpcmN1bGFyLCB3YXJuLCBpbnRlcnBvbGF0b3JzLCBjb25maWcgKSB7XG5cblx0XHR2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiggZnJvbSwgdG8sIHJhY3RpdmUsIHR5cGUgKSB7XG5cdFx0XHRpZiAoIGZyb20gPT09IHRvICkge1xuXHRcdFx0XHRyZXR1cm4gc25hcCggdG8gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZSApIHtcblx0XHRcdFx0dmFyIGludGVycG9sID0gY29uZmlnLnJlZ2lzdHJpZXMuaW50ZXJwb2xhdG9ycy5maW5kKCByYWN0aXZlLCB0eXBlICk7XG5cdFx0XHRcdGlmICggaW50ZXJwb2wgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGludGVycG9sKCBmcm9tLCB0byApIHx8IHNuYXAoIHRvICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2FybiggJ01pc3NpbmcgXCInICsgdHlwZSArICdcIiBpbnRlcnBvbGF0b3IuIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiBmcm9tIFtUT0RPXScgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbnRlcnBvbGF0b3JzLm51bWJlciggZnJvbSwgdG8gKSB8fCBpbnRlcnBvbGF0b3JzLmFycmF5KCBmcm9tLCB0byApIHx8IGludGVycG9sYXRvcnMub2JqZWN0KCBmcm9tLCB0byApIHx8IGludGVycG9sYXRvcnMuY3NzTGVuZ3RoKCBmcm9tLCB0byApIHx8IHNuYXAoIHRvICk7XG5cdFx0fTtcblx0XHRjaXJjdWxhci5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuXHRcdHJldHVybiBpbnRlcnBvbGF0ZTtcblxuXHRcdGZ1bmN0aW9uIHNuYXAoIHRvICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdG87XG5cdFx0XHR9O1xuXHRcdH1cblx0fSggY2lyY3VsYXIsIHdhcm4sIGludGVycG9sYXRvcnMsIGNvbmZpZyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2FuaW1hdGUvQW5pbWF0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJGFuaW1hdGVfQW5pbWF0aW9uID0gZnVuY3Rpb24oIHdhcm4sIHJ1bmxvb3AsIGludGVycG9sYXRlICkge1xuXG5cdFx0dmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGtleTtcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdC8vIGZyb20gYW5kIHRvXG5cdFx0XHRmb3IgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR0aGlzWyBrZXkgXSA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmludGVycG9sYXRvciA9IGludGVycG9sYXRlKCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMucm9vdCwgdGhpcy5pbnRlcnBvbGF0b3IgKTtcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0fTtcblx0XHRBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGFwc2VkLCB0LCB2YWx1ZSwgdGltZU5vdywgaW5kZXgsIGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGg7XG5cdFx0XHRcdGlmICggdGhpcy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdHRpbWVOb3cgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdGVsYXBzZWQgPSB0aW1lTm93IC0gdGhpcy5zdGFydFRpbWU7XG5cdFx0XHRcdFx0aWYgKCBlbGFwc2VkID49IHRoaXMuZHVyYXRpb24gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGtleXBhdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgdGhpcy50byApO1xuXHRcdFx0XHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RlcCggMSwgdGhpcy50byApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5jb21wbGV0ZSggdGhpcy50byApO1xuXHRcdFx0XHRcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHRcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0d2FybiggJ0FuaW1hdGlvbiB3YXMgbm90IGZvdW5kJyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ID0gdGhpcy5lYXNpbmcgPyB0aGlzLmVhc2luZyggZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24gKSA6IGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdGhpcy5pbnRlcnBvbGF0b3IoIHQgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RlcCggdCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHR3YXJuKCAnQW5pbWF0aW9uIHdhcyBub3QgZm91bmQnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBBbmltYXRpb247XG5cdH0oIHdhcm4sIHJ1bmxvb3AsIGludGVycG9sYXRlICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYW5pbWF0ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRhbmltYXRlID0gZnVuY3Rpb24oIGlzRXF1YWwsIFByb21pc2UsIG5vcm1hbGlzZUtleXBhdGgsIGFuaW1hdGlvbnMsIEFuaW1hdGlvbiApIHtcblxuXHRcdHZhciBub29wID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdG5vQW5pbWF0aW9uID0ge1xuXHRcdFx0XHRzdG9wOiBub29wXG5cdFx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGFuaW1hdGUoIGtleXBhdGgsIHRvLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2UsIGssIGFuaW1hdGlvbiwgYW5pbWF0aW9ucywgZWFzaW5nLCBkdXJhdGlvbiwgc3RlcCwgY29tcGxldGUsIG1ha2VWYWx1ZUNvbGxlY3RvciwgY3VycmVudFZhbHVlcywgY29sbGVjdFZhbHVlLCBkdW1teSwgZHVtbXlPcHRpb25zO1xuXHRcdFx0cHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsICkge1xuXHRcdFx0XHRmdWxmaWxQcm9taXNlID0gZnVsZmlsO1xuXHRcdFx0fSApO1xuXHRcdFx0Ly8gYW5pbWF0ZSBtdWx0aXBsZSBrZXlwYXRoc1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSB0byB8fCB7fTtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHRcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdFx0YW5pbWF0aW9ucyA9IFtdO1xuXHRcdFx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIHBhc3MgdGhlIGBzdGVwYCBhbmQgYGNvbXBsZXRlYCBoYW5kbGVycywgYXMgdGhleSB3aWxsXG5cdFx0XHRcdC8vIHJ1biBmb3IgZWFjaCBhbmltYXRpb24hIFNvIGluc3RlYWQgd2UnbGwgc3RvcmUgdGhlIGhhbmRsZXJzIGFuZCBjcmVhdGVcblx0XHRcdFx0Ly8gb3VyIG93bi4uLlxuXHRcdFx0XHRzdGVwID0gb3B0aW9ucy5zdGVwO1xuXHRcdFx0XHRjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRjdXJyZW50VmFsdWVzID0ge307XG5cdFx0XHRcdFx0b3B0aW9ucy5zdGVwID0gbnVsbDtcblx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gbnVsbDtcblx0XHRcdFx0XHRtYWtlVmFsdWVDb2xsZWN0b3IgPSBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGsgaW4ga2V5cGF0aCApIHtcblx0XHRcdFx0XHRpZiAoIGtleXBhdGguaGFzT3duUHJvcGVydHkoIGsgKSApIHtcblx0XHRcdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdFx0Y29sbGVjdFZhbHVlID0gbWFrZVZhbHVlQ29sbGVjdG9yKCBrICk7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGlmICggc3RlcCApIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnN0ZXAgPSBjb2xsZWN0VmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZSA/IGNvbGxlY3RWYWx1ZSA6IG5vb3A7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGFuaW1hdGUoIHRoaXMsIGssIGtleXBhdGhbIGsgXSwgb3B0aW9ucyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRkdW1teU9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKCBzdGVwICkge1xuXHRcdFx0XHRcdFx0ZHVtbXlPcHRpb25zLnN0ZXAgPSBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRcdFx0c3RlcCggdCwgY3VycmVudFZhbHVlcyApO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdHByb21pc2UudGhlbiggZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCB0LCBjdXJyZW50VmFsdWVzICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGR1bW15T3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG5cdFx0XHRcdFx0ZHVtbXkgPSBhbmltYXRlKCB0aGlzLCBudWxsLCBudWxsLCBkdW1teU9wdGlvbnMgKTtcblx0XHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGR1bW15ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBhbmltYXRpb247XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGR1bW15ICkge1xuXHRcdFx0XHRcdFx0XHRkdW1teS5zdG9wKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gYW5pbWF0ZSBhIHNpbmdsZSBrZXlwYXRoXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGlmICggb3B0aW9ucy5jb21wbGV0ZSApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBvcHRpb25zLmNvbXBsZXRlICk7XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGUoIHRoaXMsIGtleXBhdGgsIHRvLCBvcHRpb25zICk7XG5cdFx0XHRwcm9taXNlLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYW5pbWF0ZSggcm9vdCwga2V5cGF0aCwgdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZWFzaW5nLCBkdXJhdGlvbiwgYW5pbWF0aW9uLCBmcm9tO1xuXHRcdFx0aWYgKCBrZXlwYXRoICkge1xuXHRcdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBrZXlwYXRoICE9PSBudWxsICkge1xuXHRcdFx0XHRmcm9tID0gcm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjYW5jZWwgYW55IGV4aXN0aW5nIGFuaW1hdGlvblxuXHRcdFx0Ly8gVE9ETyB3aGF0IGFib3V0IHVwc3RyZWFtL2Rvd25zdHJlYW0ga2V5cGF0aHM/XG5cdFx0XHRhbmltYXRpb25zLmFib3J0KCBrZXlwYXRoLCByb290ICk7XG5cdFx0XHQvLyBkb24ndCBib3RoZXIgYW5pbWF0aW5nIHZhbHVlcyB0aGF0IHN0YXkgdGhlIHNhbWVcblx0XHRcdGlmICggaXNFcXVhbCggZnJvbSwgdG8gKSApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmNvbXBsZXRlICkge1xuXHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUoIG9wdGlvbnMudG8gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9BbmltYXRpb247XG5cdFx0XHR9XG5cdFx0XHQvLyBlYXNpbmcgZnVuY3Rpb25cblx0XHRcdGlmICggb3B0aW9ucy5lYXNpbmcgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVhc2luZyA9IHJvb3QuZWFzaW5nWyBvcHRpb25zLmVhc2luZyBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdHlwZW9mIGVhc2luZyAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRlYXNpbmcgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBkdXJhdGlvblxuXHRcdFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID09PSB1bmRlZmluZWQgPyA0MDAgOiBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0Ly8gVE9ETyBzdG9yZSBrZXlzLCB1c2UgYW4gaW50ZXJuYWwgc2V0IG1ldGhvZFxuXHRcdFx0YW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigge1xuXHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuXHRcdFx0XHRmcm9tOiBmcm9tLFxuXHRcdFx0XHR0bzogdG8sXG5cdFx0XHRcdHJvb3Q6IHJvb3QsXG5cdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdGludGVycG9sYXRvcjogb3B0aW9ucy5pbnRlcnBvbGF0b3IsXG5cdFx0XHRcdC8vIFRPRE8gd3JhcCBjYWxsYmFja3MgaWYgbmVjZXNzYXJ5LCB0byB1c2UgaW5zdGFuY2UgYXMgY29udGV4dFxuXHRcdFx0XHRzdGVwOiBvcHRpb25zLnN0ZXAsXG5cdFx0XHRcdGNvbXBsZXRlOiBvcHRpb25zLmNvbXBsZXRlXG5cdFx0XHR9ICk7XG5cdFx0XHRhbmltYXRpb25zLmFkZCggYW5pbWF0aW9uICk7XG5cdFx0XHRyb290Ll9hbmltYXRpb25zLnB1c2goIGFuaW1hdGlvbiApO1xuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbjtcblx0XHR9XG5cdH0oIGlzRXF1YWwsIFByb21pc2UsIG5vcm1hbGlzZUtleXBhdGgsIGFuaW1hdGlvbnMsIFJhY3RpdmUkYW5pbWF0ZV9BbmltYXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIFJhY3RpdmUkZGV0YWNoID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGRldGFjaCgpIHtcblx0XHRcdGlmICggdGhpcy5lbCApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0fTtcblx0fSggcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kID0gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kKCBzZWxlY3RvciApIHtcblx0XHRpZiAoICF0aGlzLmVsICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdH07XG5cblx0LyogdXRpbHMvbWF0Y2hlcy5qcyAqL1xuXHR2YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uKCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCApIHtcblxuXHRcdHZhciBtYXRjaGVzLCBkaXYsIG1ldGhvZE5hbWVzLCB1bnByZWZpeGVkLCBwcmVmaXhlZCwgaSwgaiwgbWFrZUZ1bmN0aW9uO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0bWF0Y2hlcyA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdiA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0XHRtZXRob2ROYW1lcyA9IFtcblx0XHRcdFx0J21hdGNoZXMnLFxuXHRcdFx0XHQnbWF0Y2hlc1NlbGVjdG9yJ1xuXHRcdFx0XTtcblx0XHRcdG1ha2VGdW5jdGlvbiA9IGZ1bmN0aW9uKCBtZXRob2ROYW1lICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIG5vZGUsIHNlbGVjdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlWyBtZXRob2ROYW1lIF0oIHNlbGVjdG9yICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0aSA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICYmICFtYXRjaGVzICkge1xuXHRcdFx0XHR1bnByZWZpeGVkID0gbWV0aG9kTmFtZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBkaXZbIHVucHJlZml4ZWQgXSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKCB1bnByZWZpeGVkICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aiA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdFx0cHJlZml4ZWQgPSB2ZW5kb3JzWyBpIF0gKyB1bnByZWZpeGVkLnN1YnN0ciggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyB1bnByZWZpeGVkLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdFx0aWYgKCBkaXZbIHByZWZpeGVkIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24oIHByZWZpeGVkICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSUU4Li4uXG5cdFx0XHRpZiAoICFtYXRjaGVzICkge1xuXHRcdFx0XHRtYXRjaGVzID0gZnVuY3Rpb24oIG5vZGUsIHNlbGVjdG9yICkge1xuXHRcdFx0XHRcdHZhciBub2RlcywgcGFyZW50Tm9kZSwgaTtcblx0XHRcdFx0XHRwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdGlmICggIXBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBlbXB0eSBkdW1teSA8ZGl2PlxuXHRcdFx0XHRcdFx0ZGl2LmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHRcdFx0cGFyZW50Tm9kZSA9IGRpdjtcblx0XHRcdFx0XHRcdG5vZGUgPSBub2RlLmNsb25lTm9kZSgpO1xuXHRcdFx0XHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBub2RlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGVzID0gcGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGVzWyBpIF0gPT09IG5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9KCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvdGVzdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3Rlc3QgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggaXRlbSwgbm9EaXJ0eSApIHtcblx0XHRcdHZhciBpdGVtTWF0Y2hlcyA9IHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyAhdGhpcy5zZWxlY3RvciB8fCBpdGVtLm5hbWUgPT09IHRoaXMuc2VsZWN0b3IgOiBtYXRjaGVzKCBpdGVtLm5vZGUsIHRoaXMuc2VsZWN0b3IgKTtcblx0XHRcdGlmICggaXRlbU1hdGNoZXMgKSB7XG5cdFx0XHRcdHRoaXMucHVzaCggaXRlbS5ub2RlIHx8IGl0ZW0uaW5zdGFuY2UgKTtcblx0XHRcdFx0aWYgKCAhbm9EaXJ0eSApIHtcblx0XHRcdFx0XHR0aGlzLl9tYWtlRGlydHkoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9jYW5jZWwuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9jYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGl2ZVF1ZXJpZXMsIHNlbGVjdG9yLCBpbmRleDtcblx0XHRsaXZlUXVlcmllcyA9IHRoaXMuX3Jvb3RbIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyAnbGl2ZUNvbXBvbmVudFF1ZXJpZXMnIDogJ2xpdmVRdWVyaWVzJyBdO1xuXHRcdHNlbGVjdG9yID0gdGhpcy5zZWxlY3Rvcjtcblx0XHRpbmRleCA9IGxpdmVRdWVyaWVzLmluZGV4T2YoIHNlbGVjdG9yICk7XG5cdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRsaXZlUXVlcmllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRsaXZlUXVlcmllc1sgc2VsZWN0b3IgXSA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvc29ydEJ5SXRlbVBvc2l0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5SXRlbVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYW5jZXN0cnlBLCBhbmNlc3RyeUIsIG9sZGVzdEEsIG9sZGVzdEIsIG11dHVhbEFuY2VzdG9yLCBpbmRleEEsIGluZGV4QiwgZnJhZ21lbnRzLCBmcmFnbWVudEEsIGZyYWdtZW50Qjtcblx0XHRcdGFuY2VzdHJ5QSA9IGdldEFuY2VzdHJ5KCBhLmNvbXBvbmVudCB8fCBhLl9yYWN0aXZlLnByb3h5ICk7XG5cdFx0XHRhbmNlc3RyeUIgPSBnZXRBbmNlc3RyeSggYi5jb21wb25lbnQgfHwgYi5fcmFjdGl2ZS5wcm94eSApO1xuXHRcdFx0b2xkZXN0QSA9IGFuY2VzdHJ5QVsgYW5jZXN0cnlBLmxlbmd0aCAtIDEgXTtcblx0XHRcdG9sZGVzdEIgPSBhbmNlc3RyeUJbIGFuY2VzdHJ5Qi5sZW5ndGggLSAxIF07XG5cdFx0XHQvLyByZW1vdmUgaXRlbXMgZnJvbSB0aGUgZW5kIG9mIGJvdGggYW5jZXN0cmllcyBhcyBsb25nIGFzIHRoZXkgYXJlIGlkZW50aWNhbFxuXHRcdFx0Ly8gLSB0aGUgZmluYWwgb25lIHJlbW92ZWQgaXMgdGhlIGNsb3Nlc3QgbXV0dWFsIGFuY2VzdG9yXG5cdFx0XHR3aGlsZSAoIG9sZGVzdEEgJiYgb2xkZXN0QSA9PT0gb2xkZXN0QiApIHtcblx0XHRcdFx0YW5jZXN0cnlBLnBvcCgpO1xuXHRcdFx0XHRhbmNlc3RyeUIucG9wKCk7XG5cdFx0XHRcdG11dHVhbEFuY2VzdG9yID0gb2xkZXN0QTtcblx0XHRcdFx0b2xkZXN0QSA9IGFuY2VzdHJ5QVsgYW5jZXN0cnlBLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0b2xkZXN0QiA9IGFuY2VzdHJ5QlsgYW5jZXN0cnlCLmxlbmd0aCAtIDEgXTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIG11dHVhbCBhbmNlc3Rvciwgd2UgY2FuIGZpbmQgd2hpY2ggaXMgZWFybGllc3Rcblx0XHRcdG9sZGVzdEEgPSBvbGRlc3RBLmNvbXBvbmVudCB8fCBvbGRlc3RBO1xuXHRcdFx0b2xkZXN0QiA9IG9sZGVzdEIuY29tcG9uZW50IHx8IG9sZGVzdEI7XG5cdFx0XHRmcmFnbWVudEEgPSBvbGRlc3RBLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0ZnJhZ21lbnRCID0gb2xkZXN0Qi5wYXJlbnRGcmFnbWVudDtcblx0XHRcdC8vIGlmIGJvdGggaXRlbXMgc2hhcmUgYSBwYXJlbnQgZnJhZ21lbnQsIG91ciBqb2IgaXMgZWFzeVxuXHRcdFx0aWYgKCBmcmFnbWVudEEgPT09IGZyYWdtZW50QiApIHtcblx0XHRcdFx0aW5kZXhBID0gZnJhZ21lbnRBLml0ZW1zLmluZGV4T2YoIG9sZGVzdEEgKTtcblx0XHRcdFx0aW5kZXhCID0gZnJhZ21lbnRCLml0ZW1zLmluZGV4T2YoIG9sZGVzdEIgKTtcblx0XHRcdFx0Ly8gaWYgaXQncyB0aGUgc2FtZSBpbmRleCwgaXQgbWVhbnMgb25lIGNvbnRhaW5zIHRoZSBvdGhlcixcblx0XHRcdFx0Ly8gc28gd2Ugc2VlIHdoaWNoIGhhcyB0aGUgbG9uZ2VzdCBhbmNlc3RyeVxuXHRcdFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgbXV0dWFsIGFuY2VzdG9yIGlzIGEgc2VjdGlvbiwgd2UgZmlyc3QgdGVzdCB0byBzZWUgd2hpY2ggc2VjdGlvblxuXHRcdFx0Ly8gZnJhZ21lbnQgY29tZXMgZmlyc3Rcblx0XHRcdGlmICggZnJhZ21lbnRzID0gbXV0dWFsQW5jZXN0b3IuZnJhZ21lbnRzICkge1xuXHRcdFx0XHRpbmRleEEgPSBmcmFnbWVudHMuaW5kZXhPZiggZnJhZ21lbnRBICk7XG5cdFx0XHRcdGluZGV4QiA9IGZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudEIgKTtcblx0XHRcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0FuIHVuZXhwZWN0ZWQgY29uZGl0aW9uIHdhcyBtZXQgd2hpbGUgY29tcGFyaW5nIHRoZSBwb3NpdGlvbiBvZiB0d28gY29tcG9uZW50cy4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyEnICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFBhcmVudCggaXRlbSApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudDtcblx0XHRcdGlmICggcGFyZW50RnJhZ21lbnQgPSBpdGVtLnBhcmVudEZyYWdtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGl0ZW0uY29tcG9uZW50ICYmICggcGFyZW50RnJhZ21lbnQgPSBpdGVtLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QW5jZXN0cnkoIGl0ZW0gKSB7XG5cdFx0XHR2YXIgYW5jZXN0cnksIGFuY2VzdG9yO1xuXHRcdFx0YW5jZXN0cnkgPSBbIGl0ZW0gXTtcblx0XHRcdGFuY2VzdG9yID0gZ2V0UGFyZW50KCBpdGVtICk7XG5cdFx0XHR3aGlsZSAoIGFuY2VzdG9yICkge1xuXHRcdFx0XHRhbmNlc3RyeS5wdXNoKCBhbmNlc3RvciApO1xuXHRcdFx0XHRhbmNlc3RvciA9IGdldFBhcmVudCggYW5jZXN0b3IgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhbmNlc3RyeTtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnRCeURvY3VtZW50UG9zaXRpb24uanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlEb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24oIHNvcnRCeUl0ZW1Qb3NpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggbm9kZSwgb3RoZXJOb2RlICkge1xuXHRcdFx0dmFyIGJpdG1hc2s7XG5cdFx0XHRpZiAoIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gKSB7XG5cdFx0XHRcdGJpdG1hc2sgPSBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBvdGhlck5vZGUgKTtcblx0XHRcdFx0cmV0dXJuIGJpdG1hc2sgJiAyID8gMSA6IC0xO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSW4gb2xkIElFLCB3ZSBjYW4gcGlnZ3kgYmFjayBvbiB0aGUgbWVjaGFuaXNtIGZvclxuXHRcdFx0Ly8gY29tcGFyaW5nIGNvbXBvbmVudCBwb3NpdGlvbnNcblx0XHRcdHJldHVybiBzb3J0QnlJdGVtUG9zaXRpb24oIG5vZGUsIG90aGVyTm9kZSApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0ID0gZnVuY3Rpb24oIHNvcnRCeURvY3VtZW50UG9zaXRpb24sIHNvcnRCeUl0ZW1Qb3NpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc29ydCggdGhpcy5faXNDb21wb25lbnRRdWVyeSA/IHNvcnRCeUl0ZW1Qb3NpdGlvbiA6IHNvcnRCeURvY3VtZW50UG9zaXRpb24gKTtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeURvY3VtZW50UG9zaXRpb24sIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L2RpcnR5LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfZGlydHkgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0aWYgKCAhdGhpcy5fZGlydHkgKSB7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0Ly8gT25jZSB0aGUgRE9NIGhhcyBiZWVuIHVwZGF0ZWQsIGVuc3VyZSB0aGUgcXVlcnlcblx0XHRcdFx0Ly8gaXMgY29ycmVjdGx5IG9yZGVyZWRcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMkMC5fc29ydCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvcmVtb3ZlLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfcmVtb3ZlID0gZnVuY3Rpb24oIG5vZGVPckNvbXBvbmVudCApIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBub2RlT3JDb21wb25lbnQuaW5zdGFuY2UgOiBub2RlT3JDb21wb25lbnQgKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdHRoaXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L19tYWtlUXVlcnkuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9fbWFrZVF1ZXJ5ID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnRpZXMsIHRlc3QsIGNhbmNlbCwgc29ydCwgZGlydHksIHJlbW92ZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBtYWtlUXVlcnkoIHJhY3RpdmUsIHNlbGVjdG9yLCBsaXZlLCBpc0NvbXBvbmVudFF1ZXJ5ICkge1xuXHRcdFx0dmFyIHF1ZXJ5ID0gW107XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBxdWVyeSwge1xuXHRcdFx0XHRzZWxlY3Rvcjoge1xuXHRcdFx0XHRcdHZhbHVlOiBzZWxlY3RvclxuXHRcdFx0XHR9LFxuXHRcdFx0XHRsaXZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGxpdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X2lzQ29tcG9uZW50UXVlcnk6IHtcblx0XHRcdFx0XHR2YWx1ZTogaXNDb21wb25lbnRRdWVyeVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfdGVzdDoge1xuXHRcdFx0XHRcdHZhbHVlOiB0ZXN0XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGlmICggIWxpdmUgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnRpZXMoIHF1ZXJ5LCB7XG5cdFx0XHRcdGNhbmNlbDoge1xuXHRcdFx0XHRcdHZhbHVlOiBjYW5jZWxcblx0XHRcdFx0fSxcblx0XHRcdFx0X3Jvb3Q6IHtcblx0XHRcdFx0XHR2YWx1ZTogcmFjdGl2ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfc29ydDoge1xuXHRcdFx0XHRcdHZhbHVlOiBzb3J0XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9tYWtlRGlydHk6IHtcblx0XHRcdFx0XHR2YWx1ZTogZGlydHlcblx0XHRcdFx0fSxcblx0XHRcdFx0X3JlbW92ZToge1xuXHRcdFx0XHRcdHZhbHVlOiByZW1vdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X2RpcnR5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IGZhbHNlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBkZWZpbmVQcm9wZXJ0aWVzLCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfdGVzdCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2NhbmNlbCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnQsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9kaXJ0eSwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3JlbW92ZSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZEFsbCA9IGZ1bmN0aW9uKCBtYWtlUXVlcnkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsKCBzZWxlY3Rvciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cdFx0XHRpZiAoICF0aGlzLmVsICkge1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZVF1ZXJpZXM7XG5cdFx0XHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuXHRcdFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0aWYgKCBxdWVyeSA9IGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdICkge1xuXHRcdFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3Rcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0cXVlcnkgPSBtYWtlUXVlcnkoIHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgZmFsc2UgKTtcblx0XHRcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuXHRcdFx0Ly8gaWYgYXBwbGljYWJsZVxuXHRcdFx0aWYgKCBxdWVyeS5saXZlICkge1xuXHRcdFx0XHRsaXZlUXVlcmllcy5wdXNoKCBzZWxlY3RvciApO1xuXHRcdFx0XHRsaXZlUXVlcmllc1sgJ18nICsgc2VsZWN0b3IgXSA9IHF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24oIG1ha2VRdWVyeSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3Rvciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZUNvbXBvbmVudFF1ZXJpZXM7XG5cdFx0XHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuXHRcdFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0aWYgKCBxdWVyeSA9IGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdICkge1xuXHRcdFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3Rcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0cXVlcnkgPSBtYWtlUXVlcnkoIHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgdHJ1ZSApO1xuXHRcdFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG5cdFx0XHQvLyBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHF1ZXJ5LmxpdmUgKSB7XG5cdFx0XHRcdGxpdmVRdWVyaWVzLnB1c2goIHNlbGVjdG9yICk7XG5cdFx0XHRcdGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdID0gcXVlcnk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maXJlLmpzICovXG5cdHZhciBSYWN0aXZlJGZpcmUgPSBmdW5jdGlvbiBSYWN0aXZlJGZpcmUoIGV2ZW50TmFtZSApIHtcblx0XHR2YXIgYXJncywgaSwgbGVuLCBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNbIGV2ZW50TmFtZSBdO1xuXHRcdGlmICggIXN1YnNjcmliZXJzICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdGZvciAoIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHN1YnNjcmliZXJzWyBpIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZ2V0LmpzICovXG5cdHZhciBSYWN0aXZlJGdldCA9IGZ1bmN0aW9uKCBub3JtYWxpc2VLZXlwYXRoICkge1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRjYXB0dXJlOiB0cnVlXG5cdFx0fTtcblx0XHQvLyB0b3AtbGV2ZWwgY2FsbHMgc2hvdWxkIGJlIGludGVyY2VwdGVkXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZ2V0KCBrZXlwYXRoICkge1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdHJldHVybiB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGgsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHR9KCBub3JtYWxpc2VLZXlwYXRoICk7XG5cblx0LyogdXRpbHMvZ2V0RWxlbWVudC5qcyAqL1xuXHR2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldEVsZW1lbnQoIGlucHV0ICkge1xuXHRcdHZhciBvdXRwdXQ7XG5cdFx0aWYgKCAhaW5wdXQgfHwgdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWRvY3VtZW50IHx8ICFpbnB1dCApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHQvLyBXZSBhbHJlYWR5IGhhdmUgYSBET00gbm9kZSAtIG5vIHdvcmsgdG8gZG8uIChEdWNrIHR5cGluZyBhbGVydCEpXG5cdFx0aWYgKCBpbnB1dC5ub2RlVHlwZSApIHtcblx0XHRcdHJldHVybiBpbnB1dDtcblx0XHR9XG5cdFx0Ly8gR2V0IG5vZGUgZnJvbSBzdHJpbmdcblx0XHRpZiAoIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHQvLyB0cnkgSUQgZmlyc3Rcblx0XHRcdG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBpbnB1dCApO1xuXHRcdFx0Ly8gdGhlbiBhcyBzZWxlY3RvciwgaWYgcG9zc2libGVcblx0XHRcdGlmICggIW91dHB1dCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICkge1xuXHRcdFx0XHRvdXRwdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBpbnB1dCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZGlkIGl0IHdvcms/XG5cdFx0XHRpZiAoIG91dHB1dCAmJiBvdXRwdXQubm9kZVR5cGUgKSB7XG5cdFx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBjb2xsZWN0aW9uIChqUXVlcnksIFplcHRvIGV0YyksIGV4dHJhY3QgdGhlIGZpcnN0IGl0ZW1cblx0XHRpZiAoIGlucHV0WyAwIF0gJiYgaW5wdXRbIDAgXS5ub2RlVHlwZSApIHtcblx0XHRcdHJldHVybiBpbnB1dFsgMCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9pbnNlcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkaW5zZXJ0ID0gZnVuY3Rpb24oIGdldEVsZW1lbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRpbnNlcnQoIHRhcmdldCwgYW5jaG9yICkge1xuXHRcdFx0aWYgKCAhdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0Ly8gVE9ETyBjcmVhdGUsIGFuZCBsaW5rIHRvLCBkb2N1bWVudGF0aW9uIGV4cGxhaW5pbmcgdGhpc1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgQVBJIGhhcyBjaGFuZ2VkIC0geW91IG11c3QgY2FsbCBgcmFjdGl2ZS5yZW5kZXIodGFyZ2V0WywgYW5jaG9yXSlgIHRvIHJlbmRlciB5b3VyIFJhY3RpdmUgaW5zdGFuY2UuIE9uY2UgcmVuZGVyZWQgeW91IGNhbiB1c2UgYHJhY3RpdmUuaW5zZXJ0KClgLicgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9IGdldEVsZW1lbnQoIHRhcmdldCApO1xuXHRcdFx0YW5jaG9yID0gZ2V0RWxlbWVudCggYW5jaG9yICkgfHwgbnVsbDtcblx0XHRcdGlmICggIXRhcmdldCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IG11c3Qgc3BlY2lmeSBhIHZhbGlkIHRhcmdldCB0byBpbnNlcnQgaW50bycgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZGV0YWNoKCksIGFuY2hvciApO1xuXHRcdFx0dGhpcy5lbCA9IHRhcmdldDtcblx0XHRcdCggdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyB8fCAoIHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbXSApICkucHVzaCggdGhpcyApO1xuXHRcdH07XG5cdH0oIGdldEVsZW1lbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9tZXJnZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRtZXJnZSA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0FycmF5LCBub3JtYWxpc2VLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkbWVyZ2UoIGtleXBhdGgsIGFycmF5LCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGN1cnJlbnRBcnJheSwgcHJvbWlzZTtcblx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRjdXJyZW50QXJyYXkgPSB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdC8vIElmIGVpdGhlciB0aGUgZXhpc3RpbmcgdmFsdWUgb3IgdGhlIG5ldyB2YWx1ZSBpc24ndCBhblxuXHRcdFx0Ly8gYXJyYXksIGp1c3QgZG8gYSByZWd1bGFyIHNldFxuXHRcdFx0aWYgKCAhaXNBcnJheSggY3VycmVudEFycmF5ICkgfHwgIWlzQXJyYXkoIGFycmF5ICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNldCgga2V5cGF0aCwgYXJyYXksIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wbGV0ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTWFuYWdlIHRyYW5zaXRpb25zXG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwubWVyZ2UoIGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMgKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHQvLyBhdHRhY2ggY2FsbGJhY2sgYXMgZnVsZmlsbWVudCBoYW5kbGVyLCBpZiBzcGVjaWZpZWRcblx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXRlICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIG9wdGlvbnMuY29tcGxldGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGlzQXJyYXksIG5vcm1hbGlzZUtleXBhdGggKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL09ic2VydmVyLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfT2JzZXJ2ZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNFcXVhbCApIHtcblxuXHRcdHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cdFx0XHQvLyBPYnNlcnZlcnMgYXJlIG5vdGlmaWVkIGJlZm9yZSBhbnkgRE9NIGNoYW5nZXMgdGFrZSBwbGFjZSAodGhvdWdoXG5cdFx0XHQvLyB0aGV5IGNhbiBkZWZlciBleGVjdXRpb24gdW50aWwgYWZ0ZXJ3YXJkcylcblx0XHRcdHRoaXMucHJpb3JpdHkgPSAwO1xuXHRcdFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG5cdFx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG5cdFx0fTtcblx0XHRPYnNlcnZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggaW1tZWRpYXRlICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGltbWVkaWF0ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGUoKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2suY2FsbCggdGhpcy5jb250ZXh0LCB0aGlzLnZhbHVlLCB0aGlzLm9sZFZhbHVlLCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBPYnNlcnZlcjtcblx0fSggcnVubG9vcCwgaXNFcXVhbCApO1xuXG5cdC8qIHNoYXJlZC9nZXRNYXRjaGluZ0tleXBhdGhzLmpzICovXG5cdHZhciBnZXRNYXRjaGluZ0tleXBhdGhzID0gZnVuY3Rpb24oIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TWF0Y2hpbmdLZXlwYXRocyggcmFjdGl2ZSwgcGF0dGVybiApIHtcblx0XHRcdHZhciBrZXlzLCBrZXksIG1hdGNoaW5nS2V5cGF0aHM7XG5cdFx0XHRrZXlzID0gcGF0dGVybi5zcGxpdCggJy4nICk7XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gWyAnJyBdO1xuXHRcdFx0d2hpbGUgKCBrZXkgPSBrZXlzLnNoaWZ0KCkgKSB7XG5cdFx0XHRcdGlmICgga2V5ID09PSAnKicgKSB7XG5cdFx0XHRcdFx0Ly8gZXhwYW5kIHRvIGZpbmQgYWxsIHZhbGlkIGNoaWxkIGtleXBhdGhzXG5cdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMucmVkdWNlKCBleHBhbmQsIFtdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGluZ0tleXBhdGhzWyAwIF0gPT09ICcnICkge1xuXHRcdFx0XHRcdFx0Ly8gZmlyc3Qga2V5XG5cdFx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzWyAwIF0gPSBrZXk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLm1hcCggY29uY2F0ZW5hdGUoIGtleSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hpbmdLZXlwYXRocztcblxuXHRcdFx0ZnVuY3Rpb24gZXhwYW5kKCBtYXRjaGluZ0tleXBhdGhzLCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGtleSwgY2hpbGRLZXlwYXRoO1xuXHRcdFx0XHR2YWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIGtleXBhdGggXSA/IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIGtleXBhdGggXS5nZXQoKSA6IHJhY3RpdmUuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdGZvciAoIGtleSBpbiB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHZhbHVlLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiAoIGtleSAhPT0gJ19yYWN0aXZlJyB8fCAhaXNBcnJheSggdmFsdWUgKSApICkge1xuXHRcdFx0XHRcdFx0Ly8gZm9yIGJlbmVmaXQgb2YgSUU4XG5cdFx0XHRcdFx0XHRjaGlsZEtleXBhdGggPSBrZXlwYXRoID8ga2V5cGF0aCArICcuJyArIGtleSA6IGtleTtcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMucHVzaCggY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb25jYXRlbmF0ZSgga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGtleXBhdGggPyBrZXlwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL2dldFBhdHRlcm4uanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZV9nZXRQYXR0ZXJuID0gZnVuY3Rpb24oIGdldE1hdGNoaW5nS2V5cGF0aHMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UGF0dGVybiggcmFjdGl2ZSwgcGF0dGVybiApIHtcblx0XHRcdHZhciBtYXRjaGluZ0tleXBhdGhzLCB2YWx1ZXM7XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gZ2V0TWF0Y2hpbmdLZXlwYXRocyggcmFjdGl2ZSwgcGF0dGVybiApO1xuXHRcdFx0dmFsdWVzID0ge307XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YWx1ZXNbIGtleXBhdGggXSA9IHJhY3RpdmUuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdH07XG5cdH0oIGdldE1hdGNoaW5nS2V5cGF0aHMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL1BhdHRlcm5PYnNlcnZlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX1BhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0VxdWFsLCBnZXRQYXR0ZXJuICkge1xuXG5cdFx0dmFyIFBhdHRlcm5PYnNlcnZlciwgd2lsZGNhcmQgPSAvXFwqLyxcblx0XHRcdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdFBhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLnJlZ2V4ID0gbmV3IFJlZ0V4cCggJ14nICsga2V5cGF0aC5yZXBsYWNlKCAvXFwuL2csICdcXFxcLicgKS5yZXBsYWNlKCAvXFwqL2csICcoW15cXFxcLl0rKScgKSArICckJyApO1xuXHRcdFx0dGhpcy52YWx1ZXMgPSB7fTtcblx0XHRcdGlmICggdGhpcy5kZWZlciApIHtcblx0XHRcdFx0dGhpcy5wcm94aWVzID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBPYnNlcnZlcnMgYXJlIG5vdGlmaWVkIGJlZm9yZSBhbnkgRE9NIGNoYW5nZXMgdGFrZSBwbGFjZSAodGhvdWdoXG5cdFx0XHQvLyB0aGV5IGNhbiBkZWZlciBleGVjdXRpb24gdW50aWwgYWZ0ZXJ3YXJkcylcblx0XHRcdHRoaXMucHJpb3JpdHkgPSAncGF0dGVybic7XG5cdFx0XHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cblx0XHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcblx0XHR9O1xuXHRcdFBhdHRlcm5PYnNlcnZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggaW1tZWRpYXRlICkge1xuXHRcdFx0XHR2YXIgdmFsdWVzLCBrZXlwYXRoO1xuXHRcdFx0XHR2YWx1ZXMgPSBnZXRQYXR0ZXJuKCB0aGlzLnJvb3QsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGltbWVkaWF0ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiB2YWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlcy5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXM7XG5cdFx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IGdldFBhdHRlcm4oIHRoaXMucm9vdCwga2V5cGF0aCApO1xuXHRcdFx0XHRcdGZvciAoIGtleXBhdGggaW4gdmFsdWVzICkge1xuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZXMuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGFycmF5IG11dGF0aW9uIHNob3VsZCBub3QgdHJpZ2dlciBgYXJyYXkuKmBcblx0XHRcdFx0Ly8gcGF0dGVybiBvYnNlcnZlciB3aXRoIGBhcnJheS5sZW5ndGhgXG5cdFx0XHRcdGlmICggdGhpcy5yb290LnZpZXdtb2RlbC5pbXBsaWNpdENoYW5nZXNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRPYnNlcnZlciggdGhpcy5nZXRQcm94eSgga2V5cGF0aCApICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVhbGx5VXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVhbGx5VXBkYXRlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBrZXlzLCBhcmdzO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlc1sga2V5cGF0aCBdICkgfHwgIXRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0a2V5cyA9IHNsaWNlLmNhbGwoIHRoaXMucmVnZXguZXhlYygga2V5cGF0aCApLCAxICk7XG5cdFx0XHRcdFx0YXJncyA9IFtcblx0XHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSxcblx0XHRcdFx0XHRcdGtleXBhdGhcblx0XHRcdFx0XHRdLmNvbmNhdCgga2V5cyApO1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2suYXBwbHkoIHRoaXMuY29udGV4dCwgYXJncyApO1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0UHJveHk6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdGlmICggIXRoaXMucHJveGllc1sga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHRoaXMucHJveGllc1sga2V5cGF0aCBdID0ge1xuXHRcdFx0XHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5yZWFsbHlVcGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLnByb3hpZXNbIGtleXBhdGggXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBQYXR0ZXJuT2JzZXJ2ZXI7XG5cdH0oIHJ1bmxvb3AsIGlzRXF1YWwsIFJhY3RpdmUkb2JzZXJ2ZV9nZXRQYXR0ZXJuICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS9nZXRPYnNlcnZlckZhY2FkZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlID0gZnVuY3Rpb24oIG5vcm1hbGlzZUtleXBhdGgsIE9ic2VydmVyLCBQYXR0ZXJuT2JzZXJ2ZXIgKSB7XG5cblx0XHR2YXIgd2lsZGNhcmQgPSAvXFwqLyxcblx0XHRcdGVtcHR5T2JqZWN0ID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldE9ic2VydmVyRmFjYWRlKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIsIGNhbmNlbGxlZDtcblx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCBlbXB0eU9iamVjdDtcblx0XHRcdC8vIHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5XG5cdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0b2JzZXJ2ZXIgPSBuZXcgUGF0dGVybk9ic2VydmVyKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnB1c2goIG9ic2VydmVyICk7XG5cdFx0XHRcdGlzUGF0dGVybk9ic2VydmVyID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9ic2VydmVyID0gbmV3IE9ic2VydmVyKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciA/ICdwYXR0ZXJuT2JzZXJ2ZXJzJyA6ICdvYnNlcnZlcnMnICk7XG5cdFx0XHRvYnNlcnZlci5pbml0KCBvcHRpb25zLmluaXQgKTtcblx0XHRcdC8vIFRoaXMgZmxhZyBhbGxvd3Mgb2JzZXJ2ZXJzIHRvIGluaXRpYWxpc2UgZXZlbiB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdG9ic2VydmVyLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdGlmICggY2FuY2VsbGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGlzUGF0dGVybk9ic2VydmVyICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSByYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmluZGV4T2YoIG9ic2VydmVyICk7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoIGtleXBhdGgsIG9ic2VydmVyLCAncGF0dGVybk9ic2VydmVycycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsICdvYnNlcnZlcnMnICk7XG5cdFx0XHRcdFx0Y2FuY2VsbGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCBub3JtYWxpc2VLZXlwYXRoLCBSYWN0aXZlJG9ic2VydmVfT2JzZXJ2ZXIsIFJhY3RpdmUkb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmUgPSBmdW5jdGlvbiggaXNPYmplY3QsIGdldE9ic2VydmVyRmFjYWRlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZSgga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgb2JzZXJ2ZXJzLCBtYXAsIGtleXBhdGhzLCBpO1xuXHRcdFx0Ly8gQWxsb3cgYSBtYXAgb2Yga2V5cGF0aHMgdG8gaGFuZGxlcnNcblx0XHRcdGlmICggaXNPYmplY3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdFx0XHRtYXAgPSBrZXlwYXRoO1xuXHRcdFx0XHRvYnNlcnZlcnMgPSBbXTtcblx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0aWYgKCBtYXAuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbWFwWyBrZXlwYXRoIF07XG5cdFx0XHRcdFx0XHRvYnNlcnZlcnMucHVzaCggdGhpcy5vYnNlcnZlKCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHdoaWxlICggb2JzZXJ2ZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIEFsbG93IGByYWN0aXZlLm9ic2VydmUoIGNhbGxiYWNrIClgIC0gaS5lLiBvYnNlcnZlIGVudGlyZSBtb2RlbFxuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdFx0cmV0dXJuIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0a2V5cGF0aHMgPSBrZXlwYXRoLnNwbGl0KCAnICcgKTtcblx0XHRcdC8vIFNpbmdsZSBrZXlwYXRoXG5cdFx0XHRpZiAoIGtleXBhdGhzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGtleXBhdGhzXG5cdFx0XHRvYnNlcnZlcnMgPSBbXTtcblx0XHRcdGkgPSBrZXlwYXRocy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0a2V5cGF0aCA9IGtleXBhdGhzWyBpIF07XG5cdFx0XHRcdGlmICgga2V5cGF0aCApIHtcblx0XHRcdFx0XHRvYnNlcnZlcnMucHVzaCggZ2V0T2JzZXJ2ZXJGYWNhZGUoIHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR3aGlsZSAoIG9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIGlzT2JqZWN0LCBSYWN0aXZlJG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvdHJpbS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfdHJpbSA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0cmV0dXJuIHN0ci50cmltKCk7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL25vdEVtcHR5U3RyaW5nLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9ub3RFbXB0eVN0cmluZyA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0cmV0dXJuIHN0ciAhPT0gJyc7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2ZmLmpzICovXG5cdHZhciBSYWN0aXZlJG9mZiA9IGZ1bmN0aW9uKCB0cmltLCBub3RFbXB0eVN0cmluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG9mZiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIGV2ZW50TmFtZXM7XG5cdFx0XHQvLyBpZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkLCByZW1vdmUgYWxsIGNhbGxiYWNrc1xuXHRcdFx0aWYgKCAhZXZlbnROYW1lICkge1xuXHRcdFx0XHQvLyBUT0RPIHVzZSB0aGlzIGNvZGUgaW5zdGVhZCwgb25jZSB0aGUgZm9sbG93aW5nIGlzc3VlIGhhcyBiZWVuIHJlc29sdmVkXG5cdFx0XHRcdC8vIGluIFBoYW50b21KUyAodGVzdHMgYXJlIHVucGFzc2FibGUgb3RoZXJ3aXNlISlcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTE4NTZcblx0XHRcdFx0Ly8gZGVmaW5lUHJvcGVydHkoIHRoaXMsICdfc3VicycsIHsgdmFsdWU6IGNyZWF0ZSggbnVsbCApLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cdFx0XHRcdGZvciAoIGV2ZW50TmFtZSBpbiB0aGlzLl9zdWJzICkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9zdWJzWyBldmVudE5hbWUgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuXHRcdFx0XHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KCAnICcgKS5tYXAoIHRyaW0gKS5maWx0ZXIoIG5vdEVtcHR5U3RyaW5nICk7XG5cdFx0XHRcdGV2ZW50TmFtZXMuZm9yRWFjaCggZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0XHR2YXIgc3Vic2NyaWJlcnMsIGluZGV4O1xuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgc3Vic2NyaWJlcnMgZm9yIHRoaXMgZXZlbnQuLi5cblx0XHRcdFx0XHRpZiAoIHN1YnNjcmliZXJzID0gdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSApIHtcblx0XHRcdFx0XHRcdC8vIC4uLmlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgb25seSByZW1vdmUgdGhhdFxuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKCBjYWxsYmFjayApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0XHRzdWJzY3JpYmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX3RyaW0sIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb24uanMgKi9cblx0dmFyIFJhY3RpdmUkb24gPSBmdW5jdGlvbiggdHJpbSwgbm90RW1wdHlTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRvbiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRsaXN0ZW5lcnMsIG4sIGV2ZW50TmFtZXM7XG5cdFx0XHQvLyBhbGxvdyBtdXRsaXBsZSBsaXN0ZW5lcnMgdG8gYmUgYm91bmQgaW4gb25lIGdvXG5cdFx0XHRpZiAoIHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRsaXN0ZW5lcnMgPSBbXTtcblx0XHRcdFx0Zm9yICggbiBpbiBldmVudE5hbWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudE5hbWUuaGFzT3duUHJvcGVydHkoIG4gKSApIHtcblx0XHRcdFx0XHRcdGxpc3RlbmVycy5wdXNoKCB0aGlzLm9uKCBuLCBldmVudE5hbWVbIG4gXSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBsaXN0ZW5lcjtcblx0XHRcdFx0XHRcdHdoaWxlICggbGlzdGVuZXIgPSBsaXN0ZW5lcnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcblx0XHRcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoICcgJyApLm1hcCggdHJpbSApLmZpbHRlciggbm90RW1wdHlTdHJpbmcgKTtcblx0XHRcdGV2ZW50TmFtZXMuZm9yRWFjaCggZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0KCB0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdIHx8ICggdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSA9IFtdICkgKS5wdXNoKCBjYWxsYmFjayApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLm9mZiggZXZlbnROYW1lLCBjYWxsYmFjayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX3RyaW0sIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nICk7XG5cblx0Lyogc2hhcmVkL2dldFNwbGljZUVxdWl2YWxlbnQuanMgKi9cblx0dmFyIGdldFNwbGljZUVxdWl2YWxlbnQgPSBmdW5jdGlvbiggYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MgKSB7XG5cdFx0c3dpdGNoICggbWV0aG9kTmFtZSApIHtcblx0XHRcdGNhc2UgJ3NwbGljZSc6XG5cdFx0XHRcdHJldHVybiBhcmdzO1xuXHRcdFx0Y2FzZSAnc29ydCc6XG5cdFx0XHRjYXNlICdyZXZlcnNlJzpcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRjYXNlICdwb3AnOlxuXHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gWyAtMSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0Y2FzZSAncHVzaCc6XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0YXJyYXkubGVuZ3RoLFxuXHRcdFx0XHRcdDBcblx0XHRcdFx0XS5jb25jYXQoIGFyZ3MgKTtcblx0XHRcdGNhc2UgJ3NoaWZ0Jzpcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdDFcblx0XHRcdFx0XTtcblx0XHRcdGNhc2UgJ3Vuc2hpZnQnOlxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0MFxuXHRcdFx0XHRdLmNvbmNhdCggYXJncyApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBzaGFyZWQvc3VtbWFyaXNlU3BsaWNlT3BlcmF0aW9uLmpzICovXG5cdHZhciBzdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24gPSBmdW5jdGlvbiggYXJyYXksIGFyZ3MgKSB7XG5cdFx0dmFyIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBuZXdMZW5ndGgsIGFkZGVkSXRlbXMsIHJlbW92ZWRJdGVtcywgYmFsYW5jZTtcblx0XHRpZiAoICFhcmdzICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdC8vIGZpZ3VyZSBvdXQgd2hlcmUgdGhlIGNoYW5nZXMgc3RhcnRlZC4uLlxuXHRcdHJhbmdlU3RhcnQgPSArKCBhcmdzWyAwIF0gPCAwID8gYXJyYXkubGVuZ3RoICsgYXJnc1sgMCBdIDogYXJnc1sgMCBdICk7XG5cdFx0Ly8gLi4uYW5kIGhvdyBtYW55IGl0ZW1zIHdlcmUgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheVxuXHRcdGFkZGVkSXRlbXMgPSBNYXRoLm1heCggMCwgYXJncy5sZW5ndGggLSAyICk7XG5cdFx0cmVtb3ZlZEl0ZW1zID0gYXJnc1sgMSBdICE9PSB1bmRlZmluZWQgPyBhcmdzWyAxIF0gOiBhcnJheS5sZW5ndGggLSByYW5nZVN0YXJ0O1xuXHRcdC8vIEl0J3MgcG9zc2libGUgdG8gZG8gZS5nLiBbIDEsIDIsIDMgXS5zcGxpY2UoIDIsIDIgKSAtIGkuZS4gdGhlIHNlY29uZCBhcmd1bWVudFxuXHRcdC8vIG1lYW5zIHJlbW92aW5nIG1vcmUgaXRlbXMgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheSB0aGFuIHRoZXJlIGFyZS4gSW4gdGhlc2Vcblx0XHQvLyBjYXNlcyB3ZSBuZWVkIHRvIGN1cmIgSmF2YVNjcmlwdCdzIGVudGh1c2lhc20gb3Igd2UnbGwgZ2V0IG91dCBvZiBzeW5jXG5cdFx0cmVtb3ZlZEl0ZW1zID0gTWF0aC5taW4oIHJlbW92ZWRJdGVtcywgYXJyYXkubGVuZ3RoIC0gcmFuZ2VTdGFydCApO1xuXHRcdGJhbGFuY2UgPSBhZGRlZEl0ZW1zIC0gcmVtb3ZlZEl0ZW1zO1xuXHRcdG5ld0xlbmd0aCA9IGFycmF5Lmxlbmd0aCArIGJhbGFuY2U7XG5cdFx0Ly8gV2UgbmVlZCB0byBmaW5kIHRoZSBlbmQgb2YgdGhlIHJhbmdlIGFmZmVjdGVkIGJ5IHRoZSBzcGxpY2Vcblx0XHRpZiAoICFiYWxhbmNlICkge1xuXHRcdFx0cmFuZ2VFbmQgPSByYW5nZVN0YXJ0ICsgYWRkZWRJdGVtcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFuZ2VFbmQgPSBNYXRoLm1heCggYXJyYXkubGVuZ3RoLCBuZXdMZW5ndGggKTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJhbmdlU3RhcnQ6IHJhbmdlU3RhcnQsXG5cdFx0XHRyYW5nZUVuZDogcmFuZ2VFbmQsXG5cdFx0XHRiYWxhbmNlOiBiYWxhbmNlLFxuXHRcdFx0YWRkZWQ6IGFkZGVkSXRlbXMsXG5cdFx0XHRyZW1vdmVkOiByZW1vdmVkSXRlbXNcblx0XHR9O1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlQXJyYXlNZXRob2QuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCA9IGZ1bmN0aW9uKCBpc0FycmF5LCBydW5sb29wLCBnZXRTcGxpY2VFcXVpdmFsZW50LCBzdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24gKSB7XG5cblx0XHR2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIG1ldGhvZE5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdFx0XHR2YXIgYXJncyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0XHRcdHZhciBhcnJheSwgc3BsaWNlRXF1aXZhbGVudCwgc3BsaWNlU3VtbWFyeSwgcHJvbWlzZTtcblx0XHRcdFx0YXJyYXkgPSB0aGlzLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoICFpc0FycmF5KCBhcnJheSApICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NhbGxlZCByYWN0aXZlLicgKyBtZXRob2ROYW1lICsgJyhcXCcnICsga2V5cGF0aCArICdcXCcpLCBidXQgXFwnJyArIGtleXBhdGggKyAnXFwnIGRvZXMgbm90IHJlZmVyIHRvIGFuIGFycmF5JyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNwbGljZUVxdWl2YWxlbnQgPSBnZXRTcGxpY2VFcXVpdmFsZW50KCBhcnJheSwgbWV0aG9kTmFtZSwgYXJncyApO1xuXHRcdFx0XHRzcGxpY2VTdW1tYXJ5ID0gc3VtbWFyaXNlU3BsaWNlT3BlcmF0aW9uKCBhcnJheSwgc3BsaWNlRXF1aXZhbGVudCApO1xuXHRcdFx0XHRhcnJheVByb3RvWyBtZXRob2ROYW1lIF0uYXBwbHkoIGFycmF5LCBhcmdzICk7XG5cdFx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHRcdGlmICggc3BsaWNlU3VtbWFyeSApIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zcGxpY2UoIGtleXBhdGgsIHNwbGljZVN1bW1hcnkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIGlzQXJyYXksIHJ1bmxvb3AsIGdldFNwbGljZUVxdWl2YWxlbnQsIHN1bW1hcmlzZVNwbGljZU9wZXJhdGlvbiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3BvcC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRwb3AgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3BvcCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcHVzaC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRwdXNoID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdwdXNoJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBnbG9iYWwvY3NzLmpzICovXG5cdHZhciBnbG9iYWxfY3NzID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBpc0NsaWVudCwgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIGNzcywgdXBkYXRlLCBydW5sb29wLCBzdHlsZUVsZW1lbnQsIGhlYWQsIHN0eWxlU2hlZXQsIGluRG9tLCBwcmVmaXggPSAnLyogUmFjdGl2ZS5qcyBjb21wb25lbnQgc3R5bGVzICovXFxuJyxcblx0XHRcdGNvbXBvbmVudHNJblBhZ2UgPSB7fSxcblx0XHRcdHN0eWxlcyA9IFtdO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Y3NzID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3AgPSBjaXJjdWxhci5ydW5sb29wO1xuXHRcdFx0fSApO1xuXHRcdFx0c3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3N0eWxlJyApO1xuXHRcdFx0c3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnO1xuXHRcdFx0aGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnaGVhZCcgKVsgMCBdO1xuXHRcdFx0aW5Eb20gPSBmYWxzZTtcblx0XHRcdC8vIEludGVybmV0IEV4cGxvZGVyIHdvbid0IGxldCB5b3UgdXNlIHN0eWxlU2hlZXQuaW5uZXJIVE1MIC0gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gdXNlIHN0eWxlU2hlZXQuY3NzVGV4dCBpbnN0ZWFkXG5cdFx0XHRzdHlsZVNoZWV0ID0gc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQ7XG5cdFx0XHR1cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGNzcztcblx0XHRcdFx0aWYgKCBzdHlsZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGNzcyA9IHByZWZpeCArIHN0eWxlcy5qb2luKCAnICcgKTtcblx0XHRcdFx0XHRpZiAoIHN0eWxlU2hlZXQgKSB7XG5cdFx0XHRcdFx0XHRzdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBjc3M7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWluRG9tICkge1xuXHRcdFx0XHRcdFx0aGVhZC5hcHBlbmRDaGlsZCggc3R5bGVFbGVtZW50ICk7XG5cdFx0XHRcdFx0XHRpbkRvbSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpbkRvbSApIHtcblx0XHRcdFx0XHRoZWFkLnJlbW92ZUNoaWxkKCBzdHlsZUVsZW1lbnQgKTtcblx0XHRcdFx0XHRpbkRvbSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0Y3NzID0ge1xuXHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKCBDb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhQ29tcG9uZW50LmNzcyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0XHQvLyB3ZSBjcmVhdGUgdGhpcyBjb3VudGVyIHNvIHRoYXQgd2UgY2FuIGluL2RlY3JlbWVudCBpdCBhc1xuXHRcdFx0XHRcdFx0Ly8gaW5zdGFuY2VzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZC4gV2hlbiBhbGwgY29tcG9uZW50cyBhcmVcblx0XHRcdFx0XHRcdC8vIHJlbW92ZWQsIHRoZSBzdHlsZSBpcyB0b29cblx0XHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdID0gMDtcblx0XHRcdFx0XHRcdHN0eWxlcy5wdXNoKCBDb21wb25lbnQuY3NzICk7XG5cdFx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggdXBkYXRlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICs9IDE7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIENvbXBvbmVudCApIHtcblx0XHRcdFx0XHRpZiAoICFDb21wb25lbnQuY3NzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSAtPSAxO1xuXHRcdFx0XHRcdGlmICggIWNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBzdHlsZXMsIENvbXBvbmVudC5jc3MgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCB1cGRhdGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjc3M7XG5cdH0oIGNpcmN1bGFyLCBpc0NsaWVudCwgcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciBSYWN0aXZlJHJlbmRlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBjc3MsIGdldEVsZW1lbnQgKSB7XG5cblx0XHR2YXIgcXVldWVzID0ge30sXG5cdFx0XHRyZW5kZXJpbmcgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZW5kZXIoIHRhcmdldCwgYW5jaG9yICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcHJvbWlzZSwgaW5zdGFuY2VzO1xuXHRcdFx0cmVuZGVyaW5nWyB0aGlzLl9ndWlkIF0gPSB0cnVlO1xuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IGNhbm5vdCBjYWxsIHJhY3RpdmUucmVuZGVyKCkgb24gYW4gYWxyZWFkeSByZW5kZXJlZCBpbnN0YW5jZSEgQ2FsbCByYWN0aXZlLnVucmVuZGVyKCkgZmlyc3QnICk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQgPSBnZXRFbGVtZW50KCB0YXJnZXQgKSB8fCB0aGlzLmVsO1xuXHRcdFx0YW5jaG9yID0gZ2V0RWxlbWVudCggYW5jaG9yICkgfHwgdGhpcy5hbmNob3I7XG5cdFx0XHR0aGlzLmVsID0gdGFyZ2V0O1xuXHRcdFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cdFx0XHQvLyBBZGQgQ1NTLCBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHRoaXMuY29uc3RydWN0b3IuY3NzICkge1xuXHRcdFx0XHRjc3MuYWRkKCB0aGlzLmNvbnN0cnVjdG9yICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRhcmdldCApIHtcblx0XHRcdFx0aWYgKCAhKCBpbnN0YW5jZXMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFsgdGhpcyBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGluc3RhbmNlcy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhbmNob3IgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSwgYW5jaG9yICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCB0aGlzLmZyYWdtZW50LnJlbmRlcigpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIE9ubHkgaW5pdCBvbmNlLCB1bnRpbCB3ZSByZXdvcmsgbGlmZWN5Y2xlIGV2ZW50c1xuXHRcdFx0aWYgKCAhdGhpcy5faGFzSW5pdGVkICkge1xuXHRcdFx0XHR0aGlzLl9oYXNJbml0ZWQgPSB0cnVlO1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzICppc24ndCogYSBjaGlsZCBvZiBhIGNvbXBvbmVudCB0aGF0J3MgaW4gdGhlIHByb2Nlc3Mgb2YgcmVuZGVyaW5nLFxuXHRcdFx0XHQvLyBpdCBzaG91bGQgY2FsbCBhbnkgYGluaXQoKWAgbWV0aG9kcyBhdCB0aGlzIHBvaW50XG5cdFx0XHRcdGlmICggIXRoaXMuX3BhcmVudCB8fCAhcmVuZGVyaW5nWyB0aGlzLl9wYXJlbnQuX2d1aWQgXSApIHtcblx0XHRcdFx0XHRpbml0KCB0aGlzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2V0Q2hpbGRJbml0UXVldWUoIHRoaXMuX3BhcmVudCApLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVuZGVyaW5nWyB0aGlzLl9ndWlkIF0gPSBmYWxzZTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRcdGlmICggdGhpcy5jb21wbGV0ZSApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmNvbXBsZXRlKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0KCBpbnN0YW5jZSApIHtcblx0XHRcdGlmICggaW5zdGFuY2UuaW5pdCApIHtcblx0XHRcdFx0aW5zdGFuY2UuaW5pdCggaW5zdGFuY2UuX2NvbmZpZy5vcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRnZXRDaGlsZEluaXRRdWV1ZSggaW5zdGFuY2UgKS5mb3JFYWNoKCBpbml0ICk7XG5cdFx0XHRxdWV1ZXNbIGluc3RhbmNlLl9ndWlkIF0gPSBudWxsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENoaWxkSW5pdFF1ZXVlKCBpbnN0YW5jZSApIHtcblx0XHRcdHJldHVybiBxdWV1ZXNbIGluc3RhbmNlLl9ndWlkIF0gfHwgKCBxdWV1ZXNbIGluc3RhbmNlLl9ndWlkIF0gPSBbXSApO1xuXHRcdH1cblx0fSggcnVubG9vcCwgZ2xvYmFsX2NzcywgZ2V0RWxlbWVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRidWJibGUgPSBmdW5jdGlvbiBGcmFnbWVudCRidWJibGUoKSB7XG5cdFx0dGhpcy5kaXJ0eVZhbHVlID0gdGhpcy5kaXJ0eUFyZ3MgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5pbml0ZWQgJiYgdGhpcy5vd25lci5idWJibGUgKSB7XG5cdFx0XHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZGV0YWNoID0gZnVuY3Rpb24gRnJhZ21lbnQkZGV0YWNoKCkge1xuXHRcdHZhciBkb2NGcmFnO1xuXHRcdGlmICggdGhpcy5pdGVtcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVtc1sgMCBdLmRldGFjaCgpO1xuXHRcdH1cblx0XHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKCBpdGVtLmRldGFjaCgpICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiBkb2NGcmFnO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmQgJiYgKCBxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZCggc2VsZWN0b3IgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuLCBpdGVtO1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRBbGwgKSB7XG5cdFx0XHRcdFx0aXRlbS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcXVlcnk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW07XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZEFsbENvbXBvbmVudHMgKSB7XG5cdFx0XHRcdFx0aXRlbS5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBsZW4sIGksIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRDb21wb25lbnQgJiYgKCBxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kTmV4dE5vZGUoIGl0ZW0gKSB7XG5cdFx0dmFyIGluZGV4ID0gaXRlbS5pbmRleCxcblx0XHRcdG5vZGU7XG5cdFx0aWYgKCB0aGlzLml0ZW1zWyBpbmRleCArIDEgXSApIHtcblx0XHRcdG5vZGUgPSB0aGlzLml0ZW1zWyBpbmRleCArIDEgXS5maXJzdE5vZGUoKTtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLm93bmVyID09PSB0aGlzLnJvb3QgKSB7XG5cdFx0XHRpZiAoICF0aGlzLm93bmVyLmNvbXBvbmVudCApIHtcblx0XHRcdFx0Ly8gVE9ETyBidXQgc29tZXRoaW5nIGVsc2UgY291bGQgaGF2ZSBiZWVuIGFwcGVuZGVkIHRvXG5cdFx0XHRcdC8vIHRoaXMucm9vdC5lbCwgbm8/XG5cdFx0XHRcdG5vZGUgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMub3duZXIuY29tcG9uZW50LmZpbmROZXh0Tm9kZSgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRub2RlID0gdGhpcy5vd25lci5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpcnN0Tm9kZSgpIHtcblx0XHRpZiAoIHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXNbIDAgXS5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZ2V0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRnZXROb2RlID0gZnVuY3Rpb24gRnJhZ21lbnQkZ2V0Tm9kZSgpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSB0aGlzO1xuXHRcdGRvIHtcblx0XHRcdGlmICggZnJhZ21lbnQucEVsZW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBmcmFnbWVudC5wRWxlbWVudC5ub2RlO1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCBmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCApO1xuXHRcdHJldHVybiB0aGlzLnJvb3QuZWw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZ2V0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0VmFsdWUgPSBmdW5jdGlvbiggcGFyc2VKU09OICkge1xuXG5cdFx0dmFyIGVtcHR5ID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEZyYWdtZW50JGdldFZhbHVlKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IGVtcHR5O1xuXHRcdFx0dmFyIGFzQXJncywgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgY2FjaGVkUmVzdWx0LCBkaXJ0eUZsYWcsIHJlc3VsdDtcblx0XHRcdGFzQXJncyA9IG9wdGlvbnMuYXJncztcblx0XHRcdGNhY2hlZFJlc3VsdCA9IGFzQXJncyA/ICdhcmdzTGlzdCcgOiAndmFsdWUnO1xuXHRcdFx0ZGlydHlGbGFnID0gYXNBcmdzID8gJ2RpcnR5QXJncycgOiAnZGlydHlWYWx1ZSc7XG5cdFx0XHRpZiAoIHRoaXNbIGRpcnR5RmxhZyBdICkge1xuXHRcdFx0XHRzb3VyY2UgPSBwcm9jZXNzSXRlbXMoIHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQgKTtcblx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCBhc0FyZ3MgPyAnWycgKyBzb3VyY2UgKyAnXScgOiBzb3VyY2UsIHZhbHVlcyApO1xuXHRcdFx0XHRpZiAoICFwYXJzZWQgKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gYXNBcmdzID8gWyB0aGlzLnRvU3RyaW5nKCkgXSA6IHRoaXMudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBwYXJzZWQudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1sgY2FjaGVkUmVzdWx0IF0gPSByZXN1bHQ7XG5cdFx0XHRcdHRoaXNbIGRpcnR5RmxhZyBdID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1sgY2FjaGVkUmVzdWx0IF07XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NJdGVtcyggaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlciApIHtcblx0XHRcdGNvdW50ZXIgPSBjb3VudGVyIHx8IDA7XG5cdFx0XHRyZXR1cm4gaXRlbXMubWFwKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0dmFyIHBsYWNlaG9sZGVySWQsIHdyYXBwZWQsIHZhbHVlO1xuXHRcdFx0XHRpZiAoIGl0ZW0udGV4dCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbS50ZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggaXRlbS5mcmFnbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0uZnJhZ21lbnRzLm1hcCggZnVuY3Rpb24oIGZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NJdGVtcyggZnJhZ21lbnQuaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlciApO1xuXHRcdFx0XHRcdH0gKS5qb2luKCAnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsYWNlaG9sZGVySWQgPSBndWlkICsgJy0nICsgY291bnRlcisrO1xuXHRcdFx0XHRpZiAoIHdyYXBwZWQgPSBpdGVtLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIGl0ZW0ua2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGl0ZW0uZ2V0VmFsdWUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZXNbIHBsYWNlaG9sZGVySWQgXSA9IHZhbHVlO1xuXHRcdFx0XHRyZXR1cm4gJyR7JyArIHBsYWNlaG9sZGVySWQgKyAnfSc7XG5cdFx0XHR9ICkuam9pbiggJycgKTtcblx0XHR9XG5cdH0oIHBhcnNlSlNPTiApO1xuXG5cdC8qIHV0aWxzL2VzY2FwZUh0bWwuanMgKi9cblx0dmFyIGVzY2FwZUh0bWwgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBsZXNzVGhhbiA9IC88L2csXG5cdFx0XHRncmVhdGVyVGhhbiA9IC8+L2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGVzY2FwZUh0bWwoIHN0ciApIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggbGVzc1RoYW4sICcmbHQ7JyApLnJlcGxhY2UoIGdyZWF0ZXJUaGFuLCAnJmd0OycgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvZGV0YWNoTm9kZS5qcyAqL1xuXHR2YXIgZGV0YWNoTm9kZSA9IGZ1bmN0aW9uIGRldGFjaE5vZGUoIG5vZGUgKSB7XG5cdFx0aWYgKCBub2RlICYmIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9kZXRhY2guanMgKi9cblx0dmFyIGRldGFjaCA9IGZ1bmN0aW9uKCBkZXRhY2hOb2RlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGRldGFjaE5vZGUoIHRoaXMubm9kZSApO1xuXHRcdH07XG5cdH0oIGRldGFjaE5vZGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RleHQuanMgKi9cblx0dmFyIFRleHQgPSBmdW5jdGlvbiggdHlwZXMsIGVzY2FwZUh0bWwsIGRldGFjaCApIHtcblxuXHRcdHZhciBUZXh0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5URVhUO1xuXHRcdFx0dGhpcy50ZXh0ID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHR9O1xuXHRcdFRleHQucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggdGhpcy50ZXh0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIGVzY2FwZSApIHtcblx0XHRcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwoIHRoaXMudGV4dCApIDogdGhpcy50ZXh0O1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmRldGFjaCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVGV4dDtcblx0fSggdHlwZXMsIGVzY2FwZUh0bWwsIGRldGFjaCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3VuYmluZC5qcyAqL1xuXHR2YXIgdW5iaW5kID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5iaW5kKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5rZXlwYXRoICkge1xuXHRcdFx0XHQvLyB0aGlzIHdhcyBvbiB0aGUgJ3VucmVzb2x2ZWQnIGxpc3QsIHdlIG5lZWQgdG8gcmVtb3ZlIGl0XG5cdFx0XHRcdHJ1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCggdGhpcyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdGhpcyB3YXMgcmVnaXN0ZXJlZCBhcyBhIGRlcGVuZGFudFxuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLnJlc29sdmVyICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLnRlYXJkb3duKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL2dldFZhbHVlLmpzICovXG5cdHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIE11c3RhY2hlJGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHNoYXJlZC9VbnJlc29sdmVkLmpzICovXG5cdHZhciBVbnJlc29sdmVkID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgVW5yZXNvbHZlZCA9IGZ1bmN0aW9uKCByYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50LCBjYWxsYmFjayApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLnJlZiA9IHJlZjtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVzb2x2ZSA9IGNhbGxiYWNrO1xuXHRcdFx0cnVubG9vcC5hZGRVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0fTtcblx0XHRVbnJlc29sdmVkLnByb3RvdHlwZSA9IHtcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVW5yZXNvbHZlZDtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL3N0YXJ0c1dpdGhLZXlwYXRoLmpzICovXG5cdHZhciBzdGFydHNXaXRoS2V5cGF0aCA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXQsIGtleXBhdGggKSB7XG5cdFx0cmV0dXJuIHRhcmdldC5zdWJzdHIoIDAsIGtleXBhdGgubGVuZ3RoICsgMSApID09PSBrZXlwYXRoICsgJy4nO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL2dldE5ld0tleXBhdGguanMgKi9cblx0dmFyIGdldE5ld0tleXBhdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aEtleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TmV3S2V5cGF0aCggdGFyZ2V0S2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdC8vIGV4YWN0IG1hdGNoXG5cdFx0XHRpZiAoIHRhcmdldEtleXBhdGggPT09IG9sZEtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybiBuZXdLZXlwYXRoO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcGFydGlhbCBtYXRjaCBiYXNlZCBvbiBsZWFkaW5nIGtleXBhdGggc2VnbWVudHNcblx0XHRcdGlmICggc3RhcnRzV2l0aEtleXBhdGgoIHRhcmdldEtleXBhdGgsIG9sZEtleXBhdGggKSApIHtcblx0XHRcdFx0cmV0dXJuIHRhcmdldEtleXBhdGgucmVwbGFjZSggb2xkS2V5cGF0aCArICcuJywgbmV3S2V5cGF0aCArICcuJyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGhLZXlwYXRoICk7XG5cblx0LyogdXRpbHMvbG9nLmpzICovXG5cdHZhciBsb2cgPSBmdW5jdGlvbiggY29uc29sZXdhcm4sIGVycm9ycyApIHtcblxuXHRcdHZhciBsb2cgPSB7XG5cdFx0XHR3YXJuOiBmdW5jdGlvbiggb3B0aW9ucywgcGFzc3RocnUgKSB7XG5cdFx0XHRcdGlmICggIW9wdGlvbnMuZGVidWcgJiYgIXBhc3N0aHJ1ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmxvZ2dlciggZ2V0TWVzc2FnZSggb3B0aW9ucyApLCBvcHRpb25zLmFsbG93RHVwbGljYXRlcyApO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5lcnJvck9ubHkoIG9wdGlvbnMgKTtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kZWJ1ZyApIHtcblx0XHRcdFx0XHR0aGlzLndhcm4oIG9wdGlvbnMsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGVycm9yT25seTogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5kZWJ1ZyApIHtcblx0XHRcdFx0XHR0aGlzLmNyaXRpY2FsKCBvcHRpb25zICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjcml0aWNhbDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciBlcnIgPSBvcHRpb25zLmVyciB8fCBuZXcgRXJyb3IoIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSApO1xuXHRcdFx0XHR0aGlzLnRocm93ZXIoIGVyciApO1xuXHRcdFx0fSxcblx0XHRcdGxvZ2dlcjogY29uc29sZXdhcm4sXG5cdFx0XHR0aHJvd2VyOiBmdW5jdGlvbiggZXJyICkge1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IGVycm9yc1sgb3B0aW9ucy5tZXNzYWdlIF0gfHwgb3B0aW9ucy5tZXNzYWdlIHx8ICcnO1xuXHRcdFx0cmV0dXJuIGludGVycG9sYXRlKCBtZXNzYWdlLCBvcHRpb25zLmFyZ3MgKTtcblx0XHR9XG5cdFx0Ly8gc2ltcGxlIGludGVycG9sYXRpb24uIHByb2JhYmx5IHF1aWNrZXIgKGFuZCBiZXR0ZXIpIG91dCB0aGVyZSxcblx0XHQvLyBidXQgbG9nIGlzIG5vdCBpbiBnb2xkZW4gcGF0aCBvZiBleGVjdXRpb24sIG9ubHkgZXhjZXB0aW9uc1xuXHRcdGZ1bmN0aW9uIGludGVycG9sYXRlKCBtZXNzYWdlLCBhcmdzICkge1xuXHRcdFx0cmV0dXJuIG1lc3NhZ2UucmVwbGFjZSggL3soW157fV0qKX0vZywgZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdHJldHVybiBhcmdzWyBiIF07XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2c7XG5cdH0oIHdhcm4sIGVycm9ycyApO1xuXG5cdC8qIHZpZXdtb2RlbC9Db21wdXRhdGlvbi9kaWZmLmpzICovXG5cdHZhciBkaWZmID0gZnVuY3Rpb24gZGlmZiggY29tcHV0YXRpb24sIGRlcGVuZGVuY2llcywgbmV3RGVwZW5kZW5jaWVzICkge1xuXHRcdHZhciBpLCBrZXlwYXRoO1xuXHRcdC8vIHJlbW92ZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcblx0XHRpID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGtleXBhdGggPSBkZXBlbmRlbmNpZXNbIGkgXTtcblx0XHRcdGlmICggbmV3RGVwZW5kZW5jaWVzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdGNvbXB1dGF0aW9uLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCBrZXlwYXRoLCBjb21wdXRhdGlvbiwgJ2NvbXB1dGVkJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBjcmVhdGUgcmVmZXJlbmNlcyBmb3IgYW55IG5ldyBkZXBlbmRlbmNpZXNcblx0XHRpID0gbmV3RGVwZW5kZW5jaWVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGtleXBhdGggPSBuZXdEZXBlbmRlbmNpZXNbIGkgXTtcblx0XHRcdGlmICggZGVwZW5kZW5jaWVzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdGNvbXB1dGF0aW9uLnZpZXdtb2RlbC5yZWdpc3Rlcigga2V5cGF0aCwgY29tcHV0YXRpb24sICdjb21wdXRlZCcgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29tcHV0YXRpb24uZGVwZW5kZW5jaWVzID0gbmV3RGVwZW5kZW5jaWVzLnNsaWNlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvRXZhbHVhdG9yL0V2YWx1YXRvci5qcyAqL1xuXHR2YXIgRXZhbHVhdG9yID0gZnVuY3Rpb24oIGxvZywgaXNFcXVhbCwgZGVmaW5lUHJvcGVydHksIGRpZmYgKSB7XG5cblx0XHQvLyBUT0RPIHRoaXMgaXMgYSByZWQgZmxhZy4uLiBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZT9cblx0XHR2YXIgRXZhbHVhdG9yLCBjYWNoZSA9IHt9O1xuXHRcdEV2YWx1YXRvciA9IGZ1bmN0aW9uKCByb290LCBrZXlwYXRoLCB1bmlxdWVTdHJpbmcsIGZ1bmN0aW9uU3RyLCBhcmdzLCBwcmlvcml0eSApIHtcblx0XHRcdHZhciBldmFsdWF0b3IgPSB0aGlzLFxuXHRcdFx0XHR2aWV3bW9kZWwgPSByb290LnZpZXdtb2RlbDtcblx0XHRcdGV2YWx1YXRvci5yb290ID0gcm9vdDtcblx0XHRcdGV2YWx1YXRvci52aWV3bW9kZWwgPSB2aWV3bW9kZWw7XG5cdFx0XHRldmFsdWF0b3IudW5pcXVlU3RyaW5nID0gdW5pcXVlU3RyaW5nO1xuXHRcdFx0ZXZhbHVhdG9yLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0ZXZhbHVhdG9yLnByaW9yaXR5ID0gcHJpb3JpdHk7XG5cdFx0XHRldmFsdWF0b3IuZm4gPSBnZXRGdW5jdGlvbkZyb21TdHJpbmcoIGZ1bmN0aW9uU3RyLCBhcmdzLmxlbmd0aCApO1xuXHRcdFx0ZXZhbHVhdG9yLmV4cGxpY2l0RGVwZW5kZW5jaWVzID0gW107XG5cdFx0XHRldmFsdWF0b3IuZGVwZW5kZW5jaWVzID0gW107XG5cdFx0XHQvLyBjcmVhdGVkIGJ5IGB0aGlzLmdldCgpYCB3aXRoaW4gZnVuY3Rpb25zXG5cdFx0XHRldmFsdWF0b3IuYXJndW1lbnRHZXR0ZXJzID0gYXJncy5tYXAoIGZ1bmN0aW9uKCBhcmcgKSB7XG5cdFx0XHRcdHZhciBrZXlwYXRoLCBpbmRleDtcblx0XHRcdFx0aWYgKCAhYXJnICkge1xuXHRcdFx0XHRcdHJldHVybiB2b2lkIDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhcmcuaW5kZXhSZWYgKSB7XG5cdFx0XHRcdFx0aW5kZXggPSBhcmcudmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXBhdGggPSBhcmcua2V5cGF0aDtcblx0XHRcdFx0ZXZhbHVhdG9yLmV4cGxpY2l0RGVwZW5kZW5jaWVzLnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0dmlld21vZGVsLnJlZ2lzdGVyKCBrZXlwYXRoLCBldmFsdWF0b3IsICdjb21wdXRlZCcgKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gd3JhcCggdmFsdWUsIHJvb3QgKSA6IHZhbHVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0RXZhbHVhdG9yLnByb3RvdHlwZSA9IHtcblx0XHRcdHdha2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmF3YWtlID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRzbGVlcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuYXdha2UgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhcmdzLCB2YWx1ZSwgbmV3SW1wbGljaXREZXBlbmRlbmNpZXM7XG5cdFx0XHRcdGFyZ3MgPSB0aGlzLmFyZ3VtZW50R2V0dGVycy5tYXAoIGNhbGwgKTtcblx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHMgY2F1c2VkIGJ5IGUuZy4gaW4tcGxhY2UgYXJyYXkgbXV0YXRpb25zXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5jYXB0dXJlKCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLmZuLmFwcGx5KCBudWxsLCBhcmdzICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnJvb3QuZGVidWcgKSB7XG5cdFx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0XHRkZWJ1ZzogdGhpcy5yb290LmRlYnVnLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnZXZhbHVhdGlvbkVycm9yJyxcblx0XHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZVN0cmluZzogdGhpcy51bmlxdWVTdHJpbmcsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyOiBlcnIubWVzc2FnZSB8fCBlcnJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXdJbXBsaWNpdERlcGVuZGVuY2llcyA9IHRoaXMudmlld21vZGVsLnJlbGVhc2UoKTtcblx0XHRcdFx0ZGlmZiggdGhpcywgdGhpcy5kZXBlbmRlbmNpZXMsIG5ld0ltcGxpY2l0RGVwZW5kZW5jaWVzICk7XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5tYXJrKCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBUT0RPIHNob3VsZCBldmFsdWF0b3JzIGV2ZXIgZ2V0IHRvcm4gZG93bj8gQXQgcHJlc2VudCwgdGhleSBkb24ndC4uLlxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dGhpcy5leHBsaWNpdERlcGVuZGVuY2llcy5jb25jYXQoIHRoaXMuZGVwZW5kZW5jaWVzICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgdGhpcyQwLCAnY29tcHV0ZWQnICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5ldmFsdWF0b3JzWyB0aGlzLmtleXBhdGggXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gRXZhbHVhdG9yO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKCBzdHIsIGkgKSB7XG5cdFx0XHR2YXIgZm4sIGFyZ3M7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSggL1xcJFxceyhbMC05XSspXFx9L2csICdfJDEnICk7XG5cdFx0XHRpZiAoIGNhY2hlWyBzdHIgXSApIHtcblx0XHRcdFx0cmV0dXJuIGNhY2hlWyBzdHIgXTtcblx0XHRcdH1cblx0XHRcdGFyZ3MgPSBbXTtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRhcmdzWyBpIF0gPSAnXycgKyBpO1xuXHRcdFx0fVxuXHRcdFx0Zm4gPSBuZXcgRnVuY3Rpb24oIGFyZ3Muam9pbiggJywnICksICdyZXR1cm4oJyArIHN0ciArICcpJyApO1xuXHRcdFx0Y2FjaGVbIHN0ciBdID0gZm47XG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd3JhcCggZm4sIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgd3JhcHBlZCwgcHJvcDtcblx0XHRcdGlmICggZm4uX25vV3JhcCApIHtcblx0XHRcdFx0cmV0dXJuIGZuO1xuXHRcdFx0fVxuXHRcdFx0cHJvcCA9ICdfX3JhY3RpdmVfJyArIHJhY3RpdmUuX2d1aWQ7XG5cdFx0XHR3cmFwcGVkID0gZm5bIHByb3AgXTtcblx0XHRcdGlmICggd3JhcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIHdyYXBwZWQ7XG5cdFx0XHR9IGVsc2UgaWYgKCAvdGhpcy8udGVzdCggZm4udG9TdHJpbmcoKSApICkge1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggZm4sIHByb3AsIHtcblx0XHRcdFx0XHR2YWx1ZTogZm4uYmluZCggcmFjdGl2ZSApXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIGZuWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSggZm4sICdfX3JhY3RpdmVfbm93cmFwJywge1xuXHRcdFx0XHR2YWx1ZTogZm5cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBmbi5fX3JhY3RpdmVfbm93cmFwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhbGwoIGFyZyApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKCkgOiBhcmc7XG5cdFx0fVxuXHR9KCBsb2csIGlzRXF1YWwsIGRlZmluZVByb3BlcnR5LCBkaWZmICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL0V4cHJlc3Npb25SZXNvbHZlci5qcyAqL1xuXHR2YXIgRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSwgcmVzb2x2ZVJlZiwgVW5yZXNvbHZlZCwgRXZhbHVhdG9yLCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0dmFyIEV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCBvd25lciwgcGFyZW50RnJhZ21lbnQsIGV4cHJlc3Npb24sIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIGV4cHJlc3Npb25SZXNvbHZlciA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIGluZGV4UmVmcywgYXJncztcblx0XHRcdHJhY3RpdmUgPSBvd25lci5yb290O1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMub3duZXIgPSBvd25lcjtcblx0XHRcdHRoaXMuc3RyID0gZXhwcmVzc2lvbi5zO1xuXHRcdFx0dGhpcy5hcmdzID0gYXJncyA9IFtdO1xuXHRcdFx0dGhpcy51bnJlc29sdmVkID0gW107XG5cdFx0XHR0aGlzLnBlbmRpbmcgPSAwO1xuXHRcdFx0aW5kZXhSZWZzID0gcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzO1xuXHRcdFx0Ly8gc29tZSBleHByZXNzaW9ucyBkb24ndCBoYXZlIHJlZmVyZW5jZXMuIGVkZ2UgY2FzZSwgYnV0LCB5ZWFoLlxuXHRcdFx0aWYgKCAhZXhwcmVzc2lvbi5yIHx8ICFleHByZXNzaW9uLnIubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVkID0gdGhpcy5yZWFkeSA9IHRydWU7XG5cdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIENyZWF0ZSByZXNvbHZlcnMgZm9yIGVhY2ggcmVmZXJlbmNlXG5cdFx0XHRleHByZXNzaW9uLnIuZm9yRWFjaCggZnVuY3Rpb24oIHJlZmVyZW5jZSwgaSApIHtcblx0XHRcdFx0dmFyIGluZGV4LCBrZXlwYXRoLCB1bnJlc29sdmVkO1xuXHRcdFx0XHQvLyBJcyB0aGlzIGFuIGluZGV4IHJlZmVyZW5jZT9cblx0XHRcdFx0aWYgKCBpbmRleFJlZnMgJiYgKCBpbmRleCA9IGluZGV4UmVmc1sgcmVmZXJlbmNlIF0gKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGFyZ3NbIGkgXSA9IHtcblx0XHRcdFx0XHRcdGluZGV4UmVmOiByZWZlcmVuY2UsXG5cdFx0XHRcdFx0XHR2YWx1ZTogaW5kZXhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDYW4gd2UgcmVzb2x2ZSBpdCBpbW1lZGlhdGVseT9cblx0XHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmZXJlbmNlLCBwYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRcdGFyZ3NbIGkgXSA9IHtcblx0XHRcdFx0XHRcdGtleXBhdGg6IGtleXBhdGhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDb3VsZG4ndCByZXNvbHZlIHlldFxuXHRcdFx0XHRhcmdzWyBpIF0gPSBudWxsO1xuXHRcdFx0XHRleHByZXNzaW9uUmVzb2x2ZXIucGVuZGluZyArPSAxO1xuXHRcdFx0XHR1bnJlc29sdmVkID0gbmV3IFVucmVzb2x2ZWQoIHJhY3RpdmUsIHJlZmVyZW5jZSwgcGFyZW50RnJhZ21lbnQsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdGV4cHJlc3Npb25SZXNvbHZlci5yZXNvbHZlKCBpLCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBleHByZXNzaW9uUmVzb2x2ZXIudW5yZXNvbHZlZCwgdW5yZXNvbHZlZCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGV4cHJlc3Npb25SZXNvbHZlci51bnJlc29sdmVkLnB1c2goIHVucmVzb2x2ZWQgKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuXHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHR9O1xuXHRcdEV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVuaXF1ZVN0cmluZyA9IGdldFVuaXF1ZVN0cmluZyggdGhpcy5zdHIsIHRoaXMuYXJncyApO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBnZXRLZXlwYXRoKCB0aGlzLnVuaXF1ZVN0cmluZyApO1xuXHRcdFx0XHR0aGlzLmNyZWF0ZUV2YWx1YXRvcigpO1xuXHRcdFx0XHR0aGlzLmNhbGxiYWNrKCB0aGlzLmtleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB1bnJlc29sdmVkO1xuXHRcdFx0XHR3aGlsZSAoIHVucmVzb2x2ZWQgPSB0aGlzLnVucmVzb2x2ZWQucG9wKCkgKSB7XG5cdFx0XHRcdFx0dW5yZXNvbHZlZC50ZWFyZG93bigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVzb2x2ZTogZnVuY3Rpb24oIGluZGV4LCBrZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmFyZ3NbIGluZGV4IF0gPSB7XG5cdFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aFxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHQvLyB3aGVuIGFsbCByZWZlcmVuY2VzIGhhdmUgYmVlbiByZXNvbHZlZCwgd2UgY2FuIGZsYWcgdGhlIGVudGlyZSBleHByZXNzaW9uXG5cdFx0XHRcdC8vIGFzIGhhdmluZyBiZWVuIHJlc29sdmVkXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWQgPSAhLS10aGlzLnBlbmRpbmc7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlRXZhbHVhdG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGV2YWx1YXRvciA9IHRoaXMucm9vdC52aWV3bW9kZWwuZXZhbHVhdG9yc1sgdGhpcy5rZXlwYXRoIF07XG5cdFx0XHRcdC8vIG9ubHkgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQhXG5cdFx0XHRcdGlmICggIWV2YWx1YXRvciApIHtcblx0XHRcdFx0XHRldmFsdWF0b3IgPSBuZXcgRXZhbHVhdG9yKCB0aGlzLnJvb3QsIHRoaXMua2V5cGF0aCwgdGhpcy51bmlxdWVTdHJpbmcsIHRoaXMuc3RyLCB0aGlzLmFyZ3MsIHRoaXMub3duZXIucHJpb3JpdHkgKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLmV2YWx1YXRvcnNbIHRoaXMua2V5cGF0aCBdID0gZXZhbHVhdG9yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2YWx1YXRvci51cGRhdGUoKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBjaGFuZ2VkO1xuXHRcdFx0XHR0aGlzLmFyZ3MuZm9yRWFjaCggZnVuY3Rpb24oIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgY2hhbmdlZEtleXBhdGg7XG5cdFx0XHRcdFx0aWYgKCAhYXJnIClcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRpZiAoIGFyZy5rZXlwYXRoICYmICggY2hhbmdlZEtleXBhdGggPSBnZXROZXdLZXlwYXRoKCBhcmcua2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkgKSB7XG5cdFx0XHRcdFx0XHRhcmcua2V5cGF0aCA9IGNoYW5nZWRLZXlwYXRoO1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnLmluZGV4UmVmICYmIGFyZy5pbmRleFJlZiA9PT0gaW5kZXhSZWYgKSB7XG5cdFx0XHRcdFx0XHRhcmcudmFsdWUgPSBuZXdJbmRleDtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIGNoYW5nZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIEV4cHJlc3Npb25SZXNvbHZlcjtcblxuXHRcdGZ1bmN0aW9uIGdldFVuaXF1ZVN0cmluZyggc3RyLCBhcmdzICkge1xuXHRcdFx0Ly8gZ2V0IHN0cmluZyB0aGF0IGlzIHVuaXF1ZSB0byB0aGlzIGV4cHJlc3Npb25cblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggL1xcJFxceyhbMC05XSspXFx9L2csIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRcdHZhciBhcmcgPSBhcmdzWyAkMSBdO1xuXHRcdFx0XHRpZiAoICFhcmcgKVxuXHRcdFx0XHRcdHJldHVybiAndW5kZWZpbmVkJztcblx0XHRcdFx0aWYgKCBhcmcuaW5kZXhSZWYgKVxuXHRcdFx0XHRcdHJldHVybiBhcmcudmFsdWU7XG5cdFx0XHRcdHJldHVybiBhcmcua2V5cGF0aDtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRLZXlwYXRoKCB1bmlxdWVTdHJpbmcgKSB7XG5cdFx0XHQvLyBTYW5pdGl6ZSBieSByZW1vdmluZyBhbnkgcGVyaW9kcyBvciBzcXVhcmUgYnJhY2tldHMuIE90aGVyd2lzZVxuXHRcdFx0Ly8gd2UgY2FuJ3Qgc3BsaXQgdGhlIGtleXBhdGggaW50byBrZXlzIVxuXHRcdFx0cmV0dXJuICckeycgKyB1bmlxdWVTdHJpbmcucmVwbGFjZSggL1tcXC5cXFtcXF1dL2csICctJyApICsgJ30nO1xuXHRcdH1cblx0fSggcmVtb3ZlRnJvbUFycmF5LCByZXNvbHZlUmVmLCBVbnJlc29sdmVkLCBFdmFsdWF0b3IsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyL01lbWJlclJlc29sdmVyLmpzICovXG5cdHZhciBNZW1iZXJSZXNvbHZlciA9IGZ1bmN0aW9uKCB0eXBlcywgcmVzb2x2ZVJlZiwgVW5yZXNvbHZlZCwgZ2V0TmV3S2V5cGF0aCwgRXhwcmVzc2lvblJlc29sdmVyICkge1xuXG5cdFx0dmFyIE1lbWJlclJlc29sdmVyID0gZnVuY3Rpb24oIHRlbXBsYXRlLCByZXNvbHZlciwgcGFyZW50RnJhZ21lbnQgKSB7XG5cdFx0XHR2YXIgbWVtYmVyID0gdGhpcyxcblx0XHRcdFx0cmVmLCBpbmRleFJlZnMsIGluZGV4LCByYWN0aXZlLCBrZXlwYXRoO1xuXHRcdFx0bWVtYmVyLnJlc29sdmVyID0gcmVzb2x2ZXI7XG5cdFx0XHRtZW1iZXIucm9vdCA9IHJlc29sdmVyLnJvb3Q7XG5cdFx0XHRtZW1iZXIudmlld21vZGVsID0gcmVzb2x2ZXIucm9vdC52aWV3bW9kZWw7XG5cdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdG1lbWJlci52YWx1ZSA9IHRlbXBsYXRlO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUudCA9PT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRyZWYgPSBtZW1iZXIucmVmID0gdGVtcGxhdGUubjtcblx0XHRcdFx0Ly8gSWYgaXQncyBhbiBpbmRleCByZWZlcmVuY2UsIG91ciBqb2IgaXMgc2ltcGxlXG5cdFx0XHRcdGlmICggKCBpbmRleFJlZnMgPSBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnMgKSAmJiAoIGluZGV4ID0gaW5kZXhSZWZzWyByZWYgXSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0bWVtYmVyLmluZGV4UmVmID0gcmVmO1xuXHRcdFx0XHRcdG1lbWJlci52YWx1ZSA9IGluZGV4O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJhY3RpdmUgPSByZXNvbHZlci5yb290O1xuXHRcdFx0XHRcdC8vIENhbiB3ZSByZXNvbHZlIHRoZSByZWZlcmVuY2UgaW1tZWRpYXRlbHk/XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBwYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRcdFx0bWVtYmVyLnJlc29sdmUoIGtleXBhdGggKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gQ291bGRuJ3QgcmVzb2x2ZSB5ZXRcblx0XHRcdFx0XHRcdG1lbWJlci51bnJlc29sdmVkID0gbmV3IFVucmVzb2x2ZWQoIHJhY3RpdmUsIHJlZiwgcGFyZW50RnJhZ21lbnQsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0XHRtZW1iZXIudW5yZXNvbHZlZCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdG1lbWJlci5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXcgRXhwcmVzc2lvblJlc29sdmVyKCByZXNvbHZlciwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRtZW1iZXIucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRNZW1iZXJSZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRiaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGtleXBhdGg7XG5cdFx0XHRcdGlmICggaW5kZXhSZWYgJiYgdGhpcy5pbmRleFJlZiA9PT0gaW5kZXhSZWYgKSB7XG5cdFx0XHRcdFx0aWYgKCBuZXdJbmRleCAhPT0gdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSBuZXdJbmRleDtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5rZXlwYXRoICYmICgga2V5cGF0aCA9IGdldE5ld0tleXBhdGgoIHRoaXMua2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkgKSB7XG5cdFx0XHRcdFx0dGhpcy51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudW5iaW5kKCk7XG5cdFx0XHRcdGlmICggdGhpcy51bnJlc29sdmVkICkge1xuXHRcdFx0XHRcdHRoaXMudW5yZXNvbHZlZC50ZWFyZG93bigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnVucmVzb2x2ZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy51bnJlc29sdmVkLnRlYXJkb3duKCk7XG5cdFx0XHRcdFx0dGhpcy51bnJlc29sdmVkID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLmtleXBhdGggPSB0aGlzLnJlZjtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KCB0aGlzLnJlZiApO1xuXHRcdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gTWVtYmVyUmVzb2x2ZXI7XG5cdH0oIHR5cGVzLCByZXNvbHZlUmVmLCBVbnJlc29sdmVkLCBnZXROZXdLZXlwYXRoLCBFeHByZXNzaW9uUmVzb2x2ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyL1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci5qcyAqL1xuXHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIHJlc29sdmVSZWYsIFVucmVzb2x2ZWQsIE1lbWJlclJlc29sdmVyICkge1xuXG5cdFx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCBtdXN0YWNoZSwgdGVtcGxhdGUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCByZWYsIGtleXBhdGgsIHBhcmVudEZyYWdtZW50O1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSBtdXN0YWNoZS5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJlc29sdmVyLnJvb3QgPSByYWN0aXZlID0gbXVzdGFjaGUucm9vdDtcblx0XHRcdHJlc29sdmVyLm11c3RhY2hlID0gbXVzdGFjaGU7XG5cdFx0XHRyZXNvbHZlci5wcmlvcml0eSA9IG11c3RhY2hlLnByaW9yaXR5O1xuXHRcdFx0cmVzb2x2ZXIucmVmID0gcmVmID0gdGVtcGxhdGUucjtcblx0XHRcdHJlc29sdmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXNvbHZlci51bnJlc29sdmVkID0gW107XG5cdFx0XHQvLyBGaW5kIGJhc2Uga2V5cGF0aFxuXHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBwYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRyZXNvbHZlci5iYXNlID0ga2V5cGF0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc29sdmVyLmJhc2VSZXNvbHZlciA9IG5ldyBVbnJlc29sdmVkKCByYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50LCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iYXNlID0ga2V5cGF0aDtcblx0XHRcdFx0XHRyZXNvbHZlci5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuXHRcdFx0XHRcdHJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBGaW5kIHZhbHVlcyBmb3IgbWVtYmVycywgb3IgbWFyayB0aGVtIGFzIHVucmVzb2x2ZWRcblx0XHRcdHJlc29sdmVyLm1lbWJlcnMgPSB0ZW1wbGF0ZS5tLm1hcCggZnVuY3Rpb24oIHRlbXBsYXRlICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IE1lbWJlclJlc29sdmVyKCB0ZW1wbGF0ZSwgdGhpcyQwLCBwYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmVzb2x2ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0cmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0fTtcblx0XHRSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0Z2V0S2V5cGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLm1lbWJlcnMubWFwKCBnZXRWYWx1ZSApO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXMuZXZlcnkoIGlzRGVmaW5lZCApIHx8IHRoaXMuYmFzZVJlc29sdmVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5iYXNlICsgJy4nICsgdmFsdWVzLmpvaW4oICcuJyApO1xuXHRcdFx0fSxcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMucmVhZHkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2soIHRoaXMuZ2V0S2V5cGF0aCgpICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgY2hhbmdlZDtcblx0XHRcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBtZW1iZXJzICkge1xuXHRcdFx0XHRcdGlmICggbWVtYmVycy5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggY2hhbmdlZCApIHtcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmJhc2VSZXNvbHZlciApIHtcblx0XHRcdFx0XHR0aGlzLmJhc2UgPSB0aGlzLnJlZjtcblx0XHRcdFx0XHR0aGlzLmJhc2VSZXNvbHZlci50ZWFyZG93bigpO1xuXHRcdFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaCggZnVuY3Rpb24oIG0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG0uZm9yY2VSZXNvbHV0aW9uKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIG1lbWJlciApIHtcblx0XHRcdHJldHVybiBtZW1iZXIudmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNEZWZpbmVkKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSAhPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCBtZW1iZXIgKSB7XG5cdFx0XHRtZW1iZXIudW5iaW5kKCk7XG5cdFx0fVxuXHRcdHJldHVybiBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXI7XG5cdH0oIHJlc29sdmVSZWYsIFVucmVzb2x2ZWQsIE1lbWJlclJlc29sdmVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvaW5pdGlhbGlzZS5qcyAqL1xuXHR2YXIgaW5pdGlhbGlzZSA9IGZ1bmN0aW9uKCB0eXBlcywgcnVubG9vcCwgcmVzb2x2ZVJlZiwgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gTXVzdGFjaGUkaW5pdCggbXVzdGFjaGUsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcmVmLCBrZXlwYXRoLCBpbmRleFJlZnMsIGluZGV4LCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHRtdXN0YWNoZS5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdG11c3RhY2hlLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRtdXN0YWNoZS5wRWxlbWVudCA9IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXHRcdFx0bXVzdGFjaGUudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0bXVzdGFjaGUuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG5cdFx0XHRtdXN0YWNoZS5wcmlvcml0eSA9IHBhcmVudEZyYWdtZW50LnByaW9yaXR5O1xuXHRcdFx0bXVzdGFjaGUuaXNTdGF0aWMgPSBvcHRpb25zLnRlbXBsYXRlLnM7XG5cdFx0XHRtdXN0YWNoZS50eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS50O1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIHNpbXBsZSBtdXN0YWNoZSwgd2l0aCBhIHJlZmVyZW5jZSwgd2UganVzdCBuZWVkIHRvIHJlc29sdmVcblx0XHRcdC8vIHRoZSByZWZlcmVuY2UgdG8gYSBrZXlwYXRoXG5cdFx0XHRpZiAoIHJlZiA9IHRlbXBsYXRlLnIgKSB7XG5cdFx0XHRcdGluZGV4UmVmcyA9IHBhcmVudEZyYWdtZW50LmluZGV4UmVmcztcblx0XHRcdFx0aWYgKCBpbmRleFJlZnMgJiYgKCBpbmRleCA9IGluZGV4UmVmc1sgcmVmIF0gKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLmluZGV4UmVmID0gcmVmO1xuXHRcdFx0XHRcdG11c3RhY2hlLnNldFZhbHVlKCBpbmRleCApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggbXVzdGFjaGUucm9vdCwgcmVmLCBtdXN0YWNoZS5wYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUucmVmID0gcmVmO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVW5yZXNvbHZlZCggbXVzdGFjaGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgaXQncyBhbiBleHByZXNzaW9uLCB3ZSBoYXZlIGEgYml0IG1vcmUgd29yayB0byBkb1xuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnggKSB7XG5cdFx0XHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IEV4cHJlc3Npb25SZXNvbHZlciggbXVzdGFjaGUsIHBhcmVudEZyYWdtZW50LCBvcHRpb25zLnRlbXBsYXRlLngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnJ4ICkge1xuXHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIoIG11c3RhY2hlLCBvcHRpb25zLnRlbXBsYXRlLnJ4LCByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4gKTtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGludmVydGVkIHNlY3Rpb25zXG5cdFx0XHRpZiAoIG11c3RhY2hlLnRlbXBsYXRlLm4gPT09IHR5cGVzLlNFQ1RJT05fVU5MRVNTICYmICFtdXN0YWNoZS5oYXNPd25Qcm9wZXJ0eSggJ3ZhbHVlJyApICkge1xuXHRcdFx0XHRtdXN0YWNoZS5zZXRWYWx1ZSggdW5kZWZpbmVkICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiggbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG9sZEtleXBhdGggPSBtdXN0YWNoZS5rZXlwYXRoO1xuXHRcdFx0XHRpZiAoIG5ld0tleXBhdGggIT09IG9sZEtleXBhdGggKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZSggbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRcdGlmICggb2xkS2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuZnJhZ21lbnRzICYmIG11c3RhY2hlLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0XHRcdFx0Zi5yZWJpbmQoIG51bGwsIG51bGwsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCB0eXBlcywgcnVubG9vcCwgcmVzb2x2ZVJlZiwgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9yZXNvbHZlLmpzICovXG5cdHZhciByZXNvbHZlID0gZnVuY3Rpb24gTXVzdGFjaGUkcmVzb2x2ZSgga2V5cGF0aCApIHtcblx0XHR2YXIgd2FzUmVzb2x2ZWQsIHZhbHVlLCB0d293YXlCaW5kaW5nO1xuXHRcdC8vIElmIHdlIHJlc29sdmVkIHByZXZpb3VzbHksIHdlIG5lZWQgdG8gdW5yZWdpc3RlclxuXHRcdGlmICggdGhpcy5rZXlwYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0d2FzUmVzb2x2ZWQgPSB0cnVlO1xuXHRcdH1cblx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdC8vIElmIHRoZSBuZXcga2V5cGF0aCBleGlzdHMsIHdlIG5lZWQgdG8gcmVnaXN0ZXJcblx0XHQvLyB3aXRoIHRoZSB2aWV3bW9kZWxcblx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIHRoaXMgKTtcblx0XHR9XG5cdFx0Ly8gRWl0aGVyIHdheSB3ZSBuZWVkIHRvIHF1ZXVlIHVwIGEgcmVuZGVyIChgdmFsdWVgXG5cdFx0Ly8gd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGVyZSdzIG5vIGtleXBhdGgpXG5cdFx0dGhpcy5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHQvLyBUd28td2F5IGJpbmRpbmdzIG5lZWQgdG8gcG9pbnQgdG8gdGhlaXIgbmV3IHRhcmdldCBrZXlwYXRoXG5cdFx0aWYgKCB3YXNSZXNvbHZlZCAmJiAoIHR3b3dheUJpbmRpbmcgPSB0aGlzLnR3b3dheUJpbmRpbmcgKSApIHtcblx0XHRcdHR3b3dheUJpbmRpbmcucmVib3VuZCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9yZWJpbmQuanMgKi9cblx0dmFyIHJlYmluZCA9IGZ1bmN0aW9uKCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIE11c3RhY2hlJHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXBhdGg7XG5cdFx0XHQvLyBDaGlsZHJlbiBmaXJzdFxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50cyApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaCggZnVuY3Rpb24oIGYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGYucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRXhwcmVzc2lvbiBtdXN0YWNoZT9cblx0XHRcdGlmICggdGhpcy5yZXNvbHZlciApIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm9ybWFsIGtleXBhdGggbXVzdGFjaGUgb3IgcmVmZXJlbmNlIGV4cHJlc3Npb24/XG5cdFx0XHRpZiAoIHRoaXMua2V5cGF0aCApIHtcblx0XHRcdFx0Ly8gd2FzIGEgbmV3IGtleXBhdGggY3JlYXRlZD9cblx0XHRcdFx0aWYgKCBrZXlwYXRoID0gZ2V0TmV3S2V5cGF0aCggdGhpcy5rZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0Ly8gcmVzb2x2ZSBpdFxuXHRcdFx0XHRcdHRoaXMucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBpbmRleFJlZiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5kZXhSZWYgPT09IGluZGV4UmVmICkge1xuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCBuZXdJbmRleCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9fTXVzdGFjaGUuanMgKi9cblx0dmFyIE11c3RhY2hlID0gZnVuY3Rpb24oIGdldFZhbHVlLCBpbml0LCByZXNvbHZlLCByZWJpbmQgKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0VmFsdWU6IGdldFZhbHVlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlc29sdmU6IHJlc29sdmUsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZFxuXHRcdH07XG5cdH0oIGdldFZhbHVlLCBpbml0aWFsaXNlLCByZXNvbHZlLCByZWJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0ludGVycG9sYXRvci5qcyAqL1xuXHR2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIHR5cGVzLCBydW5sb29wLCBlc2NhcGVIdG1sLCBkZXRhY2hOb2RlLCB1bmJpbmQsIE11c3RhY2hlLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5JTlRFUlBPTEFUT1I7XG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRJbnRlcnBvbGF0b3IucHJvdG90eXBlID0ge1xuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5ub2RlLmRhdGEgPSB0aGlzLnZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdGhpcy52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiAnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdFx0ZGV0YWNoTm9kZSggdGhpcy5ub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHQvLyBURU1QXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgd3JhcHBlcjtcblx0XHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cblx0XHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZSApIHtcblx0XHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCBlc2NhcGUgKSB7XG5cdFx0XHRcdHZhciBzdHJpbmcgPSB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/ICcnICsgdGhpcy52YWx1ZSA6ICcnO1xuXHRcdFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbCggc3RyaW5nICkgOiBzdHJpbmc7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gSW50ZXJwb2xhdG9yO1xuXHR9KCB0eXBlcywgcnVubG9vcCwgZXNjYXBlSHRtbCwgZGV0YWNoTm9kZSwgdW5iaW5kLCBNdXN0YWNoZSwgZGV0YWNoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRidWJibGUgPSBmdW5jdGlvbiBTZWN0aW9uJGJ1YmJsZSgpIHtcblx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZGV0YWNoID0gZnVuY3Rpb24gU2VjdGlvbiRkZXRhY2goKSB7XG5cdFx0dmFyIGRvY0ZyYWc7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbIDAgXS5kZXRhY2goKTtcblx0XHR9XG5cdFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGl0ZW0uZGV0YWNoKCkgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maW5kKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGwgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuO1xuXHRcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHNbIGkgXS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW47XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZE5leHROb2RlID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kTmV4dE5vZGUoIGZyYWdtZW50ICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudHNbIGZyYWdtZW50LmluZGV4ICsgMSBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzWyBmcmFnbWVudC5pbmRleCArIDEgXS5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaXJzdE5vZGUgPSBmdW5jdGlvbiBTZWN0aW9uJGZpcnN0Tm9kZSgpIHtcblx0XHR2YXIgbGVuLCBpLCBub2RlO1xuXHRcdGlmICggbGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aWYgKCBub2RlID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maXJzdE5vZGUoKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL21lcmdlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kbWVyZ2UgPSBmdW5jdGlvbiggcnVubG9vcCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiRtZXJnZSggbmV3SW5kaWNlcyApIHtcblx0XHRcdHZhciBzZWN0aW9uID0gdGhpcyxcblx0XHRcdFx0cGFyZW50RnJhZ21lbnQsIGZpcnN0Q2hhbmdlLCBpLCBuZXdMZW5ndGgsIHJlYm91bmRGcmFnbWVudHMsIGZyYWdtZW50T3B0aW9ucywgZnJhZ21lbnQsIG5leHROb2RlO1xuXHRcdFx0aWYgKCB0aGlzLnVuYm91bmQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJlYm91bmRGcmFnbWVudHMgPSBbXTtcblx0XHRcdC8vIGZpcnN0LCByZWJpbmQgZXhpc3RpbmcgZnJhZ21lbnRzXG5cdFx0XHRuZXdJbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uIHJlYmluZElmTmVjZXNzYXJ5KCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG5cdFx0XHRcdHZhciBmcmFnbWVudCwgYnksIG9sZEtleXBhdGgsIG5ld0tleXBhdGg7XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IG9sZEluZGV4ICkge1xuXHRcdFx0XHRcdHJlYm91bmRGcmFnbWVudHNbIG5ld0luZGV4IF0gPSBzZWN0aW9uLmZyYWdtZW50c1sgb2xkSW5kZXggXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1sgb2xkSW5kZXggXTtcblx0XHRcdFx0aWYgKCBmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGZpcnN0Q2hhbmdlID0gb2xkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZG9lcyB0aGlzIGZyYWdtZW50IG5lZWQgdG8gYmUgdG9ybiBkb3duP1xuXHRcdFx0XHRpZiAoIG5ld0luZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpdCBuZWVkcyB0byBiZSByZWJvdW5kIHRvIGEgbmV3IGluZGV4XG5cdFx0XHRcdGJ5ID0gbmV3SW5kZXggLSBvbGRJbmRleDtcblx0XHRcdFx0b2xkS2V5cGF0aCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIG9sZEluZGV4O1xuXHRcdFx0XHRuZXdLZXlwYXRoID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgbmV3SW5kZXg7XG5cdFx0XHRcdGZyYWdtZW50LnJlYmluZCggc2VjdGlvbi50ZW1wbGF0ZS5pLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRyZWJvdW5kRnJhZ21lbnRzWyBuZXdJbmRleCBdID0gZnJhZ21lbnQ7XG5cdFx0XHR9ICk7XG5cdFx0XHRuZXdMZW5ndGggPSB0aGlzLnJvb3QuZ2V0KCB0aGlzLmtleXBhdGggKS5sZW5ndGg7XG5cdFx0XHQvLyBJZiBub3RoaW5nIGNoYW5nZWQgd2l0aCB0aGUgZXhpc3RpbmcgZnJhZ21lbnRzLCB0aGVuIHdlIHN0YXJ0IGFkZGluZ1xuXHRcdFx0Ly8gbmV3IGZyYWdtZW50cyBhdCB0aGUgZW5kLi4uXG5cdFx0XHRpZiAoIGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIC4uLnVubGVzcyB0aGVyZSBhcmUgbm8gbmV3IGZyYWdtZW50cyB0byBhZGRcblx0XHRcdFx0aWYgKCB0aGlzLmxlbmd0aCA9PT0gbmV3TGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaXJzdENoYW5nZSA9IHRoaXMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5sZW5ndGggPSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPSBuZXdMZW5ndGg7XG5cdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdC8vIFByZXBhcmUgbmV3IGZyYWdtZW50IG9wdGlvbnNcblx0XHRcdGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZixcblx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fTtcblx0XHRcdGlmICggdGhpcy50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSB0aGlzLnRlbXBsYXRlLmk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgYXMgbWFueSBuZXcgZnJhZ21lbnRzIGFzIHdlIG5lZWQgdG8sIG9yIGFkZCBiYWNrIGV4aXN0aW5nXG5cdFx0XHQvLyAoZGV0YWNoZWQpIGZyYWdtZW50c1xuXHRcdFx0Zm9yICggaSA9IGZpcnN0Q2hhbmdlOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdC8vIGlzIHRoaXMgYW4gZXhpc3RpbmcgZnJhZ21lbnQ/XG5cdFx0XHRcdGlmICggZnJhZ21lbnQgPSByZWJvdW5kRnJhZ21lbnRzWyBpIF0gKSB7XG5cdFx0XHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKCBmcmFnbWVudC5kZXRhY2goIGZhbHNlICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBGcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBjaGFuZ2VzIGFyZSBhcHBsaWVkXG5cdFx0XHRcdFx0Ly8gYnkgdGhlIHJ1bmxvb3Bcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdID0gZnJhZ21lbnQ7XG5cdFx0XHR9XG5cdFx0XHQvLyByZWluc2VydCBmcmFnbWVudFxuXHRcdFx0bmV4dE5vZGUgPSBwYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpLmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCBuZXh0Tm9kZSApO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRyZW5kZXIgPSBmdW5jdGlvbiBTZWN0aW9uJHJlbmRlcigpIHtcblx0XHR2YXIgZG9jRnJhZztcblx0XHRkb2NGcmFnID0gdGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9zZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNldFZhbHVlID0gZnVuY3Rpb24oIHR5cGVzLCBpc0FycmF5LCBpc09iamVjdCwgcnVubG9vcCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiRzZXRWYWx1ZSggdmFsdWUgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciB3cmFwcGVyLCBmcmFnbWVudE9wdGlvbnM7XG5cdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdC8vIElmIGEgY2hpbGQgb2YgdGhpcyBzZWN0aW9uIGNhdXNlcyBhIHJlLWV2YWx1YXRpb24gLSBmb3IgZXhhbXBsZSwgYW5cblx0XHRcdFx0Ly8gZXhwcmVzc2lvbiByZWZlcnMgdG8gYSBmdW5jdGlvbiB0aGF0IG11dGF0ZXMgdGhlIGFycmF5IHRoYXQgdGhpc1xuXHRcdFx0XHQvLyBzZWN0aW9uIGRlcGVuZHMgb24gLSB3ZSdsbCBlbmQgdXAgd2l0aCBhIGRvdWJsZSByZW5kZXJpbmcgYnVnIChzZWVcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy83NDgpLiBUaGlzIHByZXZlbnRzIGl0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdC8vIHdpdGggc2VjdGlvbnMsIHdlIG5lZWQgdG8gZ2V0IHRoZSBmYWtlIHZhbHVlIGlmIHdlIGhhdmUgYSB3cmFwcGVkIG9iamVjdFxuXHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgYW55IGZyYWdtZW50cyBhcmUgYXdhaXRpbmcgY3JlYXRpb24gYWZ0ZXIgYSBzcGxpY2UsXG5cdFx0XHQvLyB0aGlzIGlzIHRoZSBwbGFjZSB0byBkbyBpdFxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCApIHtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG5cdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdHBFbGVtZW50OiB0aGlzLnBFbGVtZW50LFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRcdGluZGV4UmVmOiB0aGlzLnRlbXBsYXRlLmlcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5mb3JFYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdFx0dmFyIGZyYWdtZW50O1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gdGhpcyQwLmtleXBhdGggKyAnLicgKyBpbmRleDtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpbmRleDtcblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0dGhpcyQwLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHRoaXMkMC5mcmFnbWVudHNbIGluZGV4IF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoID0gMDtcblx0XHRcdH0gZWxzZSBpZiAoIHJlZXZhbHVhdGVTZWN0aW9uKCB0aGlzLCB2YWx1ZSApICkge1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZVNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlICkge1xuXHRcdFx0dmFyIGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0dGVtcGxhdGU6IHNlY3Rpb24udGVtcGxhdGUuZixcblx0XHRcdFx0cm9vdDogc2VjdGlvbi5yb290LFxuXHRcdFx0XHRwRWxlbWVudDogc2VjdGlvbi5wYXJlbnRGcmFnbWVudC5wRWxlbWVudCxcblx0XHRcdFx0b3duZXI6IHNlY3Rpb25cblx0XHRcdH07XG5cdFx0XHQvLyBJZiB3ZSBhbHJlYWR5IGtub3cgdGhlIHNlY3Rpb24gdHlwZSwgZ3JlYXRcblx0XHRcdC8vIFRPRE8gY2FuIHRoaXMgYmUgb3B0aW1pc2VkPyBpLmUuIHBpY2sgYW4gcmVldmFsdWF0ZVNlY3Rpb24gZnVuY3Rpb24gZHVyaW5nIGluaXRcblx0XHRcdC8vIGFuZCBhdm9pZCBkb2luZyB0aGlzIGVhY2ggdGltZT9cblx0XHRcdGlmICggc2VjdGlvbi5zdWJ0eXBlICkge1xuXHRcdFx0XHRzd2l0Y2ggKCBzZWN0aW9uLnN1YnR5cGUgKSB7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX0lGOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX1VOTEVTUzpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgdHJ1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX1dJVEg6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fRUFDSDpcblx0XHRcdFx0XHRcdGlmICggaXNPYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gd29yayBvdXQgd2hhdCBzb3J0IG9mIHNlY3Rpb24gd2UncmUgZGVhbGluZyB3aXRoXG5cdFx0XHRzZWN0aW9uLm9yZGVyZWQgPSAhIWlzQXJyYXkoIHZhbHVlICk7XG5cdFx0XHQvLyBPcmRlcmVkIGxpc3Qgc2VjdGlvblxuXHRcdFx0aWYgKCBzZWN0aW9uLm9yZGVyZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdC8vIFVub3JkZXJlZCBsaXN0LCBvciBjb250ZXh0XG5cdFx0XHRpZiAoIGlzT2JqZWN0KCB2YWx1ZSApIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gSW5kZXggcmVmZXJlbmNlIGluZGljYXRlcyBzZWN0aW9uIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbGlzdFxuXHRcdFx0XHRpZiAoIHNlY3Rpb24udGVtcGxhdGUuaSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBvYmplY3QgcHJvdmlkZXMgY29udGV4dCBmb3IgY29udGVudHNcblx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDb25kaXRpb25hbCBzZWN0aW9uXG5cdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaSwgbGVuZ3RoLCBmcmFnbWVudDtcblx0XHRcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdGlmICggbGVuZ3RoID09PSBzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gTm90aGluZyB0byBkb1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGUgYXJyYXkgaXMgc2hvcnRlciB0aGFuIGl0IHdhcyBwcmV2aW91c2x5LCByZW1vdmUgaXRlbXNcblx0XHRcdGlmICggbGVuZ3RoIDwgc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggbGVuZ3RoLCBzZWN0aW9uLmxlbmd0aCAtIGxlbmd0aCApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIGFkZCBhbnkgbmV3IG9uZXNcblx0XHRcdFx0XHRmb3IgKCBpID0gc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRcdC8vIGFwcGVuZCBsaXN0IGl0ZW0gdG8gY29udGV4dCBzdGFja1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBpO1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaTtcblx0XHRcdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSBzZWN0aW9uLnRlbXBsYXRlLmk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyBpIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VjdGlvbi5sZW5ndGggPSBsZW5ndGg7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaWQsIGksIGhhc0tleSwgZnJhZ21lbnQsIGNoYW5nZWQ7XG5cdFx0XHRoYXNLZXkgPSBzZWN0aW9uLmhhc0tleSB8fCAoIHNlY3Rpb24uaGFzS2V5ID0ge30gKTtcblx0XHRcdC8vIHJlbW92ZSBhbnkgZnJhZ21lbnRzIHRoYXQgc2hvdWxkIG5vIGxvbmdlciBleGlzdFxuXHRcdFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzWyBpIF07XG5cdFx0XHRcdGlmICggISggZnJhZ21lbnQuaW5kZXggaW4gdmFsdWUgKSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRoYXNLZXlbIGZyYWdtZW50LmluZGV4IF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGFueSB0aGF0IGhhdmVuJ3QgYmVlbiBjcmVhdGVkIHlldFxuXHRcdFx0Zm9yICggaWQgaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIWhhc0tleVsgaWQgXSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIGlkO1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGlkO1xuXHRcdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4UmVmID0gc2VjdGlvbi50ZW1wbGF0ZS5pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0aGFzS2V5WyBpZCBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBmcmFnbWVudDtcblx0XHRcdC8vIC4uLnRoZW4gaWYgaXQgaXNuJ3QgcmVuZGVyZWQsIHJlbmRlciBpdCwgYWRkaW5nIHNlY3Rpb24ua2V5cGF0aCB0byB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0Ly8gKGlmIGl0IGlzIGFscmVhZHkgcmVuZGVyZWQsIHRoZW4gYW55IGNoaWxkcmVuIGRlcGVuZGVudCBvbiB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0Ly8gd2lsbCB1cGRhdGUgdGhlbXNlbHZlcyB3aXRob3V0IGFueSBwcm9tcHRpbmcpXG5cdFx0XHRpZiAoICFzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gYXBwZW5kIHRoaXMgc2VjdGlvbiB0byB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aDtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyAwIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBpbnZlcnRlZCwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGRvUmVuZGVyLCBlbXB0eUFycmF5LCBmcmFnbWVudDtcblx0XHRcdGVtcHR5QXJyYXkgPSBpc0FycmF5KCB2YWx1ZSApICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcblx0XHRcdGlmICggaW52ZXJ0ZWQgKSB7XG5cdFx0XHRcdGRvUmVuZGVyID0gZW1wdHlBcnJheSB8fCAhdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb1JlbmRlciA9IHZhbHVlICYmICFlbXB0eUFycmF5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkb1JlbmRlciApIHtcblx0XHRcdFx0aWYgKCAhc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Ly8gbm8gY2hhbmdlIHRvIGNvbnRleHQgc3RhY2tcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyAwIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHNlY3Rpb24ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIDEgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIDAsIHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aCApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblx0fSggdHlwZXMsIGlzQXJyYXksIGlzT2JqZWN0LCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvc3BsaWNlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc3BsaWNlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFNlY3Rpb24kc3BsaWNlKCBzcGxpY2VTdW1tYXJ5ICkge1xuXHRcdFx0dmFyIHNlY3Rpb24gPSB0aGlzLFxuXHRcdFx0XHRiYWxhbmNlLCBzdGFydCwgaW5zZXJ0U3RhcnQsIGluc2VydEVuZCwgc3BsaWNlQXJncztcblx0XHRcdC8vIEluIHJhcmUgY2FzZXMsIGEgc2VjdGlvbiB3aWxsIHJlY2VpdmUgYSBzcGxpY2UgaW5zdHJ1Y3Rpb24gYWZ0ZXIgaXQgaGFzXG5cdFx0XHQvLyBiZWVuIHVuYm91bmQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzk2NykuIFRoaXNcblx0XHRcdC8vIHByZXZlbnRzIGVycm9ycyBhcmlzaW5nIGZyb20gdGhvc2Ugc2l0dWF0aW9uc1xuXHRcdFx0aWYgKCB0aGlzLnVuYm91bmQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGJhbGFuY2UgPSBzcGxpY2VTdW1tYXJ5LmJhbGFuY2U7XG5cdFx0XHRpZiAoICFiYWxhbmNlICkge1xuXHRcdFx0XHQvLyBUaGUgYXJyYXkgbGVuZ3RoIGhhc24ndCBjaGFuZ2VkIC0gd2UgZG9uJ3QgbmVlZCB0byBhZGQgb3IgcmVtb3ZlIGFueXRoaW5nXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFJlZ2lzdGVyIHdpdGggdGhlIHJ1bmxvb3AsIHNvIHdlIGNhbiAodW4pcmVuZGVyIHdpdGggdGhlXG5cdFx0XHQvLyBuZXh0IGJhdGNoIG9mIERPTSBjaGFuZ2VzXG5cdFx0XHRydW5sb29wLmFkZFZpZXcoIHNlY3Rpb24gKTtcblx0XHRcdHN0YXJ0ID0gc3BsaWNlU3VtbWFyeS5yYW5nZVN0YXJ0O1xuXHRcdFx0c2VjdGlvbi5sZW5ndGggKz0gYmFsYW5jZTtcblx0XHRcdC8vIElmIG1vcmUgaXRlbXMgd2VyZSByZW1vdmVkIGZyb20gdGhlIGFycmF5IHRoYW4gYWRkZWQsIHdlIHRlYXIgZG93blxuXHRcdFx0Ly8gdGhlIGV4Y2VzcyBmcmFnbWVudHMgYW5kIHJlbW92ZSB0aGVtLi4uXG5cdFx0XHRpZiAoIGJhbGFuY2UgPCAwICkge1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIHN0YXJ0LCAtYmFsYW5jZSApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdC8vIFJlYXNzaWduIGZyYWdtZW50cyBhZnRlciB0aGUgb25lcyB3ZSd2ZSBqdXN0IHJlbW92ZWRcblx0XHRcdFx0cmViaW5kRnJhZ21lbnRzKCBzZWN0aW9uLCBzdGFydCwgc2VjdGlvbi5sZW5ndGgsIGJhbGFuY2UgKTtcblx0XHRcdFx0Ly8gTm90aGluZyBtb3JlIHRvIGRvXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIC4uLm90aGVyd2lzZSB3ZSBuZWVkIHRvIGFkZCBzb21lIHRoaW5ncyB0byB0aGUgRE9NLlxuXHRcdFx0aW5zZXJ0U3RhcnQgPSBzdGFydCArIHNwbGljZVN1bW1hcnkucmVtb3ZlZDtcblx0XHRcdGluc2VydEVuZCA9IHN0YXJ0ICsgc3BsaWNlU3VtbWFyeS5hZGRlZDtcblx0XHRcdC8vIE1ha2Ugcm9vbSBmb3IgdGhlIG5ldyBmcmFnbWVudHMgYnkgZG9pbmcgYSBzcGxpY2UgdGhhdCBzaW11bGF0ZXNcblx0XHRcdC8vIHdoYXQgaGFwcGVuZWQgdG8gdGhlIGRhdGEgYXJyYXlcblx0XHRcdHNwbGljZUFyZ3MgPSBbXG5cdFx0XHRcdGluc2VydFN0YXJ0LFxuXHRcdFx0XHQwXG5cdFx0XHRdO1xuXHRcdFx0c3BsaWNlQXJncy5sZW5ndGggKz0gYmFsYW5jZTtcblx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZS5hcHBseSggc2VjdGlvbi5mcmFnbWVudHMsIHNwbGljZUFyZ3MgKTtcblx0XHRcdC8vIFJlYmluZCBleGlzdGluZyBmcmFnbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXlcblx0XHRcdHJlYmluZEZyYWdtZW50cyggc2VjdGlvbiwgaW5zZXJ0RW5kLCBzZWN0aW9uLmxlbmd0aCwgYmFsYW5jZSApO1xuXHRcdFx0Ly8gU2NoZWR1bGUgbmV3IGZyYWdtZW50cyB0byBiZSBjcmVhdGVkXG5cdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvQ3JlYXRlID0gcmFuZ2UoIGluc2VydFN0YXJ0LCBpbnNlcnRFbmQgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJhbmdlKCBzdGFydCwgZW5kICkge1xuXHRcdFx0dmFyIGFycmF5ID0gW10sXG5cdFx0XHRcdGk7XG5cdFx0XHRmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSApIHtcblx0XHRcdFx0YXJyYXkucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlYmluZEZyYWdtZW50cyggc2VjdGlvbiwgc3RhcnQsIGVuZCwgYnkgKSB7XG5cdFx0XHR2YXIgaSwgZnJhZ21lbnQsIGluZGV4UmVmLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoO1xuXHRcdFx0aW5kZXhSZWYgPSBzZWN0aW9uLnRlbXBsYXRlLmk7XG5cdFx0XHRmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1sgaSBdO1xuXHRcdFx0XHRvbGRLZXlwYXRoID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgKCBpIC0gYnkgKTtcblx0XHRcdFx0bmV3S2V5cGF0aCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIGk7XG5cdFx0XHRcdC8vIGNoYW5nZSB0aGUgZnJhZ21lbnQgaW5kZXhcblx0XHRcdFx0ZnJhZ21lbnQuaW5kZXggPSBpO1xuXHRcdFx0XHRmcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBpLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR0b1N0cmluZyA9IGZ1bmN0aW9uIFNlY3Rpb24kdG9TdHJpbmcoIGVzY2FwZSApIHtcblx0XHR2YXIgc3RyLCBpLCBsZW47XG5cdFx0c3RyID0gJyc7XG5cdFx0aSA9IDA7XG5cdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHN0ciArPSB0aGlzLmZyYWdtZW50c1sgaSBdLnRvU3RyaW5nKCBlc2NhcGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVuYmluZCA9IGZ1bmN0aW9uKCB1bmJpbmQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiR1bmJpbmQoKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCB1bmJpbmRGcmFnbWVudCApO1xuXHRcdFx0dW5iaW5kLmNhbGwoIHRoaXMgKTtcblx0XHRcdHRoaXMubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMudW5ib3VuZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZEZyYWdtZW50KCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblx0fSggdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIHNob3VsZERlc3Ryb3kgPyB1bnJlbmRlckFuZERlc3Ryb3kgOiB1bnJlbmRlciApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bnJlbmRlckFuZERlc3Ryb3koIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5yZW5kZXIoIHRydWUgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnJlbmRlciggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bnJlbmRlciggZmFsc2UgKTtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVwZGF0ZSA9IGZ1bmN0aW9uIFNlY3Rpb24kdXBkYXRlKCkge1xuXHRcdHZhciBmcmFnbWVudCwgcmVuZGVyZWQsIG5leHRGcmFnbWVudCwgYW5jaG9yLCB0YXJnZXQ7XG5cdFx0d2hpbGUgKCBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlci5wb3AoKSApIHtcblx0XHRcdGZyYWdtZW50LnVucmVuZGVyKCB0cnVlICk7XG5cdFx0fVxuXHRcdC8vIElmIHdlIGhhdmUgbm8gbmV3IG5vZGVzIHRvIGluc2VydCAoaS5lLiB0aGUgc2VjdGlvbiBsZW5ndGggc3RheWVkIHRoZVxuXHRcdC8vIHNhbWUsIG9yIHNocmFuayksIHdlIGRvbid0IG5lZWQgdG8gZ28gYW55IGZ1cnRoZXJcblx0XHRpZiAoICF0aGlzLmZyYWdtZW50c1RvUmVuZGVyLmxlbmd0aCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cdFx0fVxuXHRcdC8vIFJlbmRlciBuZXcgZnJhZ21lbnRzIHRvIG91ciBkb2NGcmFnXG5cdFx0d2hpbGUgKCBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuc2hpZnQoKSApIHtcblx0XHRcdHJlbmRlcmVkID0gZnJhZ21lbnQucmVuZGVyKCk7XG5cdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoIHJlbmRlcmVkICk7XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGFuIG9yZGVyZWQgbGlzdCwgYW5kIGl0J3MgYWxyZWFkeSByZW5kZXJlZCwgd2UgbWF5XG5cdFx0XHQvLyBuZWVkIHRvIGluc2VydCBjb250ZW50IGludG8gdGhlIGFwcHJvcHJpYXRlIHBsYWNlXG5cdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5vcmRlcmVkICkge1xuXHRcdFx0XHQvLyBJZiB0aGUgbmV4dCBmcmFnbWVudCBpcyBhbHJlYWR5IHJlbmRlcmVkLCB1c2UgaXQgYXMgYW4gYW5jaG9yLi4uXG5cdFx0XHRcdG5leHRGcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzWyBmcmFnbWVudC5pbmRleCArIDEgXTtcblx0XHRcdFx0aWYgKCBuZXh0RnJhZ21lbnQgJiYgbmV4dEZyYWdtZW50LnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgbmV4dEZyYWdtZW50LmZpcnN0Tm9kZSgpIHx8IG51bGwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgYW5jaG9yICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9fU2VjdGlvbi5qcyAqL1xuXHR2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uKCB0eXBlcywgTXVzdGFjaGUsIGJ1YmJsZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmluZE5leHROb2RlLCBmaXJzdE5vZGUsIG1lcmdlLCByZW5kZXIsIHNldFZhbHVlLCBzcGxpY2UsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuU0VDVElPTjtcblx0XHRcdHRoaXMuc3VidHlwZSA9IG9wdGlvbnMudGVtcGxhdGUubjtcblx0XHRcdHRoaXMuaW52ZXJ0ZWQgPSB0aGlzLnN1YnR5cGUgPT09IHR5cGVzLlNFQ1RJT05fVU5MRVNTO1xuXHRcdFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmZyYWdtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZSA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb1VucmVuZGVyID0gW107XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdFx0XHQvLyBudW1iZXIgb2YgdGltZXMgdGhpcyBzZWN0aW9uIGlzIHJlbmRlcmVkXG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRTZWN0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXHRcdFx0bWVyZ2U6IG1lcmdlLFxuXHRcdFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cdFx0XHRzZXRWYWx1ZTogc2V0VmFsdWUsXG5cdFx0XHRzcGxpY2U6IHNwbGljZSxcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBTZWN0aW9uO1xuXHR9KCB0eXBlcywgTXVzdGFjaGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJG1lcmdlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc2V0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzcGxpY2UsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVucmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdXBkYXRlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZGV0YWNoID0gZnVuY3Rpb24gVHJpcGxlJGRldGFjaCgpIHtcblx0XHR2YXIgbGVuLCBpO1xuXHRcdGlmICggdGhpcy5kb2NGcmFnICkge1xuXHRcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoIHRoaXMubm9kZXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmQgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeVJlc3VsdDtcblx0XHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF0Y2hlcyggbm9kZSwgc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kQWxsID0gZnVuY3Rpb24oIG1hdGNoZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeVJlc3VsdCApIHtcblx0XHRcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5QWxsUmVzdWx0LCBudW1Ob2Rlcywgajtcblx0XHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF0Y2hlcyggbm9kZSwgc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKCBub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBxdWVyeUFsbFJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRudW1Ob2RlcyA9IHF1ZXJ5QWxsUmVzdWx0Lmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IG51bU5vZGVzOyBqICs9IDEgKSB7XG5cdFx0XHRcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKCBxdWVyeUFsbFJlc3VsdFsgaiBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIFRyaXBsZSRmaXJzdE5vZGUoKSB7XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHRoaXMubm9kZXNbIDAgXSApIHtcblx0XHRcdHJldHVybiB0aGlzLm5vZGVzWyAwIF07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL2hlbHBlcnMvaW5zZXJ0SHRtbC5qcyAqL1xuXHR2YXIgaW5zZXJ0SHRtbCA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBjcmVhdGVFbGVtZW50ICkge1xuXG5cdFx0dmFyIGVsZW1lbnRDYWNoZSA9IHt9LFxuXHRcdFx0aWVCdWcsIGllQmxhY2tsaXN0O1xuXHRcdHRyeSB7XG5cdFx0XHRjcmVhdGVFbGVtZW50KCAndGFibGUnICkuaW5uZXJIVE1MID0gJ2Zvbyc7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdGllQnVnID0gdHJ1ZTtcblx0XHRcdGllQmxhY2tsaXN0ID0ge1xuXHRcdFx0XHRUQUJMRTogW1xuXHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFRIRUFEOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZT48dGhlYWQgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90aGVhZD48L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0VEJPRFk6IFtcblx0XHRcdFx0XHQnPHRhYmxlPjx0Ym9keSBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3Rib2R5PjwvdGFibGU+J1xuXHRcdFx0XHRdLFxuXHRcdFx0XHRUUjogW1xuXHRcdFx0XHRcdCc8dGFibGU+PHRyIGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0JzwvdHI+PC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFNFTEVDVDogW1xuXHRcdFx0XHRcdCc8c2VsZWN0IGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0Jzwvc2VsZWN0Pidcblx0XHRcdFx0XVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBodG1sLCBub2RlLCBkb2NGcmFnICkge1xuXHRcdFx0dmFyIGNvbnRhaW5lciwgbm9kZXMgPSBbXSxcblx0XHRcdFx0d3JhcHBlciwgc2VsZWN0ZWRPcHRpb24sIGNoaWxkLCBpO1xuXHRcdFx0aWYgKCBodG1sICkge1xuXHRcdFx0XHRpZiAoIGllQnVnICYmICggd3JhcHBlciA9IGllQmxhY2tsaXN0WyBub2RlLnRhZ05hbWUgXSApICkge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoICdESVYnICk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IHdyYXBwZXJbIDAgXSArIGh0bWwgKyB3cmFwcGVyWyAxIF07XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoICcueCcgKTtcblx0XHRcdFx0XHRpZiAoIGNvbnRhaW5lci50YWdOYW1lID09PSAnU0VMRUNUJyApIHtcblx0XHRcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbIGNvbnRhaW5lci5zZWxlY3RlZEluZGV4IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmcgKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZWxlbWVudCggJ0RJVicgKTtcblx0XHRcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmcgY2xhc3M9XCJ4XCI+JyArIGh0bWwgKyAnPC9zdmc+Jztcblx0XHRcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvciggJy54JyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoIG5vZGUudGFnTmFtZSApO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlICggY2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZCApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGNoaWxkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVGhpcyBpcyByZWFsbHkgYW5ub3lpbmcuIEV4dHJhY3RpbmcgPG9wdGlvbj4gbm9kZXMgZnJvbSB0aGVcblx0XHRcdFx0Ly8gdGVtcG9yYXJ5IGNvbnRhaW5lciA8c2VsZWN0PiBjYXVzZXMgdGhlIHJlbWFpbmluZyBvbmVzIHRvXG5cdFx0XHRcdC8vIGJlY29tZSBzZWxlY3RlZC4gU28gbm93IHdlIGhhdmUgdG8gZGVzZWxlY3QgdGhlbS4gSUU4LCB5b3Vcblx0XHRcdFx0Ly8gYW1hemUgbWUuIFlvdSByZWFsbHkgZG9cblx0XHRcdFx0aWYgKCBpZUJ1ZyAmJiBub2RlLnRhZ05hbWUgPT09ICdTRUxFQ1QnICkge1xuXHRcdFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGVzWyBpIF0gIT09IHNlbGVjdGVkT3B0aW9uICkge1xuXHRcdFx0XHRcdFx0XHRub2Rlc1sgaSBdLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZXM7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGVsZW1lbnQoIHRhZ05hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudENhY2hlWyB0YWdOYW1lIF0gfHwgKCBlbGVtZW50Q2FjaGVbIHRhZ05hbWUgXSA9IGNyZWF0ZUVsZW1lbnQoIHRhZ05hbWUgKSApO1xuXHRcdH1cblx0fSggbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCApO1xuXG5cdC8qIHV0aWxzL3RvQXJyYXkuanMgKi9cblx0dmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCBhcnJheUxpa2UgKSB7XG5cdFx0dmFyIGFycmF5ID0gW10sXG5cdFx0XHRpID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFycmF5WyBpIF0gPSBhcnJheUxpa2VbIGkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL2hlbHBlcnMvdXBkYXRlU2VsZWN0LmpzICovXG5cdHZhciB1cGRhdGVTZWxlY3QgPSBmdW5jdGlvbiggdG9BcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTZWxlY3QoIHBhcmVudEVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWRPcHRpb25zLCBvcHRpb24sIHZhbHVlO1xuXHRcdFx0aWYgKCAhcGFyZW50RWxlbWVudCB8fCBwYXJlbnRFbGVtZW50Lm5hbWUgIT09ICdzZWxlY3QnIHx8ICFwYXJlbnRFbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGVjdGVkT3B0aW9ucyA9IHRvQXJyYXkoIHBhcmVudEVsZW1lbnQubm9kZS5vcHRpb25zICkuZmlsdGVyKCBpc1NlbGVjdGVkICk7XG5cdFx0XHQvLyBJZiBvbmUgb2YgdGhlbSBoYWQgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgd2UgbmVlZCB0byBzeW5jXG5cdFx0XHQvLyB0aGUgbW9kZWwgdG8gdGhlIHZpZXdcblx0XHRcdGlmICggcGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSApIHtcblx0XHRcdFx0dmFsdWUgPSBzZWxlY3RlZE9wdGlvbnMubWFwKCBmdW5jdGlvbiggbyApIHtcblx0XHRcdFx0XHRyZXR1cm4gby52YWx1ZTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSBlbHNlIGlmICggb3B0aW9uID0gc2VsZWN0ZWRPcHRpb25zWyAwIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gb3B0aW9uLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRwYXJlbnRFbGVtZW50LmJpbmRpbmcuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0XHRwYXJlbnRFbGVtZW50LmJ1YmJsZSgpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc1NlbGVjdGVkKCBvcHRpb24gKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9uLnNlbGVjdGVkO1xuXHRcdH1cblx0fSggdG9BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHJlbmRlciA9IGZ1bmN0aW9uKCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHJlbmRlcigpIHtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHJlbmRlciBhbiBpdGVtIHRoYXQgd2FzIGFscmVhZHkgcmVuZGVyZWQnICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCggdGhpcy52YWx1ZSwgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCksIHRoaXMuZG9jRnJhZyApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG5cdFx0XHR1cGRhdGVTZWxlY3QoIHRoaXMucEVsZW1lbnQgKTtcblx0XHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcblx0XHR9O1xuXHR9KCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvc2V0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHNldFZhbHVlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHNldFZhbHVlKCB2YWx1ZSApIHtcblx0XHRcdHZhciB3cmFwcGVyO1xuXHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cblx0XHRcdGlmICggd3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFsgdGhpcy5rZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgIT09IHRoaXMudmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdG9TdHJpbmcgPSBmdW5jdGlvbiBUcmlwbGUkdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6ICcnO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdW5yZW5kZXIgPSBmdW5jdGlvbiggZGV0YWNoTm9kZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0dGhpcy5ub2Rlcy5mb3JFYWNoKCBkZXRhY2hOb2RlICk7XG5cdFx0XHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBkZXRhY2hOb2RlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdXBkYXRlID0gZnVuY3Rpb24oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdXBkYXRlKCkge1xuXHRcdFx0dmFyIG5vZGUsIHBhcmVudE5vZGU7XG5cdFx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgZXhpc3Rpbmcgbm9kZXNcblx0XHRcdHdoaWxlICggdGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXMucG9wKCk7XG5cdFx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSW5zZXJ0IG5ldyBub2Rlc1xuXHRcdFx0cGFyZW50Tm9kZSA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuXHRcdFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwoIHRoaXMudmFsdWUsIHBhcmVudE5vZGUsIHRoaXMuZG9jRnJhZyApO1xuXHRcdFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKSApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG5cdFx0XHR1cGRhdGVTZWxlY3QoIHRoaXMucEVsZW1lbnQgKTtcblx0XHR9O1xuXHR9KCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9fVHJpcGxlLmpzICovXG5cdHZhciBUcmlwbGUgPSBmdW5jdGlvbiggdHlwZXMsIE11c3RhY2hlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpcnN0Tm9kZSwgcmVuZGVyLCBzZXRWYWx1ZSwgdG9TdHJpbmcsIHVucmVuZGVyLCB1cGRhdGUsIHVuYmluZCApIHtcblxuXHRcdHZhciBUcmlwbGUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlRSSVBMRTtcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdFRyaXBsZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHNldFZhbHVlOiBzZXRWYWx1ZSxcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBUcmlwbGU7XG5cdH0oIHR5cGVzLCBNdXN0YWNoZSwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZGV0YWNoLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaXJzdE5vZGUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkc2V0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1bnJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdXBkYXRlLCB1bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGJ1YmJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRkZXRhY2ggPSBmdW5jdGlvbiBFbGVtZW50JGRldGFjaCgpIHtcblx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdHBhcmVudE5vZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Ly8gbmVlZCB0byBjaGVjayBmb3IgcGFyZW50IG5vZGUgLSBET00gbWF5IGhhdmUgYmVlbiBhbHRlcmVkXG5cdFx0XHQvLyBieSBzb21ldGhpbmcgb3RoZXIgdGhhbiBSYWN0aXZlISBlLmcuIGpRdWVyeSBVSS4uLlxuXHRcdFx0aWYgKCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdGlmICggbWF0Y2hlcyggdGhpcy5ub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICYmIHRoaXMuZnJhZ21lbnQuZmluZCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0Ly8gQWRkIHRoaXMgbm9kZSB0byB0aGUgcXVlcnksIGlmIGFwcGxpY2FibGUsIGFuZCByZWdpc3RlciB0aGVcblx0XHQvLyBxdWVyeSBvbiB0aGlzIGVsZW1lbnRcblx0XHRpZiAoIHF1ZXJ5Ll90ZXN0KCB0aGlzLCB0cnVlICkgJiYgcXVlcnkubGl2ZSApIHtcblx0XHRcdCggdGhpcy5saXZlUXVlcmllcyB8fCAoIHRoaXMubGl2ZVF1ZXJpZXMgPSBbXSApICkucHVzaCggcXVlcnkgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZmluZE5leHROb2RlKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmlyc3ROb2RlID0gZnVuY3Rpb24gRWxlbWVudCRmaXJzdE5vZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2dldEF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZ2V0QXR0cmlidXRlKCBuYW1lICkge1xuXHRcdGlmICggIXRoaXMuYXR0cmlidXRlcyB8fCAhdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXS52YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc2hhcmVkL2VuZm9yY2VDYXNlLmpzICovXG5cdHZhciBlbmZvcmNlQ2FzZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzLCBjcmVhdGVNYXAsIG1hcDtcblx0XHRzdmdDYW1lbENhc2VFbGVtZW50cyA9ICdhbHRHbHlwaCBhbHRHbHlwaERlZiBhbHRHbHlwaEl0ZW0gYW5pbWF0ZUNvbG9yIGFuaW1hdGVNb3Rpb24gYW5pbWF0ZVRyYW5zZm9ybSBjbGlwUGF0aCBmZUJsZW5kIGZlQ29sb3JNYXRyaXggZmVDb21wb25lbnRUcmFuc2ZlciBmZUNvbXBvc2l0ZSBmZUNvbnZvbHZlTWF0cml4IGZlRGlmZnVzZUxpZ2h0aW5nIGZlRGlzcGxhY2VtZW50TWFwIGZlRGlzdGFudExpZ2h0IGZlRmxvb2QgZmVGdW5jQSBmZUZ1bmNCIGZlRnVuY0cgZmVGdW5jUiBmZUdhdXNzaWFuQmx1ciBmZUltYWdlIGZlTWVyZ2UgZmVNZXJnZU5vZGUgZmVNb3JwaG9sb2d5IGZlT2Zmc2V0IGZlUG9pbnRMaWdodCBmZVNwZWN1bGFyTGlnaHRpbmcgZmVTcG90TGlnaHQgZmVUaWxlIGZlVHVyYnVsZW5jZSBmb3JlaWduT2JqZWN0IGdseXBoUmVmIGxpbmVhckdyYWRpZW50IHJhZGlhbEdyYWRpZW50IHRleHRQYXRoIHZrZXJuJy5zcGxpdCggJyAnICk7XG5cdFx0c3ZnQ2FtZWxDYXNlQXR0cmlidXRlcyA9ICdhdHRyaWJ1dGVOYW1lIGF0dHJpYnV0ZVR5cGUgYmFzZUZyZXF1ZW5jeSBiYXNlUHJvZmlsZSBjYWxjTW9kZSBjbGlwUGF0aFVuaXRzIGNvbnRlbnRTY3JpcHRUeXBlIGNvbnRlbnRTdHlsZVR5cGUgZGlmZnVzZUNvbnN0YW50IGVkZ2VNb2RlIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQgZmlsdGVyUmVzIGZpbHRlclVuaXRzIGdseXBoUmVmIGdyYWRpZW50VHJhbnNmb3JtIGdyYWRpZW50VW5pdHMga2VybmVsTWF0cml4IGtlcm5lbFVuaXRMZW5ndGgga2V5UG9pbnRzIGtleVNwbGluZXMga2V5VGltZXMgbGVuZ3RoQWRqdXN0IGxpbWl0aW5nQ29uZUFuZ2xlIG1hcmtlckhlaWdodCBtYXJrZXJVbml0cyBtYXJrZXJXaWR0aCBtYXNrQ29udGVudFVuaXRzIG1hc2tVbml0cyBudW1PY3RhdmVzIHBhdGhMZW5ndGggcGF0dGVybkNvbnRlbnRVbml0cyBwYXR0ZXJuVHJhbnNmb3JtIHBhdHRlcm5Vbml0cyBwb2ludHNBdFggcG9pbnRzQXRZIHBvaW50c0F0WiBwcmVzZXJ2ZUFscGhhIHByZXNlcnZlQXNwZWN0UmF0aW8gcHJpbWl0aXZlVW5pdHMgcmVmWCByZWZZIHJlcGVhdENvdW50IHJlcGVhdER1ciByZXF1aXJlZEV4dGVuc2lvbnMgcmVxdWlyZWRGZWF0dXJlcyBzcGVjdWxhckNvbnN0YW50IHNwZWN1bGFyRXhwb25lbnQgc3ByZWFkTWV0aG9kIHN0YXJ0T2Zmc2V0IHN0ZERldmlhdGlvbiBzdGl0Y2hUaWxlcyBzdXJmYWNlU2NhbGUgc3lzdGVtTGFuZ3VhZ2UgdGFibGVWYWx1ZXMgdGFyZ2V0WCB0YXJnZXRZIHRleHRMZW5ndGggdmlld0JveCB2aWV3VGFyZ2V0IHhDaGFubmVsU2VsZWN0b3IgeUNoYW5uZWxTZWxlY3RvciB6b29tQW5kUGFuJy5zcGxpdCggJyAnICk7XG5cdFx0Y3JlYXRlTWFwID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdFx0dmFyIG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdG1hcFsgaXRlbXNbIGkgXS50b0xvd2VyQ2FzZSgpIF0gPSBpdGVtc1sgaSBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcDtcblx0XHR9O1xuXHRcdG1hcCA9IGNyZWF0ZU1hcCggc3ZnQ2FtZWxDYXNlRWxlbWVudHMuY29uY2F0KCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzICkgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnROYW1lICkge1xuXHRcdFx0dmFyIGxvd2VyQ2FzZUVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBtYXBbIGxvd2VyQ2FzZUVsZW1lbnROYW1lIF0gfHwgbG93ZXJDYXNlRWxlbWVudE5hbWU7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRidWJibGUgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkYnViYmxlKCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0Ly8gVE9ETyB0aGlzIGNhbiByZWdpc3RlciB0aGUgYXR0cmlidXRlIG11bHRpcGxlIHRpbWVzIChzZWUgcmVuZGVyIHRlc3Rcblx0XHRcdC8vICdBdHRyaWJ1dGUgd2l0aCBuZXN0ZWQgbXVzdGFjaGVzJylcblx0XHRcdGlmICggdmFsdWUgIT09IHRoaXMudmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICd2YWx1ZScgJiYgdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gc3RvcmUgdGhlIHZhbHVlIG9uIHRoZSBET00gbGlrZSB0aGlzIHNvIHdlXG5cdFx0XHRcdFx0Ly8gY2FuIHJldHJpZXZlIGl0IGxhdGVyIHdpdGhvdXQgaXQgYmVpbmcgY29lcmNlZCB0byBhIHN0cmluZ1xuXHRcdFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZS5qcyAqL1xuXHR2YXIgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBlbmZvcmNlQ2FzZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggYXR0cmlidXRlLCBuYW1lICkge1xuXHRcdFx0dmFyIGNvbG9uSW5kZXgsIG5hbWVzcGFjZVByZWZpeDtcblx0XHRcdC8vIGFyZSB3ZSBkZWFsaW5nIHdpdGggYSBuYW1lc3BhY2VkIGF0dHJpYnV0ZSwgZS5nLiB4bGluazpocmVmP1xuXHRcdFx0Y29sb25JbmRleCA9IG5hbWUuaW5kZXhPZiggJzonICk7XG5cdFx0XHRpZiAoIGNvbG9uSW5kZXggIT09IC0xICkge1xuXHRcdFx0XHQvLyBsb29rcyBsaWtlIHdlIGFyZSwgeWVzLi4uXG5cdFx0XHRcdG5hbWVzcGFjZVByZWZpeCA9IG5hbWUuc3Vic3RyKCAwLCBjb2xvbkluZGV4ICk7XG5cdFx0XHRcdC8vIC4uLnVubGVzcyBpdCdzIGEgbmFtZXNwYWNlICpkZWNsYXJhdGlvbiosIHdoaWNoIHdlIGlnbm9yZSAob24gdGhlIGFzc3VtcHRpb25cblx0XHRcdFx0Ly8gdGhhdCBvbmx5IHZhbGlkIG5hbWVzcGFjZXMgd2lsbCBiZSB1c2VkKVxuXHRcdFx0XHRpZiAoIG5hbWVzcGFjZVByZWZpeCAhPT0gJ3htbG5zJyApIHtcblx0XHRcdFx0XHRuYW1lID0gbmFtZS5zdWJzdHJpbmcoIGNvbG9uSW5kZXggKyAxICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5hbWUgPSBlbmZvcmNlQ2FzZSggbmFtZSApO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzWyBuYW1lc3BhY2VQcmVmaXgudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdGlmICggIWF0dHJpYnV0ZS5uYW1lc3BhY2UgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyAnVW5rbm93biBuYW1lc3BhY2UgKFwiJyArIG5hbWVzcGFjZVByZWZpeCArICdcIiknO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFNWRyBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Ugc2Vuc2l0aXZlXG5cdFx0XHRhdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5lbGVtZW50Lm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlcy5odG1sID8gZW5mb3JjZUNhc2UoIG5hbWUgKSA6IG5hbWU7XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcywgZW5mb3JjZUNhc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZ2V0SW50ZXJwb2xhdG9yLmpzICovXG5cdHZhciBnZXRJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdG9yKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBhdHRyaWJ1dGUuZnJhZ21lbnQuaXRlbXM7XG5cdFx0XHRpZiAoIGl0ZW1zLmxlbmd0aCAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpdGVtc1sgMCBdLnR5cGUgPT09IHR5cGVzLklOVEVSUE9MQVRPUiApIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW1zWyAwIF07XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZGV0ZXJtaW5lUHJvcGVydHlOYW1lLmpzICovXG5cdHZhciBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiggbmFtZXNwYWNlcyApIHtcblxuXHRcdC8vIHRoZSBwcm9wZXJ0eSBuYW1lIGVxdWl2YWxlbnRzIGZvciBlbGVtZW50IGF0dHJpYnV0ZXMsIHdoZXJlIHRoZXkgZGlmZmVyXG5cdFx0Ly8gZnJvbSB0aGUgbG93ZXJjYXNlZCBhdHRyaWJ1dGUgbmFtZVxuXHRcdHZhciBwcm9wZXJ0eU5hbWVzID0ge1xuXHRcdFx0J2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuXHRcdFx0YWNjZXNza2V5OiAnYWNjZXNzS2V5Jyxcblx0XHRcdGJnY29sb3I6ICdiZ0NvbG9yJyxcblx0XHRcdCdjbGFzcyc6ICdjbGFzc05hbWUnLFxuXHRcdFx0Y29kZWJhc2U6ICdjb2RlQmFzZScsXG5cdFx0XHRjb2xzcGFuOiAnY29sU3BhbicsXG5cdFx0XHRjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuXHRcdFx0ZGF0ZXRpbWU6ICdkYXRlVGltZScsXG5cdFx0XHRkaXJuYW1lOiAnZGlyTmFtZScsXG5cdFx0XHQnZm9yJzogJ2h0bWxGb3InLFxuXHRcdFx0J2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2Jyxcblx0XHRcdGlzbWFwOiAnaXNNYXAnLFxuXHRcdFx0bWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcblx0XHRcdG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcblx0XHRcdHB1YmRhdGU6ICdwdWJEYXRlJyxcblx0XHRcdHJlYWRvbmx5OiAncmVhZE9ubHknLFxuXHRcdFx0cm93c3BhbjogJ3Jvd1NwYW4nLFxuXHRcdFx0dGFiaW5kZXg6ICd0YWJJbmRleCcsXG5cdFx0XHR1c2VtYXA6ICd1c2VNYXAnXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGF0dHJpYnV0ZSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBwcm9wZXJ0eU5hbWU7XG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5wTm9kZSAmJiAhYXR0cmlidXRlLm5hbWVzcGFjZSAmJiAoICFvcHRpb25zLnBOb2RlLm5hbWVzcGFjZVVSSSB8fCBvcHRpb25zLnBOb2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sICkgKSB7XG5cdFx0XHRcdHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbIGF0dHJpYnV0ZS5uYW1lIF0gfHwgYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5wTm9kZVsgcHJvcGVydHlOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGUucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuXHRcdFx0XHQvLyBub2RlLnNlbGVjdGVkID0gdHJ1ZSByYXRoZXIgdGhhbiBub2RlLnNldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJywgJycgKVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLnBOb2RlWyBwcm9wZXJ0eU5hbWUgXSA9PT0gJ2Jvb2xlYW4nIHx8IHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGUudXNlUHJvcGVydHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSwgZ2V0SW50ZXJwb2xhdG9yLCBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQVRUUklCVVRFO1xuXHRcdFx0dGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXHRcdFx0ZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSggdGhpcywgb3B0aW9ucy5uYW1lICk7XG5cdFx0XHQvLyBpZiBpdCdzIGFuIGVtcHR5IGF0dHJpYnV0ZSwgb3IganVzdCBhIHN0cmFpZ2h0IGtleS12YWx1ZSBwYWlyLCB3aXRoIG5vXG5cdFx0XHQvLyBtdXN0YWNoZSBzaGVuYW5pZ2Fucywgc2V0IHRoZSBhdHRyaWJ1dGUgYWNjb3JkaW5nbHkgYW5kIGdvIGhvbWVcblx0XHRcdGlmICggIW9wdGlvbnMudmFsdWUgfHwgdHlwZW9mIG9wdGlvbnMudmFsdWUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZSB8fCB0cnVlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBkbyBzb21lIHdvcmtcblx0XHRcdC8vIHNoYXJlIHBhcmVudEZyYWdtZW50IHdpdGggcGFyZW50IGVsZW1lbnRcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiBvcHRpb25zLnZhbHVlLFxuXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0Ly8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhpcyBhdHRyaWJ1dGUncyBpbnRlcnBvbGF0b3IsIGlmIGl0cyBmcmFnbWVudFxuXHRcdFx0Ly8gdGFrZXMgdGhlIGZvcm0gYHt7Zm9vfX1gLiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdHdvLXdheSBiaW5kaW5nIGFuZFxuXHRcdFx0Ly8gZm9yIGNvcnJlY3RseSByZW5kZXJpbmcgSFRNTCBsYXRlclxuXHRcdFx0dGhpcy5pbnRlcnBvbGF0b3IgPSBnZXRJbnRlcnBvbGF0b3IoIHRoaXMgKTtcblx0XHRcdHRoaXMuaXNCaW5kYWJsZSA9ICEhdGhpcy5pbnRlcnBvbGF0b3I7XG5cdFx0XHQvLyBjYW4gd2UgZXN0YWJsaXNoIHRoaXMgYXR0cmlidXRlJ3MgcHJvcGVydHkgbmFtZSBlcXVpdmFsZW50P1xuXHRcdFx0ZGV0ZXJtaW5lUHJvcGVydHlOYW1lKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0XHQvLyBtYXJrIGFzIHJlYWR5XG5cdFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHR9O1xuXHR9KCB0eXBlcywgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSwgZ2V0SW50ZXJwb2xhdG9yLCBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlYmluZCA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZW5kZXIgPSBmdW5jdGlvbiggbmFtZXNwYWNlcyApIHtcblxuXHRcdC8vIHRoZSBwcm9wZXJ0eSBuYW1lIGVxdWl2YWxlbnRzIGZvciBlbGVtZW50IGF0dHJpYnV0ZXMsIHdoZXJlIHRoZXkgZGlmZmVyXG5cdFx0Ly8gZnJvbSB0aGUgbG93ZXJjYXNlZCBhdHRyaWJ1dGUgbmFtZVxuXHRcdHZhciBwcm9wZXJ0eU5hbWVzID0ge1xuXHRcdFx0J2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuXHRcdFx0J2FjY2Vzc2tleSc6ICdhY2Nlc3NLZXknLFxuXHRcdFx0J2JnY29sb3InOiAnYmdDb2xvcicsXG5cdFx0XHQnY2xhc3MnOiAnY2xhc3NOYW1lJyxcblx0XHRcdCdjb2RlYmFzZSc6ICdjb2RlQmFzZScsXG5cdFx0XHQnY29sc3Bhbic6ICdjb2xTcGFuJyxcblx0XHRcdCdjb250ZW50ZWRpdGFibGUnOiAnY29udGVudEVkaXRhYmxlJyxcblx0XHRcdCdkYXRldGltZSc6ICdkYXRlVGltZScsXG5cdFx0XHQnZGlybmFtZSc6ICdkaXJOYW1lJyxcblx0XHRcdCdmb3InOiAnaHRtbEZvcicsXG5cdFx0XHQnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuXHRcdFx0J2lzbWFwJzogJ2lzTWFwJyxcblx0XHRcdCdtYXhsZW5ndGgnOiAnbWF4TGVuZ3RoJyxcblx0XHRcdCdub3ZhbGlkYXRlJzogJ25vVmFsaWRhdGUnLFxuXHRcdFx0J3B1YmRhdGUnOiAncHViRGF0ZScsXG5cdFx0XHQncmVhZG9ubHknOiAncmVhZE9ubHknLFxuXHRcdFx0J3Jvd3NwYW4nOiAncm93U3BhbicsXG5cdFx0XHQndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxuXHRcdFx0J3VzZW1hcCc6ICd1c2VNYXAnXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHJlbmRlciggbm9kZSApIHtcblx0XHRcdHZhciBwcm9wZXJ0eU5hbWU7XG5cdFx0XHR0aGlzLm5vZGUgPSBub2RlO1xuXHRcdFx0Ly8gc2hvdWxkIHdlIHVzZSBkaXJlY3QgcHJvcGVydHkgYWNjZXNzLCBvciBzZXRBdHRyaWJ1dGU/XG5cdFx0XHRpZiAoICFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzWyB0aGlzLm5hbWUgXSB8fCB0aGlzLm5hbWU7XG5cdFx0XHRcdGlmICggbm9kZVsgcHJvcGVydHlOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpcyBhdHRyaWJ1dGUgYSBib29sZWFuIGF0dHJpYnV0ZSBvciAndmFsdWUnPyBJZiBzbyB3ZSdyZSBiZXR0ZXIgb2ZmIGRvaW5nIGUuZy5cblx0XHRcdFx0Ly8gbm9kZS5zZWxlY3RlZCA9IHRydWUgcmF0aGVyIHRoYW4gbm9kZS5zZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcsICcnIClcblx0XHRcdFx0aWYgKCB0eXBlb2Ygbm9kZVsgcHJvcGVydHlOYW1lIF0gPT09ICdib29sZWFuJyB8fCBwcm9wZXJ0eU5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0dGhpcy51c2VQcm9wZXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBwcm9wZXJ0eU5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0dGhpcy51c2VQcm9wZXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdG9TdHJpbmcoKSB7XG5cdFx0XHR2YXIgbmFtZSwgdmFsdWUsIGludGVycG9sYXRvcjtcblx0XHRcdG5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3QgdmFsdWVzIChzaG91bGQgbm90IGJlIHN0cmluZ2lmaWVkKVxuXHRcdFx0aWYgKCBuYW1lID09PSAndmFsdWUnICYmIHRoaXMuZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZXNcblx0XHRcdGlmICggbmFtZSA9PT0gJ25hbWUnICYmIHRoaXMuZWxlbWVudC5uYW1lID09PSAnaW5wdXQnICYmICggaW50ZXJwb2xhdG9yID0gdGhpcy5pbnRlcnBvbGF0b3IgKSApIHtcblx0XHRcdFx0cmV0dXJuICduYW1lPXt7JyArICggaW50ZXJwb2xhdG9yLmtleXBhdGggfHwgaW50ZXJwb2xhdG9yLnJlZiApICsgJ319Jztcblx0XHRcdH1cblx0XHRcdC8vIE51bWJlcnNcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0cmV0dXJuIG5hbWUgKyAnPVwiJyArIHZhbHVlICsgJ1wiJztcblx0XHRcdH1cblx0XHRcdC8vIFN0cmluZ3Ncblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIG5hbWUgKyAnPVwiJyArIGVzY2FwZSggdmFsdWUgKSArICdcIic7XG5cdFx0XHR9XG5cdFx0XHQvLyBFdmVyeXRoaW5nIGVsc2Vcblx0XHRcdHJldHVybiB2YWx1ZSA/IG5hbWUgOiAnJztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZXNjYXBlKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKCAvJi9nLCAnJmFtcDsnICkucmVwbGFjZSggL1wiL2csICcmcXVvdDsnICkucmVwbGFjZSggLycvZywgJyYjMzk7JyApO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1bmJpbmQgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdW5iaW5kKCkge1xuXHRcdC8vIGlnbm9yZSBub24tZHluYW1pYyBhdHRyaWJ1dGVzXG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVNlbGVjdFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVTZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3QoKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcblx0XHRcdG9wdGlvbnMsIG9wdGlvbiwgb3B0aW9uVmFsdWUsIGk7XG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcblx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHQvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cdFx0XHRcdGlmICggb3B0aW9uVmFsdWUgPT0gdmFsdWUgKSB7XG5cdFx0XHRcdFx0Ly8gZG91YmxlIGVxdWFscyBhcyB3ZSBtYXkgYmUgY29tcGFyaW5nIG51bWJlcnMgd2l0aCBzdHJpbmdzXG5cdFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uKCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVNdWx0aXBsZVNlbGVjdCgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG5cdFx0XHRcdG9wdGlvbnMsIGksIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cdFx0XHRpZiAoICFpc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IFsgdmFsdWUgXTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcblx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHQvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmluZGV4T2YoIG9wdGlvblZhbHVlICkgIT09IC0xO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlUmFkaW9OYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb05hbWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9OYW1lKCkge1xuXHRcdHZhciBub2RlID0gKCB2YWx1ZSA9IHRoaXMgKS5ub2RlLFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZTtcblx0XHRub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSBub2RlLl9yYWN0aXZlLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVSYWRpb1ZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb1ZhbHVlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWUoKSB7XG5cdFx0XHR2YXIgd2FzQ2hlY2tlZCwgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdFx0YmluZGluZywgYmluZGluZ3MsIGk7XG5cdFx0XHR3YXNDaGVja2VkID0gbm9kZS5jaGVja2VkO1xuXHRcdFx0bm9kZS52YWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSA9PT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cdFx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gaWYgdGhlIGlucHV0IHdhcyBjaGVja2VkLCBhbmQgdGhlIHZhbHVlXG5cdFx0XHQvLyBjaGFuZ2VkIHNvIHRoYXQgaXQncyBubyBsb25nZXIgY2hlY2tlZCwgdGhlIHR3b3dheSBiaW5kaW5nIGlzXG5cdFx0XHQvLyBtb3N0IGxpa2VseSBvdXQgb2YgZGF0ZS4gVG8gZml4IGl0IHdlIGhhdmUgdG8ganVtcCB0aHJvdWdoIHNvbWVcblx0XHRcdC8vIGhvb3BzLi4uIHRoaXMgaXMgYSBsaXR0bGUga2x1ZGd5IGJ1dCBpdCB3b3Jrc1xuXHRcdFx0aWYgKCB3YXNDaGVja2VkICYmICFub2RlLmNoZWNrZWQgJiYgdGhpcy5lbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5lbGVtZW50LmJpbmRpbmcuc2libGluZ3M7XG5cdFx0XHRcdGlmICggaSA9IGJpbmRpbmdzLmxlbmd0aCApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCAhYmluZGluZy5lbGVtZW50Lm5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyLCBzaWJsaW5ncyBhcmUgc3RpbGwgcmVuZGVyaW5nIVxuXHRcdFx0XHRcdFx0XHQvLyB3ZSdsbCBjb21lIGJhY2sgbGF0ZXIuLi5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmVsZW1lbnQubm9kZS5jaGVja2VkICkge1xuXHRcdFx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggYmluZGluZy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIGJpbmRpbmcucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggYmluZGluZy5rZXlwYXRoLCB1bmRlZmluZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ2hlY2tib3hOYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDaGVja2JveE5hbWUgPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2hlY2tib3hOYW1lKCkge1xuXHRcdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdGlmICggIWlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IG5vZGUuX3JhY3RpdmUudmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB2YWx1ZS5pbmRleE9mKCBub2RlLl9yYWN0aXZlLnZhbHVlICkgIT09IC0xO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ2xhc3NOYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lKCkge1xuXHRcdHZhciBub2RlLCB2YWx1ZTtcblx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdH1cblx0XHRub2RlLmNsYXNzTmFtZSA9IHZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVJZEF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSWRBdHRyaWJ1dGUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMucm9vdC5ub2Rlc1sgdmFsdWUgXSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dGhpcy5yb290Lm5vZGVzWyB2YWx1ZSBdID0gbm9kZTtcblx0XHRub2RlLmlkID0gdmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSgpIHtcblx0XHR2YXIgbm9kZSwgdmFsdWU7XG5cdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSAnJztcblx0XHR9XG5cdFx0bm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUoICdjc3NUZXh0JywgdmFsdWUgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlKCkge1xuXHRcdHZhciBub2RlLCB2YWx1ZTtcblx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdG5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlVmFsdWUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdC8vIHN0b3JlIGFjdHVhbCB2YWx1ZSwgc28gaXQgZG9lc24ndCBnZXQgY29lcmNlZCB0byBhIHN0cmluZ1xuXHRcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG5cdFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0bm9kZS52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVCb29sZWFuLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVCb29sZWFuID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGUoKSB7XG5cdFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuXHRcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2Vcblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdHRoaXMubm9kZVsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IHRoaXMudmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVFdmVyeXRoaW5nRWxzZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlRXZlcnl0aGluZ0Vsc2UgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlRXZlcnl0aGluZ0Vsc2UoKSB7XG5cdFx0dmFyIG5vZGUsIG5hbWUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0bmFtZSA9IHRoaXMubmFtZTtcblx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB0aGlzLm5hbWVzcGFjZSApIHtcblx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMoIHRoaXMubmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcblx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggbmFtZSwgJycgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGUgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgbm9vcCwgdXBkYXRlU2VsZWN0VmFsdWUsIHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUsIHVwZGF0ZVJhZGlvTmFtZSwgdXBkYXRlUmFkaW9WYWx1ZSwgdXBkYXRlQ2hlY2tib3hOYW1lLCB1cGRhdGVDbGFzc05hbWUsIHVwZGF0ZUlkQXR0cmlidXRlLCB1cGRhdGVJRVN0eWxlQXR0cmlidXRlLCB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSwgdXBkYXRlVmFsdWUsIHVwZGF0ZUJvb2xlYW4sIHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlICkge1xuXG5cdFx0Ly8gVGhlcmUgYXJlIGEgZmV3IHNwZWNpYWwgY2FzZXMgd2hlbiBpdCBjb21lcyB0byB1cGRhdGluZyBhdHRyaWJ1dGVzLiBGb3IgdGhpcyByZWFzb24sXG5cdFx0Ly8gdGhlIHByb3RvdHlwZSAudXBkYXRlKCkgbWV0aG9kIHBvaW50cyB0byB0aGlzIG1ldGhvZCwgd2hpY2ggd2FpdHMgdW50aWwgdGhlXG5cdFx0Ly8gYXR0cmlidXRlIGhhcyBmaW5pc2hlZCBpbml0aWFsaXNpbmcsIHRoZW4gcmVwbGFjZXMgdGhlIHByb3RvdHlwZSBtZXRob2Qgd2l0aCBhIG1vcmVcblx0XHQvLyBzdWl0YWJsZSBvbmUuIFRoYXQgd2F5LCB3ZSBzYXZlIG91cnNlbHZlcyBkb2luZyBhIGJ1bmNoIG9mIHRlc3RzIG9uIGVhY2ggY2FsbFxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlKCkge1xuXHRcdFx0dmFyIG5hbWUsIGVsZW1lbnQsIG5vZGUsIHR5cGUsIHVwZGF0ZU1ldGhvZDtcblx0XHRcdG5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHRcdGlmICggbmFtZSA9PT0gJ2lkJyApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSWRBdHRyaWJ1dGU7XG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBzZWxlY3RzXG5cdFx0XHRcdGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyAmJiBuYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IG5vZGUubXVsdGlwbGUgPyB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlIDogdXBkYXRlU2VsZWN0VmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ2lucHV0JyApIHtcblx0XHRcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApO1xuXHRcdFx0XHRcdC8vIHR5cGU9J2ZpbGUnIHZhbHVlPSd7e2ZpbGVMaXN0fX0nPlxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gJ2ZpbGUnICkge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gbm9vcDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAncmFkaW8nICYmIGVsZW1lbnQuYmluZGluZyAmJiBlbGVtZW50LmJpbmRpbmcubmFtZSA9PT0gJ25hbWUnICkge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9WYWx1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnR3b3dheSAmJiBuYW1lID09PSAnbmFtZScgKSB7XG5cdFx0XHRcdGlmICggbm9kZS50eXBlID09PSAncmFkaW8nICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvTmFtZTtcblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS50eXBlID09PSAnY2hlY2tib3gnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNoZWNrYm94TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ3N0eWxlJyAmJiBub2RlLnN0eWxlLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdjbGFzcycgJiYgKCAhbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCApICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDbGFzc05hbWU7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnVzZVByb3BlcnR5ICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVCb29sZWFuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdXBkYXRlTWV0aG9kICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVFdmVyeXRoaW5nRWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRlID0gdXBkYXRlTWV0aG9kO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzLCBub29wLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVTZWxlY3RWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9OYW1lLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb1ZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDaGVja2JveE5hbWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNsYXNzTmFtZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSWRBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQm9vbGVhbiwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlRXZlcnl0aGluZ0Vsc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL19BdHRyaWJ1dGUuanMgKi9cblx0dmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBidWJibGUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLmluaXQoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdFx0cmV0dXJuIEF0dHJpYnV0ZTtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlQXR0cmlidXRlcy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCBBdHRyaWJ1dGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnQsIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHR2YXIgbmFtZSwgYXR0cmlidXRlLCByZXN1bHQgPSBbXTtcblx0XHRcdGZvciAoIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZSgge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYXR0cmlidXRlc1sgbmFtZSBdLFxuXHRcdFx0XHRcdFx0cm9vdDogZWxlbWVudC5yb290XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCByZXN1bHRbIG5hbWUgXSA9IGF0dHJpYnV0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIEF0dHJpYnV0ZSApO1xuXG5cdC8qIHV0aWxzL2V4dGVuZC5qcyAqL1xuXHR2YXIgZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgU0xJQ0UkMCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHR2YXIgc291cmNlcyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0dmFyIHByb3AsIHNvdXJjZTtcblx0XHR3aGlsZSAoIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKSApIHtcblx0XHRcdGZvciAoIHByb3AgaW4gc291cmNlICkge1xuXHRcdFx0XHRpZiAoIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXHRcdFx0XHRcdHRhcmdldFsgcHJvcCBdID0gc291cmNlWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9CaW5kaW5nLmpzICovXG5cdHZhciBCaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHdhcm4sIGNyZWF0ZSwgZXh0ZW5kLCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgQmluZGluZyA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGludGVycG9sYXRvciwga2V5cGF0aCwgdmFsdWU7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGUgPSBlbGVtZW50LmF0dHJpYnV0ZXNbIHRoaXMubmFtZSB8fCAndmFsdWUnIF07XG5cdFx0XHRpbnRlcnBvbGF0b3IgPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3I7XG5cdFx0XHRpbnRlcnBvbGF0b3IudHdvd2F5QmluZGluZyA9IHRoaXM7XG5cdFx0XHRpZiAoIGludGVycG9sYXRvci5rZXlwYXRoICYmIGludGVycG9sYXRvci5rZXlwYXRoLnN1YnN0ciA9PT0gJyR7JyApIHtcblx0XHRcdFx0d2FybiggJ1R3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggZXhwcmVzc2lvbnM6ICcgKyBpbnRlcnBvbGF0b3Iua2V5cGF0aCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBBIG11c3RhY2hlIG1heSBiZSAqYW1iaWd1b3VzKi4gTGV0J3Mgc2F5IHdlIHdlcmUgZ2l2ZW5cblx0XHRcdC8vIGB2YWx1ZT1cInt7YmFyfX1cImAuIElmIHRoZSBjb250ZXh0IHdhcyBgZm9vYCwgYW5kIGBmb28uYmFyYFxuXHRcdFx0Ly8gKndhc24ndCogYHVuZGVmaW5lZGAsIHRoZSBrZXlwYXRoIHdvdWxkIGJlIGBmb28uYmFyYC5cblx0XHRcdC8vIFRoZW4sIGFueSB1c2VyIGlucHV0IHdvdWxkIHJlc3VsdCBpbiBgZm9vLmJhcmAgYmVpbmcgdXBkYXRlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBJZiwgaG93ZXZlciwgYGZvby5iYXJgICp3YXMqIHVuZGVmaW5lZCwgYW5kIHNvIHdhcyBgYmFyYCwgd2Ugd291bGQgYmVcblx0XHRcdC8vIGxlZnQgd2l0aCBhbiB1bnJlc29sdmVkIHBhcnRpYWwga2V5cGF0aCAtIHNvIHdlIGFyZSBmb3JjZWQgdG8gbWFrZSBhblxuXHRcdFx0Ly8gYXNzdW1wdGlvbi4gVGhhdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhlIGlucHV0IGluIHF1ZXN0aW9uIHNob3VsZFxuXHRcdFx0Ly8gYmUgZm9yY2VkIHRvIHJlc29sdmUgdG8gYGJhcmAsIGFuZCBhbnkgdXNlciBpbnB1dCB3b3VsZCBhZmZlY3QgYGJhcmBcblx0XHRcdC8vIGFuZCBub3QgYGZvby5iYXJgLlxuXHRcdFx0Ly9cblx0XHRcdC8vIERpZCB0aGF0IG1ha2UgYW55IHNlbnNlPyBObz8gT2guIFNvcnJ5LiBXZWxsIHRoZSBtb3JhbCBvZiB0aGUgc3RvcnkgaXNcblx0XHRcdC8vIGJlIGV4cGxpY2l0IHdoZW4gdXNpbmcgdHdvLXdheSBkYXRhLWJpbmRpbmcgYWJvdXQgd2hhdCBrZXlwYXRoIHlvdSdyZVxuXHRcdFx0Ly8gdXBkYXRpbmcuIFVzaW5nIGl0IGluIGxpc3RzIGlzIHByb2JhYmx5IGEgcmVjaXBlIGZvciBjb25mdXNpb24uLi5cblx0XHRcdGlmICggIWludGVycG9sYXRvci5rZXlwYXRoICkge1xuXHRcdFx0XHRpZiAoIGludGVycG9sYXRvci5yZWYgKSB7XG5cdFx0XHRcdFx0aW50ZXJwb2xhdG9yLnJlc29sdmUoIGludGVycG9sYXRvci5yZWYgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcmVmZXJlbmNlIGV4cHJlc3Npb24gcmVzb2x2ZXIsIHdlIGhhdmUgdG8gZm9yY2Vcblx0XHRcdFx0Ly8gbWVtYmVycyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0byB0aGUgcm9vdFxuXHRcdFx0XHRpZiAoIGludGVycG9sYXRvci5yZXNvbHZlciApIHtcblx0XHRcdFx0XHRpbnRlcnBvbGF0b3IucmVzb2x2ZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGggPSBpbnRlcnBvbGF0b3Iua2V5cGF0aDtcblx0XHRcdC8vIGluaXRpYWxpc2UgdmFsdWUsIGlmIGl0J3MgdW5kZWZpbmVkXG5cdFx0XHRpZiAoIHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICkgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxWYWx1ZSApIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdEJpbmRpbmcucHJvdG90eXBlID0ge1xuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB0aGlzLmdldFZhbHVlKCkgKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0cmVib3VuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBiaW5kaW5ncywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblx0XHRcdFx0b2xkS2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblx0XHRcdFx0bmV3S2V5cGF0aCA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvci5rZXlwYXRoO1xuXHRcdFx0XHQvLyBUaGUgYXR0cmlidXRlIHRoaXMgYmluZGluZyBpcyBsaW5rZWQgdG8gaGFzIGFscmVhZHkgZG9uZSB0aGUgd29ya1xuXHRcdFx0XHRpZiAoIG9sZEtleXBhdGggPT09IG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgb2xkS2V5cGF0aCBdLCB0aGlzICk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgbmV3S2V5cGF0aCBdIHx8ICggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgbmV3S2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7fVxuXHRcdH07XG5cdFx0QmluZGluZy5leHRlbmQgPSBmdW5jdGlvbiggcHJvcGVydGllcyApIHtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmc7XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdFx0QmluZGluZy5jYWxsKCB0aGlzLCBlbGVtZW50ICk7XG5cdFx0XHRcdGlmICggdGhpcy5pbml0ICkge1xuXHRcdFx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0U3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXHRcdFx0ZXh0ZW5kKCBTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlLCBwcm9wZXJ0aWVzICk7XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcuZXh0ZW5kID0gQmluZGluZy5leHRlbmQ7XG5cdFx0XHRyZXR1cm4gU3BlY2lhbGlzZWRCaW5kaW5nO1xuXHRcdH07XG5cdFx0cmV0dXJuIEJpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIHdhcm4sIGNyZWF0ZSwgZXh0ZW5kLCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9zaGFyZWQvaGFuZGxlRG9tRXZlbnQuanMgKi9cblx0dmFyIGhhbmRsZURvbUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCkge1xuXHRcdHRoaXMuX3JhY3RpdmUuYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9Db250ZW50RWRpdGFibGVCaW5kaW5nLmpzICovXG5cdHZhciBDb250ZW50RWRpdGFibGVCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5mcmFnbWVudCA/IHRoaXMuZWxlbWVudC5mcmFnbWVudC50b1N0cmluZygpIDogJyc7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggIXRoaXMucm9vdC5sYXp5ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmlubmVySFRNTDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIENvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvc2hhcmVkL2dldFNpYmxpbmdzLmpzICovXG5cdHZhciBnZXRTaWJsaW5ncyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHNldHMgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0U2libGluZ3MoIGlkLCBncm91cCwga2V5cGF0aCApIHtcblx0XHRcdHZhciBoYXNoID0gaWQgKyBncm91cCArIGtleXBhdGg7XG5cdFx0XHRyZXR1cm4gc2V0c1sgaGFzaCBdIHx8ICggc2V0c1sgaGFzaCBdID0gW10gKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvUmFkaW9CaW5kaW5nLmpzICovXG5cdHZhciBSYWRpb0JpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgUmFkaW9CaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICdjaGVja2VkJyxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ3JhZGlvJywgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICkgKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5mb3JFYWNoKCBmdW5jdGlvbiggYmluZGluZyApIHtcblx0XHRcdFx0XHRiaW5kaW5nLnJvb3Qudmlld21vZGVsLnNldCggYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLmdldFZhbHVlKCkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnNpYmxpbmdzLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBSYWRpb0JpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvUmFkaW9OYW1lQmluZGluZy5qcyAqL1xuXHR2YXIgUmFkaW9OYW1lQmluZGluZyA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50LCBnZXRTaWJsaW5ncyApIHtcblxuXHRcdHZhciBSYWRpb05hbWVCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICduYW1lJyxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ3JhZGlvbmFtZScsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5yYWRpb05hbWUgPSB0cnVlO1xuXHRcdFx0XHQvLyBzbyB0aGF0IHJhY3RpdmUudXBkYXRlTW9kZWwoKSBrbm93cyB3aGF0IHRvIGRvIHdpdGggdGhpc1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS50d293YXkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NoZWNrZWQnICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUubmFtZSA9ICd7eycgKyB0aGlzLmtleXBhdGggKyAnfX0nO1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICkgPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0cmV0dXJuIG5vZGUuX3JhY3RpdmUgPyBub2RlLl9yYWN0aXZlLnZhbHVlIDogbm9kZS52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBJZiB0aGlzIDxpbnB1dD4gaXMgdGhlIG9uZSB0aGF0J3MgY2hlY2tlZCwgdGhlbiB0aGUgdmFsdWUgb2YgaXRzXG5cdFx0XHRcdC8vIGBuYW1lYCBrZXlwYXRoIGdldHMgc2V0IHRvIGl0cyB2YWx1ZVxuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlYm91bmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBub2RlO1xuXHRcdFx0XHRCaW5kaW5nLnByb3RvdHlwZS5yZWJvdW5kLmNhbGwoIHRoaXMsIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSApIHtcblx0XHRcdFx0XHRub2RlLm5hbWUgPSAne3snICsgdGhpcy5rZXlwYXRoICsgJ319Jztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5zaWJsaW5ncywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gUmFkaW9OYW1lQmluZGluZztcblx0fSggcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCwgZ2V0U2libGluZ3MgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9DaGVja2JveE5hbWVCaW5kaW5nLmpzICovXG5cdHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gZnVuY3Rpb24oIGlzQXJyYXksIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ25hbWUnLFxuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGhpcyBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIGdyb3VwIChvZiBpbnB1dHMgdGhhdFxuXHRcdFx0XHQvLyBzaGFyZSBhIG5hbWUpLCBiZWNhdXNlIGl0IG9ubHkgZ2V0cyBjYWxsZWQgaWYgdGhlcmVcblx0XHRcdFx0Ly8gaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZS4gQnkgdGhlIHNhbWUgdG9rZW4sIHdlIGNhbiBtYWtlXG5cdFx0XHRcdC8vIGEgbm90ZSBvZiB0aGF0IGZhY3QgdGhhdCB0aGVyZSB3YXMgbm8gaW5pdGlhbCB2YWx1ZSxcblx0XHRcdFx0Ly8gYW5kIHBvcHVsYXRlIGl0IHVzaW5nIGFueSBgY2hlY2tlZGAgYXR0cmlidXRlcyB0aGF0XG5cdFx0XHRcdC8vIGV4aXN0ICh3aGljaCB1c2VycyBzaG91bGQgYXZvaWQsIGJ1dCB3aGljaCB3ZSBzaG91bGRcblx0XHRcdFx0Ly8gc3VwcG9ydCBhbnl3YXkgdG8gYXZvaWQgYnJlYWtpbmcgZXhwZWN0YXRpb25zKVxuXHRcdFx0XHR0aGlzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlLCBub0luaXRpYWxWYWx1ZTtcblx0XHRcdFx0dGhpcy5jaGVja2JveE5hbWUgPSB0cnVlO1xuXHRcdFx0XHQvLyBzbyB0aGF0IHJhY3RpdmUudXBkYXRlTW9kZWwoKSBrbm93cyB3aGF0IHRvIGRvIHdpdGggdGhpc1xuXHRcdFx0XHQvLyBFYWNoIGlucHV0IGhhcyBhIHJlZmVyZW5jZSB0byBhbiBhcnJheSBjb250YWluaW5nIGl0IGFuZCBpdHNcblx0XHRcdFx0Ly8gc2libGluZ3MsIGFzIHR3by13YXkgYmluZGluZyBkZXBlbmRzIG9uIGJlaW5nIGFibGUgdG8gYXNjZXJ0YWluXG5cdFx0XHRcdC8vIHRoZSBzdGF0dXMgb2YgYWxsIGlucHV0cyB3aXRoaW4gdGhlIGdyb3VwXG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAnY2hlY2tib3hlcycsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0aWYgKCB0aGlzLm5vSW5pdGlhbFZhbHVlICkge1xuXHRcdFx0XHRcdHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vSW5pdGlhbFZhbHVlID0gdGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZTtcblx0XHRcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRpZiAoIG5vSW5pdGlhbFZhbHVlICkge1xuXHRcdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NoZWNrZWQnICk7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmlzQ2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdGV4aXN0aW5nVmFsdWUucHVzaCggYmluZGluZ1ZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gaXNBcnJheSggZXhpc3RpbmdWYWx1ZSApID8gZXhpc3RpbmdWYWx1ZS5pbmRleE9mKCBiaW5kaW5nVmFsdWUgKSAhPT0gLTEgOiBleGlzdGluZ1ZhbHVlID09PSBiaW5kaW5nVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuc2libGluZ3MsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLm5hbWUgPSAne3snICsgdGhpcy5rZXlwYXRoICsgJ319Jztcblx0XHRcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5pc0NoZWNrZWQ7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHQvLyBpbiBjYXNlIG9mIElFIGVtZXJnZW5jeSwgYmluZCB0byBjbGljayBldmVudCBhcyB3ZWxsXG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHdhc0NoZWNrZWQgPSAhIXRoaXMuaXNDaGVja2VkO1xuXHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzLmlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZDtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHRcdEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zaWJsaW5ncy5maWx0ZXIoIGlzQ2hlY2tlZCApLm1hcCggZ2V0VmFsdWUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRmdW5jdGlvbiBpc0NoZWNrZWQoIGJpbmRpbmcgKSB7XG5cdFx0XHRyZXR1cm4gYmluZGluZy5pc0NoZWNrZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIGJpbmRpbmcgKSB7XG5cdFx0XHRyZXR1cm4gYmluZGluZy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gQ2hlY2tib3hOYW1lQmluZGluZztcblx0fSggaXNBcnJheSwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9DaGVja2JveEJpbmRpbmcuanMgKi9cblx0dmFyIENoZWNrYm94QmluZGluZyA9IGZ1bmN0aW9uKCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBDaGVja2JveEJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ2NoZWNrZWQnLFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gQ2hlY2tib3hCaW5kaW5nO1xuXHR9KCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL1NlbGVjdEJpbmRpbmcuanMgKi9cblx0dmFyIFNlbGVjdEJpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgU2VsZWN0QmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuZWxlbWVudC5vcHRpb25zLFxuXHRcdFx0XHRcdGxlbiwgaTtcblx0XHRcdFx0aSA9IGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRpZiAoICFsZW4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHRha2UgdGhlIGZpbmFsIHNlbGVjdGVkIG9wdGlvbi4uLlxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG9yIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uLCBpZiBub25lIGFyZSBzZWxlY3RlZFxuXHRcdFx0XHR3aGlsZSAoICsraSA8IGxlbiApIHtcblx0XHRcdFx0XHRpZiAoICFvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAnZGlzYWJsZWQnICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBUT0RPIHRoaXMgbWV0aG9kIGlzIGFuIGFub21hbHkuLi4gaXMgaXQgbmVjZXNzYXJ5P1xuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuXHRcdFx0XHRsZW4gPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zWyBpIF0uc2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBvcHRpb25WYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIFNlbGVjdEJpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdXRpbHMvYXJyYXlDb250ZW50c01hdGNoLmpzICovXG5cdHZhciBhcnJheUNvbnRlbnRzTWF0Y2ggPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0aWYgKCAhaXNBcnJheSggYSApIHx8ICFpc0FycmF5KCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICggYS5sZW5ndGggIT09IGIubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBhWyBpIF0gIT09IGJbIGkgXSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9NdWx0aXBsZVNlbGVjdEJpbmRpbmcuanMgKi9cblx0dmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCBhcnJheUNvbnRlbnRzTWF0Y2gsIFNlbGVjdEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IFNlbGVjdEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm9wdGlvbnMuZmlsdGVyKCBmdW5jdGlvbiggb3B0aW9uICkge1xuXHRcdFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnICk7XG5cdFx0XHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZUZyb21Nb2RlbDtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR2YWx1ZUZyb21Nb2RlbCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0aWYgKCB2YWx1ZUZyb21Nb2RlbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdC8vIGdldCB2YWx1ZSBmcm9tIERPTSwgaWYgcG9zc2libGVcblx0XHRcdFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUT0RPIG5vdCBpbXBsZW1lbnRlZCB5ZXQnICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2VsZWN0ZWRWYWx1ZXMsIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMgPSBbXTtcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG5cdFx0XHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCApIHtcblx0XHRcdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMucHVzaCggb3B0aW9uVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNlbGVjdGVkVmFsdWVzO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUsIHByZXZpb3VzVmFsdWUsIHZhbHVlO1xuXHRcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcblx0XHRcdFx0cHJldmlvdXNWYWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICggcHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFhcnJheUNvbnRlbnRzTWF0Y2goIHZhbHVlLCBwcmV2aW91c1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0U2VsZWN0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGVNb2RlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGUudmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhdGhpcy5hdHRyaWJ1dGUudmFsdWUubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHRoaXMuaW5pdGlhbFZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIE11bHRpcGxlU2VsZWN0QmluZGluZztcblx0fSggcnVubG9vcCwgYXJyYXlDb250ZW50c01hdGNoLCBTZWxlY3RCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0ZpbGVMaXN0QmluZGluZy5qcyAqL1xuXHR2YXIgRmlsZUxpc3RCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIEZpbGVMaXN0QmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuZmlsZXM7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBGaWxlTGlzdEJpbmRpbmc7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvR2VuZXJpY0JpbmRpbmcuanMgKi9cblx0dmFyIEdlbmVyaWNCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIEdlbmVyaWNCaW5kaW5nLCBnZXRPcHRpb25zO1xuXHRcdGdldE9wdGlvbnMgPSB7XG5cdFx0XHRldmFsdWF0ZVdyYXBwZWQ6IHRydWVcblx0XHR9O1xuXHRcdEdlbmVyaWNCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCAhdGhpcy5yb290LmxhenkgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgaGFuZGxlQmx1ciwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdibHVyJywgaGFuZGxlQmx1ciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIEdlbmVyaWNCaW5kaW5nO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGhhbmRsZURvbUV2ZW50LmNhbGwoIHRoaXMgKTtcblx0XHRcdHZhbHVlID0gdGhpcy5fcmFjdGl2ZS5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMuX3JhY3RpdmUuYmluZGluZy5rZXlwYXRoLCBnZXRPcHRpb25zICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcblx0XHR9XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvTnVtZXJpY0JpbmRpbmcuanMgKi9cblx0dmFyIE51bWVyaWNCaW5kaW5nID0gZnVuY3Rpb24oIEdlbmVyaWNCaW5kaW5nICkge1xuXG5cdFx0cmV0dXJuIEdlbmVyaWNCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQoIHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlICk7XG5cdFx0XHRcdHJldHVybiBpc05hTiggdmFsdWUgKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSggR2VuZXJpY0JpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlVHdvd2F5QmluZGluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlVHdvd2F5QmluZGluZyA9IGZ1bmN0aW9uKCBsb2csIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcsIFJhZGlvQmluZGluZywgUmFkaW9OYW1lQmluZGluZywgQ2hlY2tib3hOYW1lQmluZGluZywgQ2hlY2tib3hCaW5kaW5nLCBTZWxlY3RCaW5kaW5nLCBNdWx0aXBsZVNlbGVjdEJpbmRpbmcsIEZpbGVMaXN0QmluZGluZywgTnVtZXJpY0JpbmRpbmcsIEdlbmVyaWNCaW5kaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVR3b3dheUJpbmRpbmcoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcyxcblx0XHRcdFx0dHlwZSwgQmluZGluZywgYmluZE5hbWUsIGJpbmRDaGVja2VkO1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGxhdGUgYmluZGluZywgYW5kIHRoZXJlJ3MgYWxyZWFkeSBvbmUsIGl0XG5cdFx0XHQvLyBuZWVkcyB0byBiZSB0b3JuIGRvd25cblx0XHRcdGlmICggZWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRlbGVtZW50LmJpbmRpbmcudGVhcmRvd24oKTtcblx0XHRcdFx0ZWxlbWVudC5iaW5kaW5nID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGNvbnRlbnRlZGl0YWJsZVxuXHRcdFx0aWYgKCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBDb250ZW50RWRpdGFibGVCaW5kaW5nO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnaW5wdXQnICkge1xuXHRcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApO1xuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94JyApIHtcblx0XHRcdFx0XHRiaW5kTmFtZSA9IGlzQmluZGFibGUoIGF0dHJpYnV0ZXMubmFtZSApO1xuXHRcdFx0XHRcdGJpbmRDaGVja2VkID0gaXNCaW5kYWJsZSggYXR0cmlidXRlcy5jaGVja2VkICk7XG5cdFx0XHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBiaW5kIHRoZSBuYW1lIGF0dHJpYnV0ZSwgb3IgdGhlIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcblx0XHRcdFx0XHRpZiAoIGJpbmROYW1lICYmIGJpbmRDaGVja2VkICkge1xuXHRcdFx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdiYWRSYWRpb0lucHV0QmluZGluZydcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBiaW5kTmFtZSApIHtcblx0XHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAncmFkaW8nID8gUmFkaW9OYW1lQmluZGluZyA6IENoZWNrYm94TmFtZUJpbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYmluZENoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gJ3JhZGlvJyA/IFJhZGlvQmluZGluZyA6IENoZWNrYm94QmluZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdmaWxlJyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0QmluZGluZyA9IEZpbGVMaXN0QmluZGluZztcblx0XHRcdFx0fSBlbHNlIGlmICggaXNCaW5kYWJsZSggYXR0cmlidXRlcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAncmFuZ2UnID8gTnVtZXJpY0JpbmRpbmcgOiBHZW5lcmljQmluZGluZztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApID8gTXVsdGlwbGVTZWxlY3RCaW5kaW5nIDogU2VsZWN0QmluZGluZztcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBHZW5lcmljQmluZGluZztcblx0XHRcdH1cblx0XHRcdGlmICggQmluZGluZyApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBCaW5kaW5nKCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzQmluZGFibGUoIGF0dHJpYnV0ZSApIHtcblx0XHRcdHJldHVybiBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQmluZGFibGU7XG5cdFx0fVxuXHR9KCBsb2csIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcsIFJhZGlvQmluZGluZywgUmFkaW9OYW1lQmluZGluZywgQ2hlY2tib3hOYW1lQmluZGluZywgQ2hlY2tib3hCaW5kaW5nLCBTZWxlY3RCaW5kaW5nLCBNdWx0aXBsZVNlbGVjdEJpbmRpbmcsIEZpbGVMaXN0QmluZGluZywgTnVtZXJpY0JpbmRpbmcsIEdlbmVyaWNCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvZmlyZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRmaXJlID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGZpcmUoIGV2ZW50ICkge1xuXHRcdHRoaXMucm9vdC5maXJlKCB0aGlzLmFjdGlvbi50b1N0cmluZygpLnRyaW0oKSwgZXZlbnQgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGluaXQgPSBmdW5jdGlvbiggY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIGdldFZhbHVlT3B0aW9ucyA9IHtcblx0XHRcdGFyZ3M6IHRydWVcblx0XHR9O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRpbml0KCBlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBhY3Rpb247XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdHRoaXMucHJveGllcyA9IFtdO1xuXHRcdFx0Ly8gR2V0IGFjdGlvbiAoJ2ZvbycgaW4gJ29uLWNsaWNrPSdmb28nKVxuXHRcdFx0YWN0aW9uID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblx0XHRcdGlmICggdHlwZW9mIGFjdGlvbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGFjdGlvbiA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiBhY3Rpb24sXG5cdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLmVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5hY3Rpb24gPSBhY3Rpb247XG5cdFx0XHQvLyBHZXQgcGFyYW1ldGVyc1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5kICkge1xuXHRcdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcblx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMuZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0dGhpcy5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuXHRcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoUGFyYW1zO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBmaXJlRXZlbnRXaXRoUGFyYW1zKCBldmVudCApIHtcblx0XHRcdHRoaXMucm9vdC5maXJlLmFwcGx5KCB0aGlzLnJvb3QsIFtcblx0XHRcdFx0dGhpcy5hY3Rpb24udG9TdHJpbmcoKS50cmltKCksXG5cdFx0XHRcdGV2ZW50XG5cdFx0XHRdLmNvbmNhdCggdGhpcy5wYXJhbXMgKSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zKCBldmVudCApIHtcblx0XHRcdHZhciBhcmdzID0gdGhpcy5keW5hbWljUGFyYW1zLmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdC8vIG5lZWQgdG8gc3RyaXAgW10gZnJvbSBlbmRzIGlmIGEgc3RyaW5nIVxuXHRcdFx0aWYgKCB0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGFyZ3MgPSBhcmdzLnN1YnN0ciggMSwgYXJncy5sZW5ndGggLSAyICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJvb3QuZmlyZS5hcHBseSggdGhpcy5yb290LCBbXG5cdFx0XHRcdHRoaXMuYWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpLFxuXHRcdFx0XHRldmVudFxuXHRcdFx0XS5jb25jYXQoIGFyZ3MgKSApO1xuXHRcdH1cblx0fSggY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmViaW5kID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdGlmICggdHlwZW9mIHRoaXMuYWN0aW9uICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdHRoaXMuYWN0aW9uLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5keW5hbWljUGFyYW1zICkge1xuXHRcdFx0dGhpcy5keW5hbWljUGFyYW1zLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvc2hhcmVkL2dlbmVyaWNIYW5kbGVyLmpzICovXG5cdHZhciBnZW5lcmljSGFuZGxlciA9IGZ1bmN0aW9uIGdlbmVyaWNIYW5kbGVyKCBldmVudCApIHtcblx0XHR2YXIgc3RvcmFnZSwgaGFuZGxlcjtcblx0XHRzdG9yYWdlID0gdGhpcy5fcmFjdGl2ZTtcblx0XHRoYW5kbGVyID0gc3RvcmFnZS5ldmVudHNbIGV2ZW50LnR5cGUgXTtcblx0XHRoYW5kbGVyLmZpcmUoIHtcblx0XHRcdG5vZGU6IHRoaXMsXG5cdFx0XHRvcmlnaW5hbDogZXZlbnQsXG5cdFx0XHRpbmRleDogc3RvcmFnZS5pbmRleCxcblx0XHRcdGtleXBhdGg6IHN0b3JhZ2Uua2V5cGF0aCxcblx0XHRcdGNvbnRleHQ6IHN0b3JhZ2Uucm9vdC5nZXQoIHN0b3JhZ2Uua2V5cGF0aCApXG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZW5kZXIgPSBmdW5jdGlvbiggd2FybiwgY29uZmlnLCBnZW5lcmljSGFuZGxlciApIHtcblxuXHRcdHZhciBjdXN0b21IYW5kbGVycyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmVuZGVyKCkge1xuXHRcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUsXG5cdFx0XHRcdGRlZmluaXRpb247XG5cdFx0XHR0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdGlmICggZGVmaW5pdGlvbiA9IGNvbmZpZy5yZWdpc3RyaWVzLmV2ZW50cy5maW5kKCB0aGlzLnJvb3QsIG5hbWUgKSApIHtcblx0XHRcdFx0dGhpcy5jdXN0b20gPSBkZWZpbml0aW9uKCB0aGlzLm5vZGUsIGdldEN1c3RvbUhhbmRsZXIoIG5hbWUgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTG9va3MgbGlrZSB3ZSdyZSBkZWFsaW5nIHdpdGggYSBzdGFuZGFyZCBET00gZXZlbnQuLi4gYnV0IGxldCdzIGNoZWNrXG5cdFx0XHRcdGlmICggISggJ29uJyArIG5hbWUgaW4gdGhpcy5ub2RlICkgJiYgISggd2luZG93ICYmICdvbicgKyBuYW1lIGluIHdpbmRvdyApICkge1xuXHRcdFx0XHRcdHdhcm4oICdNaXNzaW5nIFwiJyArIHRoaXMubmFtZSArICdcIiBldmVudC4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEgcGx1Z2luIHZpYSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9wbHVnaW5zI2V2ZW50cycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggbmFtZSwgZ2VuZXJpY0hhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdG9yZSB0aGlzIG9uIHRoZSBub2RlIGl0c2VsZiwgc28gaXQgY2FuIGJlIHJldHJpZXZlZCBieSBhXG5cdFx0XHQvLyB1bml2ZXJzYWwgaGFuZGxlclxuXHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmV2ZW50c1sgbmFtZSBdID0gdGhpcztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q3VzdG9tSGFuZGxlciggbmFtZSApIHtcblx0XHRcdGlmICggIWN1c3RvbUhhbmRsZXJzWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGN1c3RvbUhhbmRsZXJzWyBuYW1lIF0gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0dmFyIHN0b3JhZ2UgPSBldmVudC5ub2RlLl9yYWN0aXZlO1xuXHRcdFx0XHRcdGV2ZW50LmluZGV4ID0gc3RvcmFnZS5pbmRleDtcblx0XHRcdFx0XHRldmVudC5rZXlwYXRoID0gc3RvcmFnZS5rZXlwYXRoO1xuXHRcdFx0XHRcdGV2ZW50LmNvbnRleHQgPSBzdG9yYWdlLnJvb3QuZ2V0KCBzdG9yYWdlLmtleXBhdGggKTtcblx0XHRcdFx0XHRzdG9yYWdlLmV2ZW50c1sgbmFtZSBdLmZpcmUoIGV2ZW50ICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3VzdG9tSGFuZGxlcnNbIG5hbWUgXTtcblx0XHR9XG5cdH0oIHdhcm4sIGNvbmZpZywgZ2VuZXJpY0hhbmRsZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS90ZWFyZG93bi5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR0ZWFyZG93biA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR0ZWFyZG93bigpIHtcblx0XHQvLyBUZWFyIGRvd24gZHluYW1pYyBuYW1lXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5hY3Rpb24gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0dGhpcy5hY3Rpb24udGVhcmRvd24oKTtcblx0XHR9XG5cdFx0Ly8gVGVhciBkb3duIGR5bmFtaWMgcGFyYW1ldGVyc1xuXHRcdGlmICggdGhpcy5keW5hbWljUGFyYW1zICkge1xuXHRcdFx0dGhpcy5keW5hbWljUGFyYW1zLnRlYXJkb3duKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHVucmVuZGVyID0gZnVuY3Rpb24oIGdlbmVyaWNIYW5kbGVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bnJlbmRlcigpIHtcblx0XHRcdGlmICggdGhpcy5jdXN0b20gKSB7XG5cdFx0XHRcdHRoaXMuY3VzdG9tLnRlYXJkb3duKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggdGhpcy5uYW1lLCBnZW5lcmljSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBnZW5lcmljSGFuZGxlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvX0V2ZW50SGFuZGxlci5qcyAqL1xuXHR2YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oIGZpcmUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0ZWFyZG93biwgdW5yZW5kZXIgKSB7XG5cblx0XHR2YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oIGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlICkge1xuXHRcdFx0dGhpcy5pbml0KCBlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSApO1xuXHRcdH07XG5cdFx0RXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGZpcmU6IGZpcmUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRlYXJkb3duOiB0ZWFyZG93bixcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0cmV0dXJuIEV2ZW50SGFuZGxlcjtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRmaXJlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR0ZWFyZG93biwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR1bnJlbmRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVFdmVudEhhbmRsZXJzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24oIEV2ZW50SGFuZGxlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbWVudCwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgaSwgbmFtZSwgbmFtZXMsIGhhbmRsZXIsIHJlc3VsdCA9IFtdO1xuXHRcdFx0Zm9yICggbmFtZSBpbiB0ZW1wbGF0ZSApIHtcblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZS5oYXNPd25Qcm9wZXJ0eSggbmFtZSApICkge1xuXHRcdFx0XHRcdG5hbWVzID0gbmFtZS5zcGxpdCggJy0nICk7XG5cdFx0XHRcdFx0aSA9IG5hbWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyKCBlbGVtZW50LCBuYW1lc1sgaSBdLCB0ZW1wbGF0ZVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCggaGFuZGxlciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9KCBFdmVudEhhbmRsZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRGVjb3JhdG9yL19EZWNvcmF0b3IuanMgKi9cblx0dmFyIERlY29yYXRvciA9IGZ1bmN0aW9uKCBsb2csIGNpcmN1bGFyLCBjb25maWcgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIGdldFZhbHVlT3B0aW9ucywgRGVjb3JhdG9yO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0Z2V0VmFsdWVPcHRpb25zID0ge1xuXHRcdFx0YXJnczogdHJ1ZVxuXHRcdH07XG5cdFx0RGVjb3JhdG9yID0gZnVuY3Rpb24oIGVsZW1lbnQsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIGRlY29yYXRvciA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIG5hbWUsIGZyYWdtZW50O1xuXHRcdFx0ZGVjb3JhdG9yLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0ZGVjb3JhdG9yLnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuXHRcdFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cdFx0XHRpZiAoIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiBlbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5hICkge1xuXHRcdFx0XHRkZWNvcmF0b3IucGFyYW1zID0gdGVtcGxhdGUuYTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLmQgKSB7XG5cdFx0XHRcdGRlY29yYXRvci5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRkZWNvcmF0b3IucGFyYW1zID0gZGVjb3JhdG9yLmZyYWdtZW50LmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0ZGVjb3JhdG9yLmZyYWdtZW50LmJ1YmJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0XHRkZWNvcmF0b3IucGFyYW1zID0gdGhpcy5nZXRWYWx1ZSggZ2V0VmFsdWVPcHRpb25zICk7XG5cdFx0XHRcdFx0aWYgKCBkZWNvcmF0b3IucmVhZHkgKSB7XG5cdFx0XHRcdFx0XHRkZWNvcmF0b3IudXBkYXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0ZGVjb3JhdG9yLmZuID0gY29uZmlnLnJlZ2lzdHJpZXMuZGVjb3JhdG9ycy5maW5kKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoICFkZWNvcmF0b3IuZm4gKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRwbHVnaW46ICdkZWNvcmF0b3InLFxuXHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RGVjb3JhdG9yLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZGVjb3JhdG9yID0gdGhpcyxcblx0XHRcdFx0XHRub2RlLCByZXN1bHQsIGFyZ3M7XG5cdFx0XHRcdG5vZGUgPSBkZWNvcmF0b3IuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRpZiAoIGRlY29yYXRvci5wYXJhbXMgKSB7XG5cdFx0XHRcdFx0YXJncyA9IFsgbm9kZSBdLmNvbmNhdCggZGVjb3JhdG9yLnBhcmFtcyApO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRlY29yYXRvci5mbi5hcHBseSggZGVjb3JhdG9yLnJvb3QsIGFyZ3MgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBkZWNvcmF0b3IuZm4uY2FsbCggZGVjb3JhdG9yLnJvb3QsIG5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFyZXN1bHQgfHwgIXJlc3VsdC50ZWFyZG93biApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdEZWNvcmF0b3IgZGVmaW5pdGlvbiBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2l0aCBhIHRlYXJkb3duIG1ldGhvZCcgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUT0RPIGRvZXMgdGhpcyBtYWtlIHNlbnNlP1xuXHRcdFx0XHRkZWNvcmF0b3IuYWN0dWFsID0gcmVzdWx0O1xuXHRcdFx0XHRkZWNvcmF0b3IucmVhZHkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hY3R1YWwudXBkYXRlICkge1xuXHRcdFx0XHRcdHRoaXMuYWN0dWFsLnVwZGF0ZS5hcHBseSggdGhpcy5yb290LCB0aGlzLnBhcmFtcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKCB0cnVlICk7XG5cdFx0XHRcdFx0dGhpcy5pbml0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oIHVwZGF0aW5nICkge1xuXHRcdFx0XHR0aGlzLmFjdHVhbC50ZWFyZG93bigpO1xuXHRcdFx0XHRpZiAoICF1cGRhdGluZyAmJiB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBEZWNvcmF0b3I7XG5cdH0oIGxvZywgY2lyY3VsYXIsIGNvbmZpZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL3NlbGVjdC9zeW5jLmpzICovXG5cdHZhciBzeW5jID0gZnVuY3Rpb24oIHRvQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc3luY1NlbGVjdCggc2VsZWN0RWxlbWVudCApIHtcblx0XHRcdHZhciBzZWxlY3ROb2RlLCBzZWxlY3RWYWx1ZSwgaXNNdWx0aXBsZSwgb3B0aW9ucywgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cdFx0XHRzZWxlY3ROb2RlID0gc2VsZWN0RWxlbWVudC5ub2RlO1xuXHRcdFx0aWYgKCAhc2VsZWN0Tm9kZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucyA9IHRvQXJyYXkoIHNlbGVjdE5vZGUub3B0aW9ucyApO1xuXHRcdFx0c2VsZWN0VmFsdWUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aXNNdWx0aXBsZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICk7XG5cdFx0XHQvLyBJZiB0aGUgPHNlbGVjdD4gaGFzIGEgc3BlY2lmaWVkIHZhbHVlLCB0aGF0IHNob3VsZCBvdmVycmlkZVxuXHRcdFx0Ly8gdGhlc2Ugb3B0aW9uc1xuXHRcdFx0aWYgKCBzZWxlY3RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRvcHRpb25zLmZvckVhY2goIGZ1bmN0aW9uKCBvICkge1xuXHRcdFx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2hvdWxkU2VsZWN0O1xuXHRcdFx0XHRcdG9wdGlvblZhbHVlID0gby5fcmFjdGl2ZSA/IG8uX3JhY3RpdmUudmFsdWUgOiBvLnZhbHVlO1xuXHRcdFx0XHRcdHNob3VsZFNlbGVjdCA9IGlzTXVsdGlwbGUgPyB2YWx1ZUNvbnRhaW5zKCBzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUgKSA6IHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlO1xuXHRcdFx0XHRcdGlmICggc2hvdWxkU2VsZWN0ICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvLnNlbGVjdGVkID0gc2hvdWxkU2VsZWN0O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggIW9wdGlvbldhc1NlbGVjdGVkICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9uc1sgMCBdICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uc1sgMCBdLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3RFbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHNlbGVjdEVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHZhbHVlQ29udGFpbnMoIHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSApIHtcblx0XHRcdHZhciBpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VsZWN0VmFsdWVbIGkgXSA9PSBvcHRpb25WYWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSggdG9BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL3NlbGVjdC9idWJibGUuanMgKi9cblx0dmFyIGJ1YmJsZSA9IGZ1bmN0aW9uKCBydW5sb29wLCBzeW5jU2VsZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGJ1YmJsZVNlbGVjdCgpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0aWYgKCAhdGhpcy5kaXJ0eSApIHtcblx0XHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzeW5jU2VsZWN0KCB0aGlzJDAgKTtcblx0XHRcdFx0XHR0aGlzJDAuZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHR9O1xuXHR9KCBydW5sb29wLCBzeW5jICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL2ZpbmRQYXJlbnRTZWxlY3QuanMgKi9cblx0dmFyIGZpbmRQYXJlbnRTZWxlY3QgPSBmdW5jdGlvbiBmaW5kUGFyZW50U2VsZWN0KCBlbGVtZW50ICkge1xuXHRcdGRvIHtcblx0XHRcdGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL29wdGlvbi9pbml0LmpzICovXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oIGZpbmRQYXJlbnRTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gaW5pdE9wdGlvbiggb3B0aW9uLCB0ZW1wbGF0ZSApIHtcblx0XHRcdG9wdGlvbi5zZWxlY3QgPSBmaW5kUGFyZW50U2VsZWN0KCBvcHRpb24ucGFyZW50ICk7XG5cdFx0XHRvcHRpb24uc2VsZWN0Lm9wdGlvbnMucHVzaCggb3B0aW9uICk7XG5cdFx0XHQvLyBJZiB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIG1pc3NpbmcsIHVzZSB0aGUgZWxlbWVudCdzIGNvbnRlbnRcblx0XHRcdGlmICggIXRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdHRlbXBsYXRlLmEgPSB7fTtcblx0XHRcdH1cblx0XHRcdC8vIC4uLmFzIGxvbmcgYXMgaXQgaXNuJ3QgZGlzYWJsZWRcblx0XHRcdGlmICggIXRlbXBsYXRlLmEudmFsdWUgJiYgIXRlbXBsYXRlLmEuaGFzT3duUHJvcGVydHkoICdkaXNhYmxlZCcgKSApIHtcblx0XHRcdFx0dGVtcGxhdGUuYS52YWx1ZSA9IHRlbXBsYXRlLmY7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCBidXQgdGhlIDxzZWxlY3Q+XG5cdFx0XHQvLyBhbHJlYWR5IGhhcyBhIHZhbHVlLCBkZWxldGUgaXRcblx0XHRcdGlmICggJ3NlbGVjdGVkJyBpbiB0ZW1wbGF0ZS5hICYmIG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZGVsZXRlIHRlbXBsYXRlLmEuc2VsZWN0ZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggZmluZFBhcmVudFNlbGVjdCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXQgPSBmdW5jdGlvbiggdHlwZXMsIGVuZm9yY2VDYXNlLCBjcmVhdGVBdHRyaWJ1dGVzLCBjcmVhdGVUd293YXlCaW5kaW5nLCBjcmVhdGVFdmVudEhhbmRsZXJzLCBEZWNvcmF0b3IsIGJ1YmJsZVNlbGVjdCwgaW5pdE9wdGlvbiwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gRWxlbWVudCRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgcmFjdGl2ZSwgYmluZGluZywgYmluZGluZ3M7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5FTEVNRU5UO1xuXHRcdFx0Ly8gc3R1ZmYgd2UnbGwgbmVlZCBsYXRlclxuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHR0aGlzLnBhcmVudCA9IG9wdGlvbnMucEVsZW1lbnQgfHwgcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5uYW1lID0gZW5mb3JjZUNhc2UoIHRlbXBsYXRlLmUgKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+IGVsZW1lbnRzXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdGluaXRPcHRpb24oIHRoaXMsIHRlbXBsYXRlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2VsZWN0PiBlbGVtZW50c1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdzZWxlY3QnICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMgPSBbXTtcblx0XHRcdFx0dGhpcy5idWJibGUgPSBidWJibGVTZWxlY3Q7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgYXR0cmlidXRlc1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlcyggdGhpcywgdGVtcGxhdGUuYSApO1xuXHRcdFx0Ly8gYXBwZW5kIGNoaWxkcmVuLCBpZiB0aGVyZSBhcmUgYW55XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmYgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZixcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRcdHBFbGVtZW50OiB0aGlzXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSB0d293YXkgYmluZGluZ1xuXHRcdFx0aWYgKCByYWN0aXZlLnR3b3dheSAmJiAoIGJpbmRpbmcgPSBjcmVhdGVUd293YXlCaW5kaW5nKCB0aGlzLCB0ZW1wbGF0ZS5hICkgKSApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcblx0XHRcdFx0Ly8gcmVnaXN0ZXIgdGhpcyB3aXRoIHRoZSByb290LCBzbyB0aGF0IHdlIGNhbiBkbyByYWN0aXZlLnVwZGF0ZU1vZGVsKClcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBiaW5kaW5nLmtleXBhdGggXSB8fCAoIHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIGJpbmRpbmcua2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggYmluZGluZyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIGV2ZW50IHByb3hpZXNcblx0XHRcdGlmICggdGVtcGxhdGUudiApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzID0gY3JlYXRlRXZlbnRIYW5kbGVycyggdGhpcywgdGVtcGxhdGUudiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIGRlY29yYXRvclxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5vICkge1xuXHRcdFx0XHR0aGlzLmRlY29yYXRvciA9IG5ldyBEZWNvcmF0b3IoIHRoaXMsIHRlbXBsYXRlLm8gKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSB0cmFuc2l0aW9uc1xuXHRcdFx0dGhpcy5pbnRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQxO1xuXHRcdFx0dGhpcy5vdXRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQyO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBlbmZvcmNlQ2FzZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlQXR0cmlidXRlcywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlVHdvd2F5QmluZGluZywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlRXZlbnRIYW5kbGVycywgRGVjb3JhdG9yLCBidWJibGUsIGluaXQsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvc3RhcnRzV2l0aC5qcyAqL1xuXHR2YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKCBzdGFydHNXaXRoS2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzdGFydHNXaXRoKCB0YXJnZXQsIGtleXBhdGggKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0ID09PSBrZXlwYXRoIHx8IHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXQsIGtleXBhdGggKTtcblx0XHR9O1xuXHR9KCBzdGFydHNXaXRoS2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL2Fzc2lnbk5ld0tleXBhdGguanMgKi9cblx0dmFyIGFzc2lnbk5ld0tleXBhdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aCwgZ2V0TmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhc3NpZ25OZXdLZXlwYXRoKCB0YXJnZXQsIHByb3BlcnR5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dmFyIGV4aXN0aW5nS2V5cGF0aCA9IHRhcmdldFsgcHJvcGVydHkgXTtcblx0XHRcdGlmICggIWV4aXN0aW5nS2V5cGF0aCB8fCBzdGFydHNXaXRoKCBleGlzdGluZ0tleXBhdGgsIG5ld0tleXBhdGggKSB8fCAhc3RhcnRzV2l0aCggZXhpc3RpbmdLZXlwYXRoLCBvbGRLZXlwYXRoICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRhcmdldFsgcHJvcGVydHkgXSA9IGdldE5ld0tleXBhdGgoIGV4aXN0aW5nS2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGgsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlYmluZCA9IGZ1bmN0aW9uKCBhc3NpZ25OZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgaSwgc3RvcmFnZSwgbGl2ZVF1ZXJpZXMsIHJhY3RpdmU7XG5cdFx0XHRpZiAoIHRoaXMuYXR0cmlidXRlcyApIHtcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdH1cblx0XHRcdC8vIHJlYmluZCBjaGlsZHJlblxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRyZWJpbmQoIHRoaXMuZnJhZ21lbnQgKTtcblx0XHRcdH1cblx0XHRcdC8vIFVwZGF0ZSBsaXZlIHF1ZXJpZXMsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCBsaXZlUXVlcmllcyA9IHRoaXMubGl2ZVF1ZXJpZXMgKSB7XG5cdFx0XHRcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cdFx0XHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGxpdmVRdWVyaWVzWyBpIF0uX21ha2VEaXJ0eSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubm9kZSAmJiAoIHN0b3JhZ2UgPSB0aGlzLm5vZGUuX3JhY3RpdmUgKSApIHtcblx0XHRcdFx0Ly8gYWRqdXN0IGtleXBhdGggaWYgbmVlZGVkXG5cdFx0XHRcdGFzc2lnbk5ld0tleXBhdGgoIHN0b3JhZ2UsICdrZXlwYXRoJywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGluZGV4UmVmICE9IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRzdG9yYWdlLmluZGV4WyBpbmRleFJlZiBdID0gbmV3SW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmViaW5kKCB0aGluZyApIHtcblx0XHRcdFx0dGhpbmcucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBhc3NpZ25OZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvaW1nL3JlbmRlci5qcyAqL1xuXHR2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVySW1hZ2UoIGltZyApIHtcblx0XHR2YXIgd2lkdGgsIGhlaWdodCwgbG9hZEhhbmRsZXI7XG5cdFx0Ly8gaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXkgbmVlZCB0byBwcmV2ZW50IGl0XG5cdFx0Ly8gZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpdCBsb2FkcyB0aGUgc3JjXG5cdFx0aWYgKCAoIHdpZHRoID0gaW1nLmdldEF0dHJpYnV0ZSggJ3dpZHRoJyApICkgfHwgKCBoZWlnaHQgPSBpbWcuZ2V0QXR0cmlidXRlKCAnaGVpZ2h0JyApICkgKSB7XG5cdFx0XHRpbWcubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggd2lkdGggKSB7XG5cdFx0XHRcdFx0aW1nLm5vZGUud2lkdGggPSB3aWR0aC52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGhlaWdodCApIHtcblx0XHRcdFx0XHRpbWcubm9kZS5oZWlnaHQgPSBoZWlnaHQudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW1nLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBsb2FkSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH0sIGZhbHNlICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRpbml0ID0gZnVuY3Rpb24oIGxvZywgY29uZmlnLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgZ2V0VmFsdWVPcHRpb25zID0ge307XG5cdFx0Ly8gVE9ETyB3aGF0IGFyZSB0aGUgb3B0aW9ucz9cblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBUcmFuc2l0aW9uJGluaXQoIGVsZW1lbnQsIHRlbXBsYXRlLCBpc0ludHJvICkge1xuXHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblx0XHRcdHQuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR0LnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuXHRcdFx0dC5pc0ludHJvID0gaXNJbnRybztcblx0XHRcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXHRcdFx0aWYgKCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IG5hbWUsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdHQubmFtZSA9IG5hbWU7XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdHQucGFyYW1zID0gdGVtcGxhdGUuYTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLmQgKSB7XG5cdFx0XHRcdC8vIFRPRE8gaXMgdGhlcmUgYSB3YXkgdG8gaW50ZXJwcmV0IGR5bmFtaWMgYXJndW1lbnRzIHdpdGhvdXQgYWxsIHRoZVxuXHRcdFx0XHQvLyAnZGVwZW5kZW5jeSB0aHJhc2hpbmcnP1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0LnBhcmFtcyA9IGZyYWdtZW50LmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHR0Ll9mbiA9IGNvbmZpZy5yZWdpc3RyaWVzLnRyYW5zaXRpb25zLmZpbmQoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIXQuX2ZuICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbWlzc2luZ1BsdWdpbicsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0cGx1Z2luOiAndHJhbnNpdGlvbicsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBsb2csIGNvbmZpZywgY2lyY3VsYXIgKTtcblxuXHQvKiB1dGlscy9jYW1lbENhc2UuanMgKi9cblx0dmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBoeXBoZW5hdGVkU3RyICkge1xuXHRcdHJldHVybiBoeXBoZW5hdGVkU3RyLnJlcGxhY2UoIC8tKFthLXpBLVpdKS9nLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL2hlbHBlcnMvcHJlZml4LmpzICovXG5cdHZhciBwcmVmaXggPSBmdW5jdGlvbiggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSApIHtcblxuXHRcdHZhciBwcmVmaXgsIHByZWZpeENhY2hlLCB0ZXN0U3R5bGU7XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRwcmVmaXggPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmVmaXhDYWNoZSA9IHt9O1xuXHRcdFx0dGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKS5zdHlsZTtcblx0XHRcdHByZWZpeCA9IGZ1bmN0aW9uKCBwcm9wICkge1xuXHRcdFx0XHR2YXIgaSwgdmVuZG9yLCBjYXBwZWQ7XG5cdFx0XHRcdHByb3AgPSBjYW1lbENhc2UoIHByb3AgKTtcblx0XHRcdFx0aWYgKCAhcHJlZml4Q2FjaGVbIHByb3AgXSApIHtcblx0XHRcdFx0XHRpZiAoIHRlc3RTdHlsZVsgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVsgcHJvcCBdID0gcHJvcDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gdGVzdCB2ZW5kb3JzLi4uXG5cdFx0XHRcdFx0XHRjYXBwZWQgPSBwcm9wLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXN0U3R5bGVbIHZlbmRvciArIGNhcHBlZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJlZml4Q2FjaGVbIHByb3AgXSA9IHZlbmRvciArIGNhcHBlZDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJlZml4Q2FjaGVbIHByb3AgXTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBwcmVmaXg7XG5cdH0oIGlzQ2xpZW50LCB2ZW5kb3JzLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvZ2V0U3R5bGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGdldFN0eWxlID0gZnVuY3Rpb24oIGxlZ2FjeSwgaXNDbGllbnQsIGlzQXJyYXksIHByZWZpeCApIHtcblxuXHRcdHZhciBnZXRTdHlsZSwgZ2V0Q29tcHV0ZWRTdHlsZTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGdldFN0eWxlID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXHRcdFx0Z2V0U3R5bGUgPSBmdW5jdGlvbiggcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBjb21wdXRlZFN0eWxlLCBzdHlsZXMsIGksIHByb3AsIHZhbHVlO1xuXHRcdFx0XHRjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5ub2RlICk7XG5cdFx0XHRcdGlmICggdHlwZW9mIHByb3BzID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcHMgKSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXNBcnJheSggcHJvcHMgKSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUcmFuc2l0aW9uJGdldFN0eWxlIG11c3QgYmUgcGFzc2VkIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBDU1MgcHJvcGVydGllcycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZXMgPSB7fTtcblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0cHJvcCA9IHByb3BzWyBpIF07XG5cdFx0XHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlWyBwcmVmaXgoIHByb3AgKSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHlsZXNbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdHlsZXM7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZ2V0U3R5bGU7XG5cdH0oIGxlZ2FjeSwgaXNDbGllbnQsIGlzQXJyYXksIHByZWZpeCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9zZXRTdHlsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc2V0U3R5bGUgPSBmdW5jdGlvbiggcHJlZml4ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHlsZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcHJvcDtcblx0XHRcdGlmICggdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0dGhpcy5ub2RlLnN0eWxlWyBwcmVmaXgoIHN0eWxlICkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBzdHlsZSApIHtcblx0XHRcdFx0XHRpZiAoIHN0eWxlLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSBzdHlsZVsgcHJvcCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSggcHJlZml4ICk7XG5cblx0Lyogc2hhcmVkL1RpY2tlci5qcyAqL1xuXHR2YXIgVGlja2VyID0gZnVuY3Rpb24oIHdhcm4sIGdldFRpbWUsIGFuaW1hdGlvbnMgKSB7XG5cblx0XHQvLyBUT0RPIHdoYXQgaGFwcGVucyBpZiBhIHRyYW5zaXRpb24gaXMgYWJvcnRlZD9cblx0XHQvLyBUT0RPIHVzZSB0aGlzIHdpdGggQW5pbWF0aW9uIHRvIGRlZHVwZSBzb21lIGNvZGU/XG5cdFx0dmFyIFRpY2tlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGVhc2luZztcblx0XHRcdHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0dGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwO1xuXHRcdFx0dGhpcy5jb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHQvLyBlYXNpbmdcblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5yb290LmVhc2luZ1sgb3B0aW9ucy5lYXNpbmcgXTtcblx0XHRcdFx0aWYgKCAhZWFzaW5nICkge1xuXHRcdFx0XHRcdHdhcm4oICdNaXNzaW5nIGVhc2luZyBmdW5jdGlvbiAoXCInICsgb3B0aW9ucy5lYXNpbmcgKyAnXCIpLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gZnJvbSBbVE9ET10nICk7XG5cdFx0XHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmc7XG5cdFx0XHR0aGlzLnN0YXJ0ID0gZ2V0VGltZSgpO1xuXHRcdFx0dGhpcy5lbmQgPSB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0XHRhbmltYXRpb25zLmFkZCggdGhpcyApO1xuXHRcdH07XG5cdFx0VGlja2VyLnByb3RvdHlwZSA9IHtcblx0XHRcdHRpY2s6IGZ1bmN0aW9uKCBub3cgKSB7XG5cdFx0XHRcdHZhciBlbGFwc2VkLCBlYXNlZDtcblx0XHRcdFx0aWYgKCAhdGhpcy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG5vdyA+IHRoaXMuZW5kICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGVwKCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdGhpcy5jb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuY29tcGxldGUoIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsYXBzZWQgPSBub3cgLSB0aGlzLnN0YXJ0O1xuXHRcdFx0XHRlYXNlZCA9IHRoaXMuZWFzaW5nKCBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbiApO1xuXHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHR0aGlzLnN0ZXAoIGVhc2VkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hYm9ydCApIHtcblx0XHRcdFx0XHR0aGlzLmFib3J0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVGlja2VyO1xuXG5cdFx0ZnVuY3Rpb24gbGluZWFyKCB0ICkge1xuXHRcdFx0cmV0dXJuIHQ7XG5cdFx0fVxuXHR9KCB3YXJuLCBnZXRUaW1lLCBhbmltYXRpb25zICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vaGVscGVycy91bnByZWZpeC5qcyAqL1xuXHR2YXIgdW5wcmVmaXggPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciB1bnByZWZpeFBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXi0oPzonICsgdmVuZG9ycy5qb2luKCAnfCcgKSArICcpLScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHByb3AgKSB7XG5cdFx0XHRyZXR1cm4gcHJvcC5yZXBsYWNlKCB1bnByZWZpeFBhdHRlcm4sICcnICk7XG5cdFx0fTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL2hlbHBlcnMvaHlwaGVuYXRlLmpzICovXG5cdHZhciBoeXBoZW5hdGUgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciB2ZW5kb3JQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJ14oPzonICsgdmVuZG9ycy5qb2luKCAnfCcgKSArICcpKFtBLVpdKScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHZhciBoeXBoZW5hdGVkO1xuXHRcdFx0aWYgKCAhc3RyICkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZlbmRvclBhdHRlcm4udGVzdCggc3RyICkgKSB7XG5cdFx0XHRcdHN0ciA9ICctJyArIHN0cjtcblx0XHRcdH1cblx0XHRcdGh5cGhlbmF0ZWQgPSBzdHIucmVwbGFjZSggL1tBLVpdL2csIGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdFx0cmV0dXJuICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gaHlwaGVuYXRlZDtcblx0XHR9O1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2FuaW1hdGVTdHlsZS9jcmVhdGVUcmFuc2l0aW9ucy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIGlzQ2xpZW50LCB3YXJuLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UsIGludGVycG9sYXRlLCBUaWNrZXIsIHByZWZpeCwgdW5wcmVmaXgsIGh5cGhlbmF0ZSApIHtcblxuXHRcdHZhciBjcmVhdGVUcmFuc2l0aW9ucywgdGVzdFN0eWxlLCBUUkFOU0lUSU9OLCBUUkFOU0lUSU9ORU5ELCBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCwgVFJBTlNJVElPTl9EVVJBVElPTiwgVFJBTlNJVElPTl9QUk9QRVJUWSwgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04sIGNhblVzZUNzc1RyYW5zaXRpb25zID0ge30sXG5cdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9ucyA9IHt9O1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApLnN0eWxlO1xuXHRcdFx0Ly8gZGV0ZXJtaW5lIHNvbWUgZmFjdHMgYWJvdXQgb3VyIGVudmlyb25tZW50XG5cdFx0XHQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRlc3RTdHlsZS50cmFuc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0VFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcblx0XHRcdFx0XHRUUkFOU0lUSU9ORU5EID0gJ3RyYW5zaXRpb25lbmQnO1xuXHRcdFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggdGVzdFN0eWxlLndlYmtpdFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRUUkFOU0lUSU9OID0gJ3dlYmtpdFRyYW5zaXRpb24nO1xuXHRcdFx0XHRcdFRSQU5TSVRJT05FTkQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG5cdFx0XHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0oKSApO1xuXHRcdFx0aWYgKCBUUkFOU0lUSU9OICkge1xuXHRcdFx0XHRUUkFOU0lUSU9OX0RVUkFUSU9OID0gVFJBTlNJVElPTiArICdEdXJhdGlvbic7XG5cdFx0XHRcdFRSQU5TSVRJT05fUFJPUEVSVFkgPSBUUkFOU0lUSU9OICsgJ1Byb3BlcnR5Jztcblx0XHRcdFx0VFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04gPSBUUkFOU0lUSU9OICsgJ1RpbWluZ0Z1bmN0aW9uJztcblx0XHRcdH1cblx0XHRcdGNyZWF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIHQsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgcmVzb2x2ZSApIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJlYXQgKG90aGVyd2lzZSB0aGUgdGFyZ2V0IHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgaW1tZWRpYXRlbHkpXG5cdFx0XHRcdC8vIFRPRE8gdXNlIGEgZmFzdGRvbS1zdHlsZSBtZWNoYW5pc20/XG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBoYXNoUHJlZml4LCBqc1RyYW5zaXRpb25zQ29tcGxldGUsIGNzc1RyYW5zaXRpb25zQ29tcGxldGUsIGNoZWNrQ29tcGxldGUsIHRyYW5zaXRpb25FbmRIYW5kbGVyO1xuXHRcdFx0XHRcdGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICgganNUcmFuc2l0aW9uc0NvbXBsZXRlICYmIGNzc1RyYW5zaXRpb25zQ29tcGxldGUgKSB7XG5cdFx0XHRcdFx0XHRcdHQucm9vdC5maXJlKCB0Lm5hbWUgKyAnOmVuZCcsIHQubm9kZSwgdC5pc0ludHJvICk7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdC8vIHRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGVsZW1lbnRzIGNhbiB1c2UgQ1NTIHRvIGFuaW1hdGVcblx0XHRcdFx0XHQvLyB3aGljaCBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0aGFzaFByZWZpeCA9ICggdC5ub2RlLm5hbWVzcGFjZVVSSSB8fCAnJyApICsgdC5ub2RlLnRhZ05hbWU7XG5cdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBUUkFOU0lUSU9OX1BST1BFUlRZIF0gPSBjaGFuZ2VkUHJvcGVydGllcy5tYXAoIHByZWZpeCApLm1hcCggaHlwaGVuYXRlICkuam9pbiggJywnICk7XG5cdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiBdID0gaHlwaGVuYXRlKCBvcHRpb25zLmVhc2luZyB8fCAnbGluZWFyJyApO1xuXHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgVFJBTlNJVElPTl9EVVJBVElPTiBdID0gb3B0aW9ucy5kdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoIGNhbWVsQ2FzZSggdW5wcmVmaXgoIGV2ZW50LnByb3BlcnR5TmFtZSApICkgKTtcblx0XHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gc3RpbGwgdHJhbnNpdGlvbmluZy4uLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHQubm9kZS5hZGRFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBpID0gY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRoYXNoLCBvcmlnaW5hbFZhbHVlLCBpbmRleCwgcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMgPSBbXSxcblx0XHRcdFx0XHRcdFx0cHJvcCwgc3VmZml4O1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdHByb3AgPSBjaGFuZ2VkUHJvcGVydGllc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRoYXNoID0gaGFzaFByZWZpeCArIHByb3A7XG5cdFx0XHRcdFx0XHRcdGlmICggQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgJiYgIWNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gdG9bIHByb3AgXTtcblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3Qgc3VyZSBpZiBDU1MgdHJhbnNpdGlvbnMgYXJlIHN1cHBvcnRlZCBmb3Jcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIHRhZy9wcm9wZXJ0eSBjb21ibywgZmluZCBvdXQgbm93XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhY2FuVXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBpZiB0aGlzIHByb3BlcnR5IGlzIHRyYW5zaXRpb25hYmxlIGluIHRoaXMgYnJvd3Nlcixcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IHN0eWxlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHRhcmdldCBzdHlsZVxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FuVXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSA9IHQuZ2V0U3R5bGUoIHByb3AgKSAhPSB0b1sgcHJvcCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSA9ICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmVzZXQsIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSB0aW1lcnMgYWZ0ZXIgYWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IG9yaWdpbmFsVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICggIUNTU19UUkFOU0lUSU9OU19FTkFCTEVEIHx8IGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGltZXItYmFzZWQgc3R1ZmZcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG9yaWdpbmFsVmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIG5lZWQgdG8gcmVtb3ZlIHRoaXMgZnJvbSBjaGFuZ2VkUHJvcGVydGllcywgb3RoZXJ3aXNlIHRyYW5zaXRpb25FbmRIYW5kbGVyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2lsbCBnZXQgY29uZnVzZWRcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdhcm4oICdTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkIHdpdGggdHJhbnNpdGlvbnMuIElmIHlvdSBzZWUgdGhpcyBtZXNzYWdlLCBwbGVhc2UgbGV0IEBSYWN0aXZlSlMga25vdy4gVGhhbmtzIScgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPIERldGVybWluZSB3aGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgYW5pbWF0YWJsZSBhdCBhbGxcblx0XHRcdFx0XHRcdFx0XHRzdWZmaXggPSAvW15cXGRdKiQvLmV4ZWMoIHRvWyBwcm9wIF0gKVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLnRoZW4ga2ljayBvZmYgYSB0aW1lci1iYXNlZCB0cmFuc2l0aW9uXG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZTogcHJlZml4KCBwcm9wICksXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3I6IGludGVycG9sYXRlKCBwYXJzZUZsb2F0KCBvcmlnaW5hbFZhbHVlICksIHBhcnNlRmxvYXQoIHRvWyBwcm9wIF0gKSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0c3VmZml4OiBzdWZmaXhcblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGphdmFzY3JpcHQgdHJhbnNpdGlvbnNcblx0XHRcdFx0XHRcdGlmICggcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRuZXcgVGlja2VyKCB7XG5cdFx0XHRcdFx0XHRcdFx0cm9vdDogdC5yb290LFxuXHRcdFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdGVhc2luZzogY2FtZWxDYXNlKCBvcHRpb25zLmVhc2luZyB8fCAnJyApLFxuXHRcdFx0XHRcdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcHJvcCwgaTtcblx0XHRcdFx0XHRcdFx0XHRcdGkgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzWyBpIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wLmludGVycG9sYXRvciggcG9zICkgKyBwcm9wLnN1ZmZpeDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRqc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGFuZCBkZWFsIHdpdGhcblx0XHRcdFx0XHRcdFx0Ly8gdGhlIGZhY3QgdGhhdCBpdCB3aWxsIG5ldmVyIGZpcmVcblx0XHRcdFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDAgKTtcblx0XHRcdFx0fSwgb3B0aW9ucy5kZWxheSB8fCAwICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlVHJhbnNpdGlvbnM7XG5cdH0oIGlzQ2xpZW50LCB3YXJuLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UsIGludGVycG9sYXRlLCBUaWNrZXIsIHByZWZpeCwgdW5wcmVmaXgsIGh5cGhlbmF0ZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9hbmltYXRlU3R5bGUvdmlzaWJpbGl0eS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciBoaWRkZW4sIHZlbmRvciwgcHJlZml4LCBpLCB2aXNpYmlsaXR5O1xuXHRcdGlmICggdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdGhpZGRlbiA9ICdoaWRkZW4nO1xuXHRcdFx0dmlzaWJpbGl0eSA9IHt9O1xuXHRcdFx0aWYgKCBoaWRkZW4gaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdHByZWZpeCA9ICcnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHR2ZW5kb3IgPSB2ZW5kb3JzWyBpIF07XG5cdFx0XHRcdFx0aGlkZGVuID0gdmVuZG9yICsgJ0hpZGRlbic7XG5cdFx0XHRcdFx0aWYgKCBoaWRkZW4gaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXggPSB2ZW5kb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHByZWZpeCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBwcmVmaXggKyAndmlzaWJpbGl0eWNoYW5nZScsIG9uQ2hhbmdlICk7XG5cdFx0XHRcdC8vIGluaXRpYWxpc2Vcblx0XHRcdFx0b25DaGFuZ2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGdhaCwgd2UncmUgaW4gYW4gb2xkIGJyb3dzZXJcblx0XHRcdFx0aWYgKCAnb25mb2N1c291dCcgaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3Vzb3V0Jywgb25IaWRlICk7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3VzaW4nLCBvblNob3cgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3BhZ2VoaWRlJywgb25IaWRlICk7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgb25IaWRlICk7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdwYWdlc2hvdycsIG9uU2hvdyApO1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCBvblNob3cgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuXHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBkb2N1bWVudFsgaGlkZGVuIF07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25IaWRlKCkge1xuXHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uU2hvdygpIHtcblx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB2aXNpYmlsaXR5O1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2FuaW1hdGVTdHlsZS9fYW5pbWF0ZVN0eWxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfX2FuaW1hdGVTdHlsZSA9IGZ1bmN0aW9uKCBsZWdhY3ksIGlzQ2xpZW50LCB3YXJuLCBQcm9taXNlLCBwcmVmaXgsIGNyZWF0ZVRyYW5zaXRpb25zLCB2aXNpYmlsaXR5ICkge1xuXG5cdFx0dmFyIGFuaW1hdGVTdHlsZSwgZ2V0Q29tcHV0ZWRTdHlsZSwgcmVzb2x2ZWQ7XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRhbmltYXRlU3R5bGUgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cdFx0XHRhbmltYXRlU3R5bGUgPSBmdW5jdGlvbiggc3R5bGUsIHZhbHVlLCBvcHRpb25zLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRcdHRvO1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBwYWdlIGlzbid0IHZpc2libGUuIERvbid0IGFuaW1hdGUgYW55dGhpbmcsIGJlY2F1c2Vcblx0XHRcdFx0Ly8gdGhhdCB3YXkgeW91J2xsIG5ldmVyIGdldCBDU1MgdHJhbnNpdGlvbmVuZCBldmVudHNcblx0XHRcdFx0aWYgKCB2aXNpYmlsaXR5LmhpZGRlbiApIHtcblx0XHRcdFx0XHR0aGlzLnNldFN0eWxlKCBzdHlsZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZWQgfHwgKCByZXNvbHZlZCA9IFByb21pc2UucmVzb2x2ZSgpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHRvID0ge307XG5cdFx0XHRcdFx0dG9bIHN0eWxlIF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0byA9IHN0eWxlO1xuXHRcdFx0XHRcdC8vIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0XHRcdFx0Y29tcGxldGUgPSBvcHRpb25zO1xuXHRcdFx0XHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBcyBvZiAwLjMuOSwgdHJhbnNpdGlvbiBhdXRob3JzIHNob3VsZCBzdXBwbHkgYW4gYG9wdGlvbmAgb2JqZWN0IHdpdGhcblx0XHRcdFx0Ly8gYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllcyAoYW5kIG9wdGlvbmFsIGBkZWxheWApLCBwbHVzIGFcblx0XHRcdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlc1xuXHRcdFx0XHQvLyBUT0RPIHJlbW92ZSB0aGlzIGNoZWNrIGluIGEgZnV0dXJlIHZlcnNpb25cblx0XHRcdFx0aWYgKCAhb3B0aW9ucyApIHtcblx0XHRcdFx0XHR3YXJuKCAnVGhlIFwiJyArIHQubmFtZSArICdcIiB0cmFuc2l0aW9uIGRvZXMgbm90IHN1cHBseSBhbiBvcHRpb25zIG9iamVjdCB0byBgdC5hbmltYXRlU3R5bGUoKWAuIFRoaXMgd2lsbCBicmVhayBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUuIEZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMvMzQwJyApO1xuXHRcdFx0XHRcdG9wdGlvbnMgPSB0O1xuXHRcdFx0XHRcdGNvbXBsZXRlID0gdC5jb21wbGV0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggcmVzb2x2ZSApIHtcblx0XHRcdFx0XHR2YXIgcHJvcGVydHlOYW1lcywgY2hhbmdlZFByb3BlcnRpZXMsIGNvbXB1dGVkU3R5bGUsIGN1cnJlbnQsIGZyb20sIGksIHByb3A7XG5cdFx0XHRcdFx0Ly8gRWRnZSBjYXNlIC0gaWYgZHVyYXRpb24gaXMgemVybywgc2V0IHN0eWxlIHN5bmNocm9ub3VzbHkgYW5kIGNvbXBsZXRlXG5cdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdFx0XHRcdHQuc2V0U3R5bGUoIHRvICk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEdldCBhIGxpc3Qgb2YgdGhlIHByb3BlcnRpZXMgd2UncmUgYW5pbWF0aW5nXG5cdFx0XHRcdFx0cHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKCB0byApO1xuXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzID0gW107XG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGN1cnJlbnQgc3R5bGVzXG5cdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIHQubm9kZSApO1xuXHRcdFx0XHRcdGZyb20gPSB7fTtcblx0XHRcdFx0XHRpID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydHlOYW1lc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y3VycmVudCA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcCApIF07XG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnQgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8ga25vdyBpZiB3ZSdyZSBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZ1xuXHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50ICE9IHRvWyBwcm9wIF0gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSAhPSBpbnN0ZWFkIG9mICE9PSwgc28gd2UgY2FuIGNvbXBhcmUgc3RyaW5ncyB3aXRoIG51bWJlcnNcblx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMucHVzaCggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHQvLyBtYWtlIHRoZSBjb21wdXRlZCBzdHlsZSBleHBsaWNpdCwgc28gd2UgY2FuIGFuaW1hdGUgd2hlcmVcblx0XHRcdFx0XHRcdFx0Ly8gZS5nLiBoZWlnaHQ9J2F1dG8nXG5cdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZywgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnRcblx0XHRcdFx0XHQvLyB3aWxsIG5ldmVyIGZpcmUhIFNvIHdlIGNvbXBsZXRlIGVhcmx5XG5cdFx0XHRcdFx0aWYgKCAhY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjcmVhdGVUcmFuc2l0aW9ucyggdCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0Ly8gSWYgYSBjYWxsYmFjayB3YXMgc3VwcGxpZWQsIGRvIHRoZSBob25vdXJzXG5cdFx0XHRcdC8vIFRPRE8gcmVtb3ZlIHRoaXMgY2hlY2sgaW4gZnV0dXJlXG5cdFx0XHRcdGlmICggY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0d2FybiggJ3QuYW5pbWF0ZVN0eWxlIHJldHVybnMgYSBQcm9taXNlIGFzIG9mIDAuNC4wLiBUcmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIGRvIHQuYW5pbWF0ZVN0eWxlKC4uLikudGhlbihjYWxsYmFjayknICk7XG5cdFx0XHRcdFx0cHJvbWlzZS50aGVuKCBjb21wbGV0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGFuaW1hdGVTdHlsZTtcblx0fSggbGVnYWN5LCBpc0NsaWVudCwgd2FybiwgUHJvbWlzZSwgcHJlZml4LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5ICk7XG5cblx0LyogdXRpbHMvZmlsbEdhcHMuanMgKi9cblx0dmFyIGZpbGxHYXBzID0gZnVuY3Rpb24oIHRhcmdldCwgc291cmNlICkge1xuXHRcdHZhciBrZXk7XG5cdFx0Zm9yICgga2V5IGluIHNvdXJjZSApIHtcblx0XHRcdGlmICggc291cmNlLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiAhKCBrZXkgaW4gdGFyZ2V0ICkgKSB7XG5cdFx0XHRcdHRhcmdldFsga2V5IF0gPSBzb3VyY2VbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9wcm9jZXNzUGFyYW1zLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRwcm9jZXNzUGFyYW1zID0gZnVuY3Rpb24oIGZpbGxHYXBzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJhbXMsIGRlZmF1bHRzICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFyYW1zID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiBwYXJhbXNcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRpZiAoIHBhcmFtcyA9PT0gJ3Nsb3cnICkge1xuXHRcdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiA2MDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJhbXMgPT09ICdmYXN0JyApIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogMjAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogNDAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggIXBhcmFtcyApIHtcblx0XHRcdFx0cGFyYW1zID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmlsbEdhcHMoIHBhcmFtcywgZGVmYXVsdHMgKTtcblx0XHR9O1xuXHR9KCBmaWxsR2FwcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9zdGFydC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc3RhcnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmFuc2l0aW9uJHN0YXJ0KCkge1xuXHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRub2RlLCBvcmlnaW5hbFN0eWxlO1xuXHRcdFx0bm9kZSA9IHQubm9kZSA9IHQuZWxlbWVudC5ub2RlO1xuXHRcdFx0b3JpZ2luYWxTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHQvLyBjcmVhdGUgdC5jb21wbGV0ZSgpIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIG9uIHRoZSBwcm90b3R5cGUsXG5cdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYHRoaXNgIHNpbGxpbmVzcyB3aGVuIHBhc3NpbmcgaXQgYXNcblx0XHRcdC8vIGFuIGFyZ3VtZW50XG5cdFx0XHR0LmNvbXBsZXRlID0gZnVuY3Rpb24oIG5vUmVzZXQgKSB7XG5cdFx0XHRcdGlmICggIW5vUmVzZXQgJiYgdC5pc0ludHJvICkge1xuXHRcdFx0XHRcdHJlc2V0U3R5bGUoIG5vZGUsIG9yaWdpbmFsU3R5bGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLl9yYWN0aXZlLnRyYW5zaXRpb24gPSBudWxsO1xuXHRcdFx0XHR0Ll9tYW5hZ2VyLnJlbW92ZSggdCApO1xuXHRcdFx0fTtcblx0XHRcdC8vIElmIHRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGRvZXNuJ3QgZXhpc3QsIGFib3J0XG5cdFx0XHRpZiAoICF0Ll9mbiApIHtcblx0XHRcdFx0dC5jb21wbGV0ZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0Ll9mbi5hcHBseSggdC5yb290LCBbIHQgXS5jb25jYXQoIHQucGFyYW1zICkgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRTdHlsZSggbm9kZSwgc3R5bGUgKSB7XG5cdFx0XHRpZiAoIHN0eWxlICkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgc3R5bGUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE5leHQgbGluZSBpcyBuZWNlc3NhcnksIHRvIHJlbW92ZSBlbXB0eSBzdHlsZSBhdHRyaWJ1dGUhXG5cdFx0XHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTY3NTUzXG5cdFx0XHRcdG5vZGUuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vX1RyYW5zaXRpb24uanMgKi9cblx0dmFyIFRyYW5zaXRpb24gPSBmdW5jdGlvbiggaW5pdCwgZ2V0U3R5bGUsIHNldFN0eWxlLCBhbmltYXRlU3R5bGUsIHByb2Nlc3NQYXJhbXMsIHN0YXJ0LCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgVHJhbnNpdGlvbjtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdFRyYW5zaXRpb24gPSBmdW5jdGlvbiggb3duZXIsIHRlbXBsYXRlLCBpc0ludHJvICkge1xuXHRcdFx0dGhpcy5pbml0KCBvd25lciwgdGVtcGxhdGUsIGlzSW50cm8gKTtcblx0XHR9O1xuXHRcdFRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGdldFN0eWxlOiBnZXRTdHlsZSxcblx0XHRcdHNldFN0eWxlOiBzZXRTdHlsZSxcblx0XHRcdGFuaW1hdGVTdHlsZTogYW5pbWF0ZVN0eWxlLFxuXHRcdFx0cHJvY2Vzc1BhcmFtczogcHJvY2Vzc1BhcmFtc1xuXHRcdH07XG5cdFx0cmV0dXJuIFRyYW5zaXRpb247XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGdldFN0eWxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzZXRTdHlsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX19hbmltYXRlU3R5bGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHByb2Nlc3NQYXJhbXMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHN0YXJ0LCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmVuZGVyID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGlzQXJyYXksIHdhcm4sIGNyZWF0ZSwgY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIG5vb3AsIHJ1bmxvb3AsIGdldElubmVyQ29udGV4dCwgcmVuZGVySW1hZ2UsIFRyYW5zaXRpb24gKSB7XG5cblx0XHR2YXIgdXBkYXRlQ3NzLCB1cGRhdGVTY3JpcHQ7XG5cdFx0dXBkYXRlQ3NzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdFx0Y29udGVudCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGZhbHNlICk7XG5cdFx0XHRpZiAoIG5vZGUuc3R5bGVTaGVldCApIHtcblx0XHRcdFx0bm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb250ZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCBub2RlLmhhc0NoaWxkTm9kZXMoKSApIHtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKCBub2RlLmZpcnN0Q2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggY29udGVudCApICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR1cGRhdGVTY3JpcHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMubm9kZS50eXBlIHx8IHRoaXMubm9kZS50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0JyApIHtcblx0XHRcdFx0d2FybiggJ1NjcmlwdCB0YWcgd2FzIHVwZGF0ZWQuIFRoaXMgZG9lcyBub3QgY2F1c2UgdGhlIGNvZGUgdG8gYmUgcmUtZXZhbHVhdGVkIScgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZmFsc2UgKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBFbGVtZW50JHJlbmRlcigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHJvb3QgPSB0aGlzLnJvb3QsXG5cdFx0XHRcdG5hbWVzcGFjZSwgbm9kZTtcblx0XHRcdG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSggdGhpcyApO1xuXHRcdFx0bm9kZSA9IHRoaXMubm9kZSA9IGNyZWF0ZUVsZW1lbnQoIHRoaXMubmFtZSwgbmFtZXNwYWNlICk7XG5cdFx0XHQvLyBJcyB0aGlzIGEgdG9wLWxldmVsIG5vZGUgb2YgYSBjb21wb25lbnQ/IElmIHNvLCB3ZSBtYXkgbmVlZCB0byBhZGRcblx0XHRcdC8vIGEgZGF0YS1ydmNndWlkIGF0dHJpYnV0ZSwgZm9yIENTUyBlbmNhcHN1bGF0aW9uXG5cdFx0XHQvLyBOT1RFOiBjc3Mgbm8gbG9uZ2VyIGNvcGllZCB0byBpbnN0YW5jZSwgc28gd2UgY2hlY2sgY29uc3RydWN0b3IuY3NzIC1cblx0XHRcdC8vIHdlIGNhbiBlbmhhbmNlIHRvIGhhbmRsZSBpbnN0YW5jZSwgYnV0IHRoaXMgaXMgbW9yZSBcImNvcnJlY3RcIiB3aXRoIGN1cnJlbnRcblx0XHRcdC8vIGZ1bmN0aW9uYWxpdHlcblx0XHRcdGlmICggcm9vdC5jb25zdHJ1Y3Rvci5jc3MgJiYgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkgPT09IHJvb3QuZWwgKSB7XG5cdFx0XHRcdHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoICdkYXRhLXJ2Y2d1aWQnLCByb290LmNvbnN0cnVjdG9yLl9ndWlkICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgX3JhY3RpdmUgcHJvcGVydHkgdG8gdGhlIG5vZGUgLSB3ZSB1c2UgdGhpcyBvYmplY3QgdG8gc3RvcmUgc3R1ZmZcblx0XHRcdC8vIHJlbGF0ZWQgdG8gcHJveHkgZXZlbnRzLCB0d28td2F5IGJpbmRpbmdzIGV0Y1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIHRoaXMubm9kZSwgJ19yYWN0aXZlJywge1xuXHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdHByb3h5OiB0aGlzLFxuXHRcdFx0XHRcdGtleXBhdGg6IGdldElubmVyQ29udGV4dCggdGhpcy5wYXJlbnRGcmFnbWVudCApLFxuXHRcdFx0XHRcdGluZGV4OiB0aGlzLnBhcmVudEZyYWdtZW50LmluZGV4UmVmcyxcblx0XHRcdFx0XHRldmVudHM6IGNyZWF0ZSggbnVsbCApLFxuXHRcdFx0XHRcdHJvb3Q6IHJvb3Rcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gUmVuZGVyIGF0dHJpYnV0ZXNcblx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0cmV0dXJuIGEucmVuZGVyKCBub2RlICk7XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBSZW5kZXIgY2hpbGRyZW5cblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNjcmlwdD4gZWxlbWVudFxuXHRcdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3NjcmlwdCcgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVTY3JpcHQ7XG5cdFx0XHRcdFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBmYWxzZSApO1xuXHRcdFx0XHRcdC8vIGJ5cGFzcyB3YXJuaW5nIGluaXRpYWxseVxuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm5hbWUgPT09ICdzdHlsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVDc3M7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5iaW5kaW5nICYmIHRoaXMuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMubm9kZS5hcHBlbmRDaGlsZCggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgcHJveHkgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggZnVuY3Rpb24oIGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGgucmVuZGVyKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIGRlYWwgd2l0aCB0d28td2F5IGJpbmRpbmdzXG5cdFx0XHRpZiAoIHRoaXMuYmluZGluZyApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nLnJlbmRlcigpO1xuXHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IHRoaXMuYmluZGluZztcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZTogaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXlcblx0XHRcdC8vIG5lZWQgdG8gcHJldmVudCBpdCBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuIGl0IGxvYWRzIHRoZSBzcmNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnaW1nJyApIHtcblx0XHRcdFx0cmVuZGVySW1hZ2UoIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdC8vIGFwcGx5IGRlY29yYXRvcihzKVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciAmJiB0aGlzLmRlY29yYXRvci5mbiApIHtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMkMC5kZWNvcmF0b3IuaW5pdCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyB0cmlnZ2VyIGludHJvIHRyYW5zaXRpb25cblx0XHRcdGlmICggcm9vdC50cmFuc2l0aW9uc0VuYWJsZWQgJiYgdGhpcy5pbnRybyApIHtcblx0XHRcdFx0dmFyIHRyYW5zaXRpb24gPSBuZXcgVHJhbnNpdGlvbiggdGhpcywgdGhpcy5pbnRybywgdHJ1ZSApO1xuXHRcdFx0XHRydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbiggdHJhbnNpdGlvbiApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICkge1xuXHRcdFx0XHRwcm9jZXNzT3B0aW9uKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubm9kZS5hdXRvZm9jdXMgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZS4gU29tZSBicm93c2VycyAoKmNvdWdoKiBGaXJlZml4ICpjb3VnaCopIGhhdmUgYSBwcm9ibGVtXG5cdFx0XHRcdC8vIHdpdGggZHluYW1pY2FsbHktZ2VuZXJhdGVkIGVsZW1lbnRzIGhhdmluZyBhdXRvZm9jdXMsIGFuZCB0aGV5IHdvbid0XG5cdFx0XHRcdC8vIGFsbG93IHlvdSB0byBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzIHRoZSBlbGVtZW50IHVudGlsIGl0J3MgaW4gdGhlIERPTVxuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5ub2RlLmZvY3VzKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXROYW1lc3BhY2UoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgbmFtZXNwYWNlLCB4bWxucywgcGFyZW50O1xuXHRcdFx0Ly8gVXNlIHNwZWNpZmllZCBuYW1lc3BhY2UuLi5cblx0XHRcdGlmICggeG1sbnMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3htbG5zJyApICkge1xuXHRcdFx0XHRuYW1lc3BhY2UgPSB4bWxucztcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3N2ZycgKSB7XG5cdFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuc3ZnO1xuXHRcdFx0fSBlbHNlIGlmICggcGFyZW50ID0gZWxlbWVudC5wYXJlbnQgKSB7XG5cdFx0XHRcdC8vIC4uLm9yIEhUTUwsIGlmIHRoZSBwYXJlbnQgaXMgYSA8Zm9yZWlnbk9iamVjdD5cblx0XHRcdFx0aWYgKCBwYXJlbnQubmFtZSA9PT0gJ2ZvcmVpZ25PYmplY3QnICkge1xuXHRcdFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuaHRtbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuYW1lc3BhY2UgPSBwYXJlbnQubm9kZS5uYW1lc3BhY2VVUkk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5hbWVzcGFjZSA9IGVsZW1lbnQucm9vdC5lbC5uYW1lc3BhY2VVUkk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmFtZXNwYWNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NPcHRpb24oIG9wdGlvbiApIHtcblx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cdFx0XHRzZWxlY3RWYWx1ZSA9IG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIHNlbGVjdFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0Lm5vZGUubXVsdGlwbGUgJiYgaXNBcnJheSggc2VsZWN0VmFsdWUgKSApIHtcblx0XHRcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZVsgaSBdICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZUxpdmVRdWVyaWVzKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGluc3RhbmNlLCBsaXZlUXVlcmllcywgaSwgc2VsZWN0b3IsIHF1ZXJ5O1xuXHRcdFx0Ly8gRG9lcyB0aGlzIG5lZWQgdG8gYmUgYWRkZWQgdG8gYW55IGxpdmUgcXVlcmllcz9cblx0XHRcdGluc3RhbmNlID0gZWxlbWVudC5yb290O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRsaXZlUXVlcmllcyA9IGluc3RhbmNlLl9saXZlUXVlcmllcztcblx0XHRcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBsaXZlUXVlcmllc1sgaSBdO1xuXHRcdFx0XHRcdHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbICdfJyArIHNlbGVjdG9yIF07XG5cdFx0XHRcdFx0aWYgKCBxdWVyeS5fdGVzdCggZWxlbWVudCApICkge1xuXHRcdFx0XHRcdFx0Ly8ga2VlcCByZWdpc3RlciBvZiBhcHBsaWNhYmxlIHNlbGVjdG9ycywgZm9yIHdoZW4gd2UgdGVhcmRvd25cblx0XHRcdFx0XHRcdCggZWxlbWVudC5saXZlUXVlcmllcyB8fCAoIGVsZW1lbnQubGl2ZVF1ZXJpZXMgPSBbXSApICkucHVzaCggcXVlcnkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCBpbnN0YW5jZSA9IGluc3RhbmNlLl9wYXJlbnQgKTtcblx0XHR9XG5cdH0oIG5hbWVzcGFjZXMsIGlzQXJyYXksIHdhcm4sIGNyZWF0ZSwgY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIG5vb3AsIHJ1bmxvb3AsIGdldElubmVyQ29udGV4dCwgcmVuZGVyLCBUcmFuc2l0aW9uICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHRvU3RyaW5nID0gZnVuY3Rpb24oIHZvaWRFbGVtZW50TmFtZXMsIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc3RyLCBlc2NhcGU7XG5cdFx0XHRzdHIgPSAnPCcgKyAoIHRoaXMudGVtcGxhdGUueSA/ICchRE9DVFlQRScgOiB0aGlzLnRlbXBsYXRlLmUgKTtcblx0XHRcdHN0ciArPSB0aGlzLmF0dHJpYnV0ZXMubWFwKCBzdHJpbmdpZnlBdHRyaWJ1dGUgKS5qb2luKCAnJyApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICYmIG9wdGlvbklzU2VsZWN0ZWQoIHRoaXMgKSApIHtcblx0XHRcdFx0c3RyICs9ICcgc2VsZWN0ZWQnO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gdHdvLXdheSByYWRpbyBuYW1lIGJpbmRpbmdzXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2lucHV0JyAmJiBpbnB1dElzQ2hlY2tlZFJhZGlvKCB0aGlzICkgKSB7XG5cdFx0XHRcdHN0ciArPSAnIGNoZWNrZWQnO1xuXHRcdFx0fVxuXHRcdFx0c3RyICs9ICc+Jztcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0ZXNjYXBlID0gdGhpcy5uYW1lICE9PSAnc2NyaXB0JyAmJiB0aGlzLm5hbWUgIT09ICdzdHlsZSc7XG5cdFx0XHRcdHN0ciArPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBlc2NhcGUgKTtcblx0XHRcdH1cblx0XHRcdC8vIGFkZCBhIGNsb3NpbmcgdGFnIGlmIHRoaXMgaXNuJ3QgYSB2b2lkIGVsZW1lbnRcblx0XHRcdGlmICggIXZvaWRFbGVtZW50TmFtZXMudGVzdCggdGhpcy50ZW1wbGF0ZS5lICkgKSB7XG5cdFx0XHRcdHN0ciArPSAnPC8nICsgdGhpcy50ZW1wbGF0ZS5lICsgJz4nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gb3B0aW9uSXNTZWxlY3RlZCggZWxlbWVudCApIHtcblx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cdFx0XHRvcHRpb25WYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHNlbGVjdFZhbHVlID0gZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgJiYgaXNBcnJheSggc2VsZWN0VmFsdWUgKSApIHtcblx0XHRcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3RWYWx1ZVsgaSBdID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5wdXRJc0NoZWNrZWRSYWRpbyggZWxlbWVudCApIHtcblx0XHRcdHZhciBhdHRyaWJ1dGVzLCB0eXBlQXR0cmlidXRlLCB2YWx1ZUF0dHJpYnV0ZSwgbmFtZUF0dHJpYnV0ZTtcblx0XHRcdGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cdFx0XHR0eXBlQXR0cmlidXRlID0gYXR0cmlidXRlcy50eXBlO1xuXHRcdFx0dmFsdWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnZhbHVlO1xuXHRcdFx0bmFtZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMubmFtZTtcblx0XHRcdGlmICggIXR5cGVBdHRyaWJ1dGUgfHwgdHlwZUF0dHJpYnV0ZS52YWx1ZSAhPT0gJ3JhZGlvJyB8fCAhdmFsdWVBdHRyaWJ1dGUgfHwgIW5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlQXR0cmlidXRlLnZhbHVlID09PSBuYW1lQXR0cmlidXRlLmludGVycG9sYXRvci52YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RyaW5naWZ5QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHR2YXIgc3RyID0gYXR0cmlidXRlLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gc3RyID8gJyAnICsgc3RyIDogJyc7XG5cdFx0fVxuXHR9KCB2b2lkRWxlbWVudE5hbWVzLCBpc0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X3NwZWNpYWxfb3B0aW9uX3VuYmluZCA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5iaW5kT3B0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRyZW1vdmVGcm9tQXJyYXkoIG9wdGlvbi5zZWxlY3Qub3B0aW9ucywgb3B0aW9uICk7XG5cdFx0fTtcblx0fSggcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bmJpbmQgPSBmdW5jdGlvbiggdW5iaW5kT3B0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkdW5iaW5kKCkge1xuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZy51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+XG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdHVuYmluZE9wdGlvbiggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIHVuYmluZEF0dHJpYnV0ZSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmRBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblx0XHRcdGF0dHJpYnV0ZS51bmJpbmQoKTtcblx0XHR9XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9zcGVjaWFsX29wdGlvbl91bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdW5yZW5kZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgVHJhbnNpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBFbGVtZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0dmFyIGJpbmRpbmcsIGJpbmRpbmdzO1xuXHRcdFx0Ly8gRGV0YWNoIGFzIHNvb24gYXMgd2UgY2FuXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdC8vIDxvcHRpb24+IGVsZW1lbnRzIGRldGFjaCBpbW1lZGlhdGVseSwgc28gdGhhdFxuXHRcdFx0XHQvLyB0aGVpciBwYXJlbnQgPHNlbGVjdD4gZWxlbWVudCBzeW5jcyBjb3JyZWN0bHksIGFuZFxuXHRcdFx0XHQvLyBzaW5jZSBvcHRpb24gZWxlbWVudHMgY2FuJ3QgaGF2ZSB0cmFuc2l0aW9ucyBhbnl3YXlcblx0XHRcdFx0dGhpcy5kZXRhY2goKTtcblx0XHRcdH0gZWxzZSBpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHJ1bmxvb3AuZGV0YWNoV2hlblJlYWR5KCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDaGlsZHJlbiBmaXJzdC4gdGhhdCB3YXksIGFueSB0cmFuc2l0aW9ucyBvbiBjaGlsZCBlbGVtZW50cyB3aWxsIGJlXG5cdFx0XHQvLyBoYW5kbGVkIGJ5IHRoZSBjdXJyZW50IHRyYW5zaXRpb25NYW5hZ2VyXG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZy51bnJlbmRlcigpO1xuXHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IG51bGw7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgYmluZGluZy5rZXlwYXRoIF07XG5cdFx0XHRcdGJpbmRpbmdzLnNwbGljZSggYmluZGluZ3MuaW5kZXhPZiggYmluZGluZyApLCAxICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggZnVuY3Rpb24oIGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGgudW5yZW5kZXIoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciApIHtcblx0XHRcdFx0dGhpcy5kZWNvcmF0b3IudGVhcmRvd24oKTtcblx0XHRcdH1cblx0XHRcdC8vIHRyaWdnZXIgb3V0cm8gdHJhbnNpdGlvbiBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmICggdGhpcy5yb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLm91dHJvICkge1xuXHRcdFx0XHR2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKCB0aGlzLCB0aGlzLm91dHJvLCBmYWxzZSApO1xuXHRcdFx0XHRydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbiggdHJhbnNpdGlvbiApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIHRoaXMgbm9kZSBmcm9tIGFueSBsaXZlIHF1ZXJpZXNcblx0XHRcdGlmICggdGhpcy5saXZlUXVlcmllcyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlUXVlcmllcyggZWxlbWVudCApIHtcblx0XHRcdHZhciBxdWVyeSwgc2VsZWN0b3IsIGk7XG5cdFx0XHRpID0gZWxlbWVudC5saXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0cXVlcnkgPSBlbGVtZW50LmxpdmVRdWVyaWVzWyBpIF07XG5cdFx0XHRcdHNlbGVjdG9yID0gcXVlcnkuc2VsZWN0b3I7XG5cdFx0XHRcdHF1ZXJ5Ll9yZW1vdmUoIGVsZW1lbnQubm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSggcnVubG9vcCwgVHJhbnNpdGlvbiApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9fRWxlbWVudC5qcyAqL1xuXHR2YXIgRWxlbWVudCA9IGZ1bmN0aW9uKCBidWJibGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBnZXRBdHRyaWJ1dGUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciApIHtcblxuXHRcdHZhciBFbGVtZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLmluaXQoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEVsZW1lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXJcblx0XHR9O1xuXHRcdHJldHVybiBFbGVtZW50O1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkYnViYmxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZGV0YWNoLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQWxsQ29tcG9uZW50cywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRDb21wb25lbnQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaXJzdE5vZGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRnZXRBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bnJlbmRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9kZUluZGVudC5qcyAqL1xuXHR2YXIgZGVJbmRlbnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBlbXB0eSA9IC9eXFxzKiQvLFxuXHRcdFx0bGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccyovO1xuXHRcdHJldHVybiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0dmFyIGxpbmVzLCBmaXJzdExpbmUsIGxhc3RMaW5lLCBtaW5JbmRlbnQ7XG5cdFx0XHRsaW5lcyA9IHN0ci5zcGxpdCggJ1xcbicgKTtcblx0XHRcdC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBsaW5lLCBpZiB0aGV5IG9ubHkgY29udGFpbiB3aGl0ZXNwYWNlXG5cdFx0XHRmaXJzdExpbmUgPSBsaW5lc1sgMCBdO1xuXHRcdFx0aWYgKCBmaXJzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBlbXB0eS50ZXN0KCBmaXJzdExpbmUgKSApIHtcblx0XHRcdFx0bGluZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHRcdGxhc3RMaW5lID0gbGluZXNbIGxpbmVzLmxlbmd0aCAtIDEgXTtcblx0XHRcdGlmICggbGFzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBlbXB0eS50ZXN0KCBsYXN0TGluZSApICkge1xuXHRcdFx0XHRsaW5lcy5wb3AoKTtcblx0XHRcdH1cblx0XHRcdG1pbkluZGVudCA9IGxpbmVzLnJlZHVjZSggcmVkdWNlciwgbnVsbCApO1xuXHRcdFx0aWYgKCBtaW5JbmRlbnQgKSB7XG5cdFx0XHRcdHN0ciA9IGxpbmVzLm1hcCggZnVuY3Rpb24oIGxpbmUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmUucmVwbGFjZSggbWluSW5kZW50LCAnJyApO1xuXHRcdFx0XHR9ICkuam9pbiggJ1xcbicgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlZHVjZXIoIHByZXZpb3VzLCBsaW5lICkge1xuXHRcdFx0dmFyIGxpbmVJbmRlbnQgPSBsZWFkaW5nV2hpdGVzcGFjZS5leGVjKCBsaW5lIClbIDAgXTtcblx0XHRcdGlmICggcHJldmlvdXMgPT09IG51bGwgfHwgbGluZUluZGVudC5sZW5ndGggPCBwcmV2aW91cy5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBsaW5lSW5kZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZXZpb3VzO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9nZXRQYXJ0aWFsRGVzY3JpcHRvci5qcyAqL1xuXHR2YXIgZ2V0UGFydGlhbERlc2NyaXB0b3IgPSBmdW5jdGlvbiggbG9nLCBjb25maWcsIHBhcnNlciwgZGVJbmRlbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UGFydGlhbERlc2NyaXB0b3IoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcGFydGlhbDtcblx0XHRcdC8vIElmIHRoZSBwYXJ0aWFsIGluIGluc3RhbmNlIG9yIHZpZXcgaGVpcmFyY2h5IGluc3RhbmNlcywgZ3JlYXRcblx0XHRcdGlmICggcGFydGlhbCA9IGdldFBhcnRpYWxGcm9tUmVnaXN0cnkoIHJhY3RpdmUsIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRpYWw7XG5cdFx0XHR9XG5cdFx0XHQvLyBEb2VzIGl0IGV4aXN0IG9uIHRoZSBwYWdlIGFzIGEgc2NyaXB0IHRhZz9cblx0XHRcdHBhcnRpYWwgPSBwYXJzZXIuZnJvbUlkKCBuYW1lLCB7XG5cdFx0XHRcdG5vVGhyb3c6IHRydWVcblx0XHRcdH0gKTtcblx0XHRcdGlmICggcGFydGlhbCApIHtcblx0XHRcdFx0Ly8gaXMgdGhpcyBuZWNlc3Nhcnk/XG5cdFx0XHRcdHBhcnRpYWwgPSBkZUluZGVudCggcGFydGlhbCApO1xuXHRcdFx0XHQvLyBwYXJzZSBhbmQgcmVnaXN0ZXIgdG8gdGhpcyByYWN0aXZlIGluc3RhbmNlXG5cdFx0XHRcdHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoIHBhcnRpYWwsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSApO1xuXHRcdFx0XHQvLyByZWdpc3RlciAoYW5kIHJldHVybiBtYWluIHBhcnRpYWwgaWYgdGhlcmUgYXJlIG90aGVycyBpbiB0aGUgdGVtcGxhdGUpXG5cdFx0XHRcdHJldHVybiByYWN0aXZlLnBhcnRpYWxzWyBuYW1lIF0gPSBwYXJzZWQudDtcblx0XHRcdH1cblx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0bWVzc2FnZTogJ25vVGVtcGxhdGVGb3JQYXJ0aWFsJyxcblx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gTm8gbWF0Y2g/IFJldHVybiBhbiBlbXB0eSBhcnJheVxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KCByYWN0aXZlLCBuYW1lICkge1xuXHRcdFx0dmFyIHBhcnRpYWxzID0gY29uZmlnLnJlZ2lzdHJpZXMucGFydGlhbHM7XG5cdFx0XHQvLyBmaW5kIGZpcnN0IGluc3RhbmNlIGluIHRoZSByYWN0aXZlIG9yIHZpZXcgaGllcmFyY2h5IHRoYXQgaGFzIHRoaXMgcGFydGlhbFxuXHRcdFx0dmFyIGluc3RhbmNlID0gcGFydGlhbHMuZmluZEluc3RhbmNlKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcnRpYWwgPSBpbnN0YW5jZS5wYXJ0aWFsc1sgbmFtZSBdLFxuXHRcdFx0XHRmbjtcblx0XHRcdC8vIHBhcnRpYWwgaXMgYSBmdW5jdGlvbj9cblx0XHRcdGlmICggdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGZuID0gcGFydGlhbC5iaW5kKCBpbnN0YW5jZSApO1xuXHRcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UucGFydGlhbHMuaGFzT3duUHJvcGVydHkoIG5hbWUgKTtcblx0XHRcdFx0cGFydGlhbCA9IGZuKCBpbnN0YW5jZS5kYXRhLCBwYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnRpYWwgKSB7XG5cdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ25vUmVnaXN0cnlGdW5jdGlvblJldHVybicsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0cmVnaXN0cnk6ICdwYXJ0aWFsJyxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYWRkZWQgbWFudWFsbHkgdG8gdGhlIHJlZ2lzdHJ5LFxuXHRcdFx0Ly8gYnV0IGhhc24ndCBiZWVuIHBhcnNlZCwgcGFyc2UgaXQgbm93XG5cdFx0XHRpZiAoICFwYXJzZXIuaXNQYXJzZWQoIHBhcnRpYWwgKSApIHtcblx0XHRcdFx0Ly8gdXNlIHRoZSBwYXJzZU9wdGlvbnMgb2YgdGhlIHJhY3RpdmUgaW5zdGFuY2Ugb24gd2hpY2ggaXQgd2FzIGZvdW5kXG5cdFx0XHRcdHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoIHBhcnRpYWwsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIGluc3RhbmNlICkgKTtcblx0XHRcdFx0Ly8gUGFydGlhbHMgY2Fubm90IGNvbnRhaW4gbmVzdGVkIHBhcnRpYWxzIVxuXHRcdFx0XHQvLyBUT0RPIGFkZCBhIHRlc3QgZm9yIHRoaXNcblx0XHRcdFx0aWYgKCBwYXJzZWQucCApIHtcblx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiAnbm9OZXN0ZWRQYXJ0aWFscycsXG5cdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdHJuYW1lOiBuYW1lXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIGZuLCB1c2UgaW5zdGFuY2UgdG8gc3RvcmUgcmVzdWx0LCBvdGhlcndpc2UgbmVlZHMgdG8gZ29cblx0XHRcdFx0Ly8gaW4gdGhlIGNvcnJlY3QgcG9pbnQgaW4gcHJvdG90eXBlIGNoYWluIG9uIGluc3RhbmNlIG9yIGNvbnN0cnVjdG9yXG5cdFx0XHRcdHZhciB0YXJnZXQgPSBmbiA/IGluc3RhbmNlIDogcGFydGlhbHMuZmluZE93bmVyKCBpbnN0YW5jZSwgbmFtZSApO1xuXHRcdFx0XHQvLyBtYXkgYmUgYSB0ZW1wbGF0ZSB3aXRoIHBhcnRpYWxzLCB3aGljaCBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgYW5kIG1haW4gdGVtcGxhdGUgZXh0cmFjdGVkXG5cdFx0XHRcdHRhcmdldC5wYXJ0aWFsc1sgbmFtZSBdID0gcGFydGlhbCA9IHBhcnNlZC50O1xuXHRcdFx0fVxuXHRcdFx0Ly8gc3RvcmUgZm9yIHJlc2V0XG5cdFx0XHRpZiAoIGZuICkge1xuXHRcdFx0XHRwYXJ0aWFsLl9mbiA9IGZuO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnRpYWwudiA/IHBhcnRpYWwudCA6IHBhcnRpYWw7XG5cdFx0fVxuXHR9KCBsb2csIGNvbmZpZywgcGFyc2VyLCBkZUluZGVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9hcHBseUluZGVudC5qcyAqL1xuXHR2YXIgYXBwbHlJbmRlbnQgPSBmdW5jdGlvbiggc3RyaW5nLCBpbmRlbnQgKSB7XG5cdFx0dmFyIGluZGVudGVkO1xuXHRcdGlmICggIWluZGVudCApIHtcblx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0fVxuXHRcdGluZGVudGVkID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApLm1hcCggZnVuY3Rpb24oIGxpbmUsIG5vdEZpcnN0TGluZSApIHtcblx0XHRcdHJldHVybiBub3RGaXJzdExpbmUgPyBpbmRlbnQgKyBsaW5lIDogbGluZTtcblx0XHR9ICkuam9pbiggJ1xcbicgKTtcblx0XHRyZXR1cm4gaW5kZW50ZWQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL19QYXJ0aWFsLmpzICovXG5cdHZhciBQYXJ0aWFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRQYXJ0aWFsRGVzY3JpcHRvciwgYXBwbHlJbmRlbnQsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFBhcnRpYWwsIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0UGFydGlhbCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQsXG5cdFx0XHRcdHRlbXBsYXRlO1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuUEFSVElBTDtcblx0XHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUucjtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdGlmICggIW9wdGlvbnMudGVtcGxhdGUuciApIHtcblx0XHRcdFx0Ly8gVE9ETyBzdXBwb3J0IGR5bmFtaWMgcGFydGlhbCBzd2l0Y2hpbmdcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnUGFydGlhbHMgbXVzdCBoYXZlIGEgc3RhdGljIHJlZmVyZW5jZSAobm8gZXhwcmVzc2lvbnMpLiBUaGlzIG1heSBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlLicgKTtcblx0XHRcdH1cblx0XHRcdHRlbXBsYXRlID0gZ2V0UGFydGlhbERlc2NyaXB0b3IoIHBhcmVudEZyYWdtZW50LnJvb3QsIG9wdGlvbnMudGVtcGxhdGUuciApO1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRcdHJvb3Q6IHBhcmVudEZyYWdtZW50LnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRwRWxlbWVudDogcGFyZW50RnJhZ21lbnQucEVsZW1lbnRcblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdFBhcnRpYWwucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRkZXRhY2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5yZW5kZXIoKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIHRvU3RyaW5nICkge1xuXHRcdFx0XHR2YXIgc3RyaW5nLCBwcmV2aW91c0l0ZW0sIGxhc3RMaW5lLCBtYXRjaDtcblx0XHRcdFx0c3RyaW5nID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggdG9TdHJpbmcgKTtcblx0XHRcdFx0cHJldmlvdXNJdGVtID0gdGhpcy5wYXJlbnRGcmFnbWVudC5pdGVtc1sgdGhpcy5pbmRleCAtIDEgXTtcblx0XHRcdFx0aWYgKCAhcHJldmlvdXNJdGVtIHx8IHByZXZpb3VzSXRlbS50eXBlICE9PSB0eXBlcy5URVhUICkge1xuXHRcdFx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdExpbmUgPSBwcmV2aW91c0l0ZW0udGVtcGxhdGUuc3BsaXQoICdcXG4nICkucG9wKCk7XG5cdFx0XHRcdGlmICggbWF0Y2ggPSAvXlxccyskLy5leGVjKCBsYXN0TGluZSApICkge1xuXHRcdFx0XHRcdHJldHVybiBhcHBseUluZGVudCggc3RyaW5nLCBtYXRjaFsgMCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdH0sXG5cdFx0XHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEFsbDogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFBhcnRpYWw7XG5cdH0oIHR5cGVzLCBnZXRQYXJ0aWFsRGVzY3JpcHRvciwgYXBwbHlJbmRlbnQsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvZ2V0Q29tcG9uZW50LmpzICovXG5cdHZhciBnZXRDb21wb25lbnQgPSBmdW5jdGlvbiggY29uZmlnLCBsb2csIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFJhY3RpdmU7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRSYWN0aXZlID0gY2lyY3VsYXIuUmFjdGl2ZTtcblx0XHR9ICk7XG5cdFx0Ly8gZmluZHMgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBpbiB0aGUgcmVnaXN0cnkgb3IgdmlldyBoaWVyYXJjaHkgcmVnaXN0cmllc1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRDb21wb25lbnQoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50LCBpbnN0YW5jZSA9IGNvbmZpZy5yZWdpc3RyaWVzLmNvbXBvbmVudHMuZmluZEluc3RhbmNlKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRjb21wb25lbnQgPSBpbnN0YW5jZS5jb21wb25lbnRzWyBuYW1lIF07XG5cdFx0XHRcdC8vIGJlc3QgdGVzdCB3ZSBoYXZlIGZvciBub3QgUmFjdGl2ZS5leHRlbmRcblx0XHRcdFx0aWYgKCAhY29tcG9uZW50Ll9wYXJlbnQgKSB7XG5cdFx0XHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uLCBleGVjdXRlIGFuZCBzdG9yZSBmb3IgcmVzZXRcblx0XHRcdFx0XHR2YXIgZm4gPSBjb21wb25lbnQuYmluZCggaW5zdGFuY2UgKTtcblx0XHRcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApO1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGZuKCBpbnN0YW5jZS5kYXRhICk7XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4nLFxuXHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cmVnaXN0cnk6ICdjb21wb25lbnQnLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0Ly9hbGxvdyBzdHJpbmcgbG9va3VwXG5cdFx0XHRcdFx0XHRjb21wb25lbnQgPSBnZXRDb21wb25lbnQoIHJhY3RpdmUsIGNvbXBvbmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21wb25lbnQuX2ZuID0gZm47XG5cdFx0XHRcdFx0aW5zdGFuY2UuY29tcG9uZW50c1sgbmFtZSBdID0gY29tcG9uZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50O1xuXHRcdH07XG5cdH0oIGNvbmZpZywgbG9nLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGRldGFjaCA9IGZ1bmN0aW9uIENvbXBvbmVudCRkZXRhY2goKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmQgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbCA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHF1ZXJ5Ll90ZXN0KCB0aGlzLCB0cnVlICk7XG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdGlmICggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSB0aGlzLm5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlLmZyYWdtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZE5leHROb2RlID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmROZXh0Tm9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaXJzdE5vZGUgPSBmdW5jdGlvbiBDb21wb25lbnQkZmlyc3ROb2RlKCkge1xuXHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZU1vZGVsL0NvbXBvbmVudFBhcmFtZXRlci5qcyAqL1xuXHR2YXIgQ29tcG9uZW50UGFyYW1ldGVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBDb21wb25lbnRQYXJhbWV0ZXI7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRDb21wb25lbnRQYXJhbWV0ZXIgPSBmdW5jdGlvbiggY29tcG9uZW50LCBrZXksIHZhbHVlICkge1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXHRcdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB2YWx1ZSxcblx0XHRcdFx0cm9vdDogY29tcG9uZW50LnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdH07XG5cdFx0Q29tcG9uZW50UGFyYW1ldGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuZGlydHkgKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuY29tcG9uZW50Lmluc3RhbmNlLnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5LCB2YWx1ZSApO1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5jb21wb25lbnQuaW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcG9uZW50UGFyYW1ldGVyO1xuXHR9KCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlTW9kZWwvX2NyZWF0ZU1vZGVsLmpzICovXG5cdHZhciBjcmVhdGVNb2RlbCA9IGZ1bmN0aW9uKCB0eXBlcywgcGFyc2VKU09OLCByZXNvbHZlUmVmLCBDb21wb25lbnRQYXJhbWV0ZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGNvbXBvbmVudCwgZGVmYXVsdERhdGEsIGF0dHJpYnV0ZXMsIHRvQmluZCApIHtcblx0XHRcdHZhciBkYXRhID0ge30sXG5cdFx0XHRcdGtleSwgdmFsdWU7XG5cdFx0XHQvLyBzb21lIHBhcmFtZXRlcnMsIGUuZy4gZm9vPVwiVGhlIHZhbHVlIGlzIHt7YmFyfX1cIiwgYXJlICdjb21wbGV4JyAtIGluXG5cdFx0XHQvLyBvdGhlciB3b3Jkcywgd2UgbmVlZCB0byBjb25zdHJ1Y3QgYSBzdHJpbmcgZnJhZ21lbnQgdG8gd2F0Y2hcblx0XHRcdC8vIHdoZW4gdGhleSBjaGFuZ2UuIFdlIHN0b3JlIHRoZXNlIHNvIHRoZXkgY2FuIGJlIHRvcm4gZG93biBsYXRlclxuXHRcdFx0Y29tcG9uZW50LmNvbXBsZXhQYXJhbWV0ZXJzID0gW107XG5cdFx0XHRmb3IgKCBrZXkgaW4gYXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGdldFZhbHVlKCBjb21wb25lbnQsIGtleSwgYXR0cmlidXRlc1sga2V5IF0sIHRvQmluZCApO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCB8fCBkZWZhdWx0RGF0YVsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGRhdGFbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIGNvbXBvbmVudCwga2V5LCB0ZW1wbGF0ZSwgdG9CaW5kICkge1xuXHRcdFx0dmFyIHBhcmFtZXRlciwgcGFyc2VkLCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50RnJhZ21lbnQsIGtleXBhdGgsIGluZGV4UmVmO1xuXHRcdFx0cGFyZW50SW5zdGFuY2UgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHN0YXRpYyB2YWx1ZSwgZ3JlYXRcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCB0ZW1wbGF0ZSApO1xuXHRcdFx0XHRpZiAoICFwYXJzZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRlbXBsYXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXJzZWQudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBudWxsLCB3ZSB0cmVhdCBpdCBhcyBhIGJvb2xlYW4gYXR0cmlidXRlIChpLmUuIHRydWUpXG5cdFx0XHRpZiAoIHRlbXBsYXRlID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIElmIGEgcmVndWxhciBpbnRlcnBvbGF0b3IsIHdlIGJpbmQgdG8gaXRcblx0XHRcdGlmICggdGVtcGxhdGUubGVuZ3RoID09PSAxICYmIHRlbXBsYXRlWyAwIF0udCA9PT0gdHlwZXMuSU5URVJQT0xBVE9SICYmIHRlbXBsYXRlWyAwIF0uciApIHtcblx0XHRcdFx0Ly8gSXMgaXQgYW4gaW5kZXggcmVmZXJlbmNlP1xuXHRcdFx0XHRpZiAoIHBhcmVudEZyYWdtZW50LmluZGV4UmVmcyAmJiBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnNbIGluZGV4UmVmID0gdGVtcGxhdGVbIDAgXS5yIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuaW5kZXhSZWZCaW5kaW5nc1sgaW5kZXhSZWYgXSA9IGtleTtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzWyBpbmRleFJlZiBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRPRE8gd2hhdCBhYm91dCByZWZlcmVuY2VzIHRoYXQgcmVzb2x2ZSBsYXRlPyBTaG91bGQgdGhlc2UgYmUgY29uc2lkZXJlZD9cblx0XHRcdFx0a2V5cGF0aCA9IHJlc29sdmVSZWYoIHBhcmVudEluc3RhbmNlLCB0ZW1wbGF0ZVsgMCBdLnIsIHBhcmVudEZyYWdtZW50ICkgfHwgdGVtcGxhdGVbIDAgXS5yO1xuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHNldCB1cCBiaW5kaW5ncyBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQsIGJ1dFxuXHRcdFx0XHQvLyB3ZSBjYW4ndCBkbyBpdCB5ZXQgYmVjYXVzZSB0aGUgY2hpbGQgaW5zdGFuY2UgZG9lc24ndCBleGlzdFxuXHRcdFx0XHQvLyB5ZXQgLSBzbyB3ZSBtYWtlIGEgbm90ZSBpbnN0ZWFkXG5cdFx0XHRcdHRvQmluZC5wdXNoKCB7XG5cdFx0XHRcdFx0Y2hpbGRLZXlwYXRoOiBrZXksXG5cdFx0XHRcdFx0cGFyZW50S2V5cGF0aDoga2V5cGF0aFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRJbnN0YW5jZS52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSBoYXZlIGEgJ2NvbXBsZXggcGFyYW1ldGVyJyAtIHdlIG5lZWQgdG8gY3JlYXRlIGEgZnVsbC1ibG93biBzdHJpbmdcblx0XHRcdC8vIGZyYWdtZW50IGluIG9yZGVyIHRvIGV2YWx1YXRlIGFuZCBvYnNlcnZlIGl0cyB2YWx1ZVxuXHRcdFx0cGFyYW1ldGVyID0gbmV3IENvbXBvbmVudFBhcmFtZXRlciggY29tcG9uZW50LCBrZXksIHRlbXBsYXRlICk7XG5cdFx0XHRjb21wb25lbnQuY29tcGxleFBhcmFtZXRlcnMucHVzaCggcGFyYW1ldGVyICk7XG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVyLnZhbHVlO1xuXHRcdH1cblx0fSggdHlwZXMsIHBhcnNlSlNPTiwgcmVzb2x2ZVJlZiwgQ29tcG9uZW50UGFyYW1ldGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVJbnN0YW5jZS5qcyAqL1xuXHR2YXIgY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiggY29tcG9uZW50LCBDb21wb25lbnQsIGRhdGEsIGNvbnRlbnREZXNjcmlwdG9yICkge1xuXHRcdHZhciBpbnN0YW5jZSwgcGFyZW50RnJhZ21lbnQsIHBhcnRpYWxzLCByb290O1xuXHRcdHBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdHJvb3QgPSBjb21wb25lbnQucm9vdDtcblx0XHQvLyBNYWtlIGNvbnRlbnRzIGF2YWlsYWJsZSBhcyBhIHt7PmNvbnRlbnR9fSBwYXJ0aWFsXG5cdFx0cGFydGlhbHMgPSB7XG5cdFx0XHRjb250ZW50OiBjb250ZW50RGVzY3JpcHRvciB8fCBbXVxuXHRcdH07XG5cdFx0aW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KCB7XG5cdFx0XHRhcHBlbmQ6IHRydWUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0cGFydGlhbHM6IHBhcnRpYWxzLFxuXHRcdFx0bWFnaWM6IHJvb3QubWFnaWMgfHwgQ29tcG9uZW50LmRlZmF1bHRzLm1hZ2ljLFxuXHRcdFx0bW9kaWZ5QXJyYXlzOiByb290Lm1vZGlmeUFycmF5cyxcblx0XHRcdF9wYXJlbnQ6IHJvb3QsXG5cdFx0XHRfY29tcG9uZW50OiBjb21wb25lbnQsXG5cdFx0XHQvLyBuZWVkIHRvIGluaGVyaXQgcnVudGltZSBwYXJlbnQgYWRhcHRvcnNcblx0XHRcdGFkYXB0OiByb290LmFkYXB0XG5cdFx0fSApO1xuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZUJpbmRpbmdzLmpzICovXG5cdHZhciBjcmVhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uKCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxDb21wb25lbnRCaW5kaW5ncyggY29tcG9uZW50LCB0b0JpbmQgKSB7XG5cdFx0XHR0b0JpbmQuZm9yRWFjaCggZnVuY3Rpb24gY3JlYXRlSW5pdGlhbENvbXBvbmVudEJpbmRpbmcoIHBhaXIgKSB7XG5cdFx0XHRcdHZhciBjaGlsZFZhbHVlLCBwYXJlbnRWYWx1ZTtcblx0XHRcdFx0Y3JlYXRlQ29tcG9uZW50QmluZGluZyggY29tcG9uZW50LCBjb21wb25lbnQucm9vdCwgcGFpci5wYXJlbnRLZXlwYXRoLCBwYWlyLmNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRjaGlsZFZhbHVlID0gY29tcG9uZW50Lmluc3RhbmNlLnZpZXdtb2RlbC5nZXQoIHBhaXIuY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gY29tcG9uZW50LnJvb3Qudmlld21vZGVsLmdldCggcGFpci5wYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdGlmICggY2hpbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHBhcmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnJvb3Qudmlld21vZGVsLnNldCggcGFpci5wYXJlbnRLZXlwYXRoLCBjaGlsZFZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9wcm9wYWdhdGVFdmVudHMuanMgKi9cblx0dmFyIHByb3BhZ2F0ZUV2ZW50cyA9IGZ1bmN0aW9uKCBsb2cgKSB7XG5cblx0XHQvLyBUT0RPIGhvdyBzaG91bGQgZXZlbnQgYXJndW1lbnRzIGJlIGhhbmRsZWQ/IGUuZy5cblx0XHQvLyA8d2lkZ2V0IG9uLWZvbz0nYmFyOjEsMiwzJy8+XG5cdFx0Ly8gVGhlIGV2ZW50ICdiYXInIHdpbGwgYmUgZmlyZWQgb24gdGhlIHBhcmVudCBpbnN0YW5jZVxuXHRcdC8vIHdoZW4gJ2ZvbycgZmlyZXMgb24gdGhlIGNoaWxkLCBidXQgdGhlIDEsMiwzIGFyZ3VtZW50c1xuXHRcdC8vIHdpbGwgYmUgbG9zdFxuXHRcdHJldHVybiBmdW5jdGlvbiggY29tcG9uZW50LCBldmVudHNEZXNjcmlwdG9yICkge1xuXHRcdFx0dmFyIGV2ZW50TmFtZTtcblx0XHRcdGZvciAoIGV2ZW50TmFtZSBpbiBldmVudHNEZXNjcmlwdG9yICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50c0Rlc2NyaXB0b3IuaGFzT3duUHJvcGVydHkoIGV2ZW50TmFtZSApICkge1xuXHRcdFx0XHRcdHByb3BhZ2F0ZUV2ZW50KCBjb21wb25lbnQuaW5zdGFuY2UsIGNvbXBvbmVudC5yb290LCBldmVudE5hbWUsIGV2ZW50c0Rlc2NyaXB0b3JbIGV2ZW50TmFtZSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnQoIGNoaWxkSW5zdGFuY2UsIHBhcmVudEluc3RhbmNlLCBldmVudE5hbWUsIHByb3h5RXZlbnROYW1lICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgcHJveHlFdmVudE5hbWUgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcGFyZW50SW5zdGFuY2UuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ25vQ29tcG9uZW50RXZlbnRBcmd1bWVudHMnXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGNoaWxkSW5zdGFuY2Uub24oIGV2ZW50TmFtZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoIHByb3h5RXZlbnROYW1lICk7XG5cdFx0XHRcdHBhcmVudEluc3RhbmNlLmZpcmUuYXBwbHkoIHBhcmVudEluc3RhbmNlLCBhcmdzICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9KCBsb2cgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL3VwZGF0ZUxpdmVRdWVyaWVzLmpzICovXG5cdHZhciB1cGRhdGVMaXZlUXVlcmllcyA9IGZ1bmN0aW9uKCBjb21wb25lbnQgKSB7XG5cdFx0dmFyIGFuY2VzdG9yLCBxdWVyeTtcblx0XHQvLyBJZiB0aGVyZSdzIGEgbGl2ZSBxdWVyeSBmb3IgdGhpcyBjb21wb25lbnQgdHlwZSwgYWRkIGl0XG5cdFx0YW5jZXN0b3IgPSBjb21wb25lbnQucm9vdDtcblx0XHR3aGlsZSAoIGFuY2VzdG9yICkge1xuXHRcdFx0aWYgKCBxdWVyeSA9IGFuY2VzdG9yLl9saXZlQ29tcG9uZW50UXVlcmllc1sgJ18nICsgY29tcG9uZW50Lm5hbWUgXSApIHtcblx0XHRcdFx0cXVlcnkucHVzaCggY29tcG9uZW50Lmluc3RhbmNlICk7XG5cdFx0XHR9XG5cdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLl9wYXJlbnQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCB3YXJuLCBjcmVhdGVNb2RlbCwgY3JlYXRlSW5zdGFuY2UsIGNyZWF0ZUJpbmRpbmdzLCBwcm9wYWdhdGVFdmVudHMsIHVwZGF0ZUxpdmVRdWVyaWVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCRpbml0KCBvcHRpb25zLCBDb21wb25lbnQgKSB7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQsIHJvb3QsIGRhdGEsIHRvQmluZDtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMucm9vdCA9IHJvb3Q7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5DT01QT05FTlQ7XG5cdFx0XHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLmU7XG5cdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdHRoaXMuaW5kZXhSZWZCaW5kaW5ncyA9IHt9O1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IFtdO1xuXHRcdFx0aWYgKCAhQ29tcG9uZW50ICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb21wb25lbnQgXCInICsgdGhpcy5uYW1lICsgJ1wiIG5vdCBmb3VuZCcgKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpcnN0LCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG1vZGVsIGZvciB0aGUgY29tcG9uZW50IC0gZS5nLiBpZiB3ZVxuXHRcdFx0Ly8gZW5jb3VudGVyIDx3aWRnZXQgZm9vPSdiYXInLz4gdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdpZGdldFxuXHRcdFx0Ly8gd2l0aCBgZGF0YTogeyBmb286ICdiYXInIH1gLlxuXHRcdFx0Ly9cblx0XHRcdC8vIFRoaXMgbWF5IGludm9sdmUgc2V0dGluZyB1cCBzb21lIGJpbmRpbmdzLCBidXQgd2UgY2FuJ3QgZG8gaXRcblx0XHRcdC8vIHlldCBzbyB3ZSB0YWtlIHNvbWUgbm90ZXMgaW5zdGVhZFxuXHRcdFx0dG9CaW5kID0gW107XG5cdFx0XHRkYXRhID0gY3JlYXRlTW9kZWwoIHRoaXMsIENvbXBvbmVudC5kZWZhdWx0cy5kYXRhIHx8IHt9LCBvcHRpb25zLnRlbXBsYXRlLmEsIHRvQmluZCApO1xuXHRcdFx0Y3JlYXRlSW5zdGFuY2UoIHRoaXMsIENvbXBvbmVudCwgZGF0YSwgb3B0aW9ucy50ZW1wbGF0ZS5mICk7XG5cdFx0XHRjcmVhdGVCaW5kaW5ncyggdGhpcywgdG9CaW5kICk7XG5cdFx0XHRwcm9wYWdhdGVFdmVudHMoIHRoaXMsIG9wdGlvbnMudGVtcGxhdGUudiApO1xuXHRcdFx0Ly8gaW50cm8sIG91dHJvIGFuZCBkZWNvcmF0b3IgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnQxIHx8IG9wdGlvbnMudGVtcGxhdGUudDIgfHwgb3B0aW9ucy50ZW1wbGF0ZS5vICkge1xuXHRcdFx0XHR3YXJuKCAnVGhlIFwiaW50cm9cIiwgXCJvdXRyb1wiIGFuZCBcImRlY29yYXRvclwiIGRpcmVjdGl2ZXMgaGF2ZSBubyBlZmZlY3Qgb24gY29tcG9uZW50cycgKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0fTtcblx0fSggdHlwZXMsIHdhcm4sIGNyZWF0ZU1vZGVsLCBjcmVhdGVJbnN0YW5jZSwgY3JlYXRlQmluZGluZ3MsIHByb3BhZ2F0ZUV2ZW50cywgdXBkYXRlTGl2ZVF1ZXJpZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZWJpbmQgPSBmdW5jdGlvbiggcnVubG9vcCwgZ2V0TmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBDb21wb25lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgY2hpbGRJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2UsXG5cdFx0XHRcdHBhcmVudEluc3RhbmNlID0gY2hpbGRJbnN0YW5jZS5fcGFyZW50LFxuXHRcdFx0XHRpbmRleFJlZkFsaWFzLCBxdWVyeTtcblx0XHRcdHRoaXMuYmluZGluZ3MuZm9yRWFjaCggZnVuY3Rpb24oIGJpbmRpbmcgKSB7XG5cdFx0XHRcdHZhciB1cGRhdGVkO1xuXHRcdFx0XHRpZiAoIGJpbmRpbmcucm9vdCAhPT0gcGFyZW50SW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdXBkYXRlZCA9IGdldE5ld0tleXBhdGgoIGJpbmRpbmcua2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkge1xuXHRcdFx0XHRcdGJpbmRpbmcucmViaW5kKCB1cGRhdGVkICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuY29tcGxleFBhcmFtZXRlcnMuZm9yRWFjaCggZnVuY3Rpb24oIHBhcmFtZXRlciApIHtcblx0XHRcdFx0cGFyYW1ldGVyLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoIGluZGV4UmVmQWxpYXMgPSB0aGlzLmluZGV4UmVmQmluZGluZ3NbIGluZGV4UmVmIF0gKSB7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCBjaGlsZEluc3RhbmNlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHRjaGlsZEluc3RhbmNlLnZpZXdtb2RlbC5zZXQoIGluZGV4UmVmQWxpYXMsIG5ld0luZGV4ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHF1ZXJ5ID0gdGhpcy5yb290Ll9saXZlQ29tcG9uZW50UXVlcmllc1sgJ18nICsgdGhpcy5uYW1lIF0gKSB7XG5cdFx0XHRcdHF1ZXJ5Ll9tYWtlRGlydHkoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wLCBnZXROZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmVuZGVyID0gZnVuY3Rpb24gQ29tcG9uZW50JHJlbmRlcigpIHtcblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXHRcdGluc3RhbmNlLnJlbmRlciggdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkgKTtcblx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gaW5zdGFuY2UuZGV0YWNoKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR0b1N0cmluZyA9IGZ1bmN0aW9uIENvbXBvbmVudCR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC50b1N0cmluZygpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVuYmluZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCR1bmJpbmQoKSB7XG5cdFx0XHR0aGlzLmNvbXBsZXhQYXJhbWV0ZXJzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyggdGhpcyApO1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC51bmJpbmQoKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCB0aGluZyApIHtcblx0XHRcdHRoaW5nLnVuYmluZCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyggY29tcG9uZW50ICkge1xuXHRcdFx0dmFyIGluc3RhbmNlLCBxdWVyeTtcblx0XHRcdGluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmICggcXVlcnkgPSBpbnN0YW5jZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbICdfJyArIGNvbXBvbmVudC5uYW1lIF0gKSB7XG5cdFx0XHRcdFx0cXVlcnkuX3JlbW92ZSggY29tcG9uZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCBpbnN0YW5jZSA9IGluc3RhbmNlLl9wYXJlbnQgKTtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVucmVuZGVyID0gZnVuY3Rpb24gQ29tcG9uZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdHRoaXMuaW5zdGFuY2UuZmlyZSggJ3RlYXJkb3duJyApO1xuXHRcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHNob3VsZERlc3Ryb3k7XG5cdFx0dGhpcy5pbnN0YW5jZS51bnJlbmRlcigpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L19Db21wb25lbnQuanMgKi9cblx0dmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uKCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyICkge1xuXG5cdFx0dmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uKCBvcHRpb25zLCBDb25zdHJ1Y3RvciApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucywgQ29uc3RydWN0b3IgKTtcblx0XHR9O1xuXHRcdENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcG9uZW50O1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21tZW50LmpzICovXG5cdHZhciBDb21tZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgQ29tbWVudCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQ09NTUVOVDtcblx0XHRcdHRoaXMudmFsdWUgPSBvcHRpb25zLnRlbXBsYXRlLmM7XG5cdFx0fTtcblx0XHRDb21tZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggdGhpcy52YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJzwhLS0nICsgdGhpcy52YWx1ZSArICctLT4nO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIENvbW1lbnQ7XG5cdH0oIHR5cGVzLCBkZXRhY2ggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUl0ZW0uanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdF9jcmVhdGVJdGVtID0gZnVuY3Rpb24oIHR5cGVzLCBUZXh0LCBJbnRlcnBvbGF0b3IsIFNlY3Rpb24sIFRyaXBsZSwgRWxlbWVudCwgUGFydGlhbCwgZ2V0Q29tcG9uZW50LCBDb21wb25lbnQsIENvbW1lbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlSXRlbSggb3B0aW9ucyApIHtcblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFRleHQoIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAoIG9wdGlvbnMudGVtcGxhdGUudCApIHtcblx0XHRcdFx0Y2FzZSB0eXBlcy5JTlRFUlBPTEFUT1I6XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBJbnRlcnBvbGF0b3IoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgU2VjdGlvbiggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlRSSVBMRTpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRyaXBsZSggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkVMRU1FTlQ6XG5cdFx0XHRcdFx0dmFyIGNvbnN0cnVjdG9yO1xuXHRcdFx0XHRcdGlmICggY29uc3RydWN0b3IgPSBnZXRDb21wb25lbnQoIG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdCwgb3B0aW9ucy50ZW1wbGF0ZS5lICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IENvbXBvbmVudCggb3B0aW9ucywgY29uc3RydWN0b3IgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBFbGVtZW50KCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuUEFSVElBTDpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBhcnRpYWwoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5DT01NRU5UOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgQ29tbWVudCggb3B0aW9ucyApO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1NvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMuIFRoYW5rcyEnICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMsIFRleHQsIEludGVycG9sYXRvciwgU2VjdGlvbiwgVHJpcGxlLCBFbGVtZW50LCBQYXJ0aWFsLCBnZXRDb21wb25lbnQsIENvbXBvbmVudCwgQ29tbWVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgY3JlYXRlLCBjcmVhdGVJdGVtICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEZyYWdtZW50JGluaXQoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgcGFyZW50UmVmcywgcmVmO1xuXHRcdFx0Ly8gVGhlIGl0ZW0gdGhhdCBvd25zIHRoaXMgZnJhZ21lbnQgLSBhbiBlbGVtZW50LCBzZWN0aW9uLCBwYXJ0aWFsLCBvciBhdHRyaWJ1dGVcblx0XHRcdHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudCA9IHRoaXMub3duZXIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHQvLyBpbmhlcml0ZWQgcHJvcGVydGllc1xuXHRcdFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXHRcdFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cdFx0XHQvLyBJZiBwYXJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIHRoaXMgbWF5IG5vdCBiZSB0aGUgb25seSBmcmFnbWVudFxuXHRcdFx0Ly8gdGhhdCBiZWxvbmdzIHRvIGl0IC0gd2UgbmVlZCB0byBtYWtlIGEgbm90ZSBvZiB0aGUgaW5kZXhcblx0XHRcdGlmICggdGhpcy5vd25lci50eXBlID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdH1cblx0XHRcdC8vIGluZGV4IHJlZmVyZW5jZXMgKHRoZSAnaScgaW4ge3sjc2VjdGlvbjppfX0uLi57ey9zZWN0aW9ufX0pIG5lZWQgdG8gY2FzY2FkZVxuXHRcdFx0Ly8gZG93biB0aGUgdHJlZVxuXHRcdFx0aWYgKCBwYXJlbnRGcmFnbWVudCApIHtcblx0XHRcdFx0cGFyZW50UmVmcyA9IHBhcmVudEZyYWdtZW50LmluZGV4UmVmcztcblx0XHRcdFx0aWYgKCBwYXJlbnRSZWZzICkge1xuXHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHRcdFx0Ly8gYXZvaWRzIG5lZWQgZm9yIGhhc093blByb3BlcnR5XG5cdFx0XHRcdFx0Zm9yICggcmVmIGluIHBhcmVudFJlZnMgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgcmVmIF0gPSBwYXJlbnRSZWZzWyByZWYgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGluaGVyaXQgcHJpb3JpdHlcblx0XHRcdHRoaXMucHJpb3JpdHkgPSBwYXJlbnRGcmFnbWVudCA/IHBhcmVudEZyYWdtZW50LnByaW9yaXR5ICsgMSA6IDE7XG5cdFx0XHRpZiAoIG9wdGlvbnMuaW5kZXhSZWYgKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuaW5kZXhSZWZzICkge1xuXHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5pbmRleFJlZnNbIG9wdGlvbnMuaW5kZXhSZWYgXSA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lIHRvIGNyZWF0ZSB0aGlzIGZyYWdtZW50J3MgY2hpbGQgaXRlbXNcblx0XHRcdC8vIFRFTVAgc2hvdWxkIHRoaXMgYmUgaGFwcGVuaW5nP1xuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdG9wdGlvbnMudGVtcGxhdGUgPSBbIG9wdGlvbnMudGVtcGxhdGUgXTtcblx0XHRcdH0gZWxzZSBpZiAoICFvcHRpb25zLnRlbXBsYXRlICkge1xuXHRcdFx0XHRvcHRpb25zLnRlbXBsYXRlID0gW107XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1zID0gb3B0aW9ucy50ZW1wbGF0ZS5tYXAoIGZ1bmN0aW9uKCB0ZW1wbGF0ZSwgaSApIHtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUl0ZW0oIHtcblx0XHRcdFx0XHRwYXJlbnRGcmFnbWVudDogdGhpcyQwLFxuXHRcdFx0XHRcdHBFbGVtZW50OiBvcHRpb25zLnBFbGVtZW50LFxuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5hcmdzTGlzdCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmluaXRlZCA9IHRydWU7XG5cdFx0fTtcblx0fSggdHlwZXMsIGNyZWF0ZSwgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0X2NyZWF0ZUl0ZW0gKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkcmViaW5kID0gZnVuY3Rpb24oIGFzc2lnbk5ld0tleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRnJhZ21lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHQvLyBhc3NpZ24gbmV3IGNvbnRleHQga2V5cGF0aCBpZiBuZWVkZWRcblx0XHRcdGFzc2lnbk5ld0tleXBhdGgoIHRoaXMsICdjb250ZXh0Jywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0aWYgKCB0aGlzLmluZGV4UmVmcyAmJiB0aGlzLmluZGV4UmVmc1sgaW5kZXhSZWYgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgaW5kZXhSZWYgXSA9IG5ld0luZGV4O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0aWYgKCBpdGVtLnJlYmluZCApIHtcblx0XHRcdFx0XHRpdGVtLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBhc3NpZ25OZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHJlbmRlciA9IGZ1bmN0aW9uIEZyYWdtZW50JHJlbmRlcigpIHtcblx0XHR2YXIgcmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXN1bHQgPSB0aGlzLml0ZW1zWyAwIF0ucmVuZGVyKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdHJlc3VsdC5hcHBlbmRDaGlsZCggaXRlbS5yZW5kZXIoKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHRvU3RyaW5nID0gZnVuY3Rpb24gRnJhZ21lbnQkdG9TdHJpbmcoIGVzY2FwZSApIHtcblx0XHRpZiAoICF0aGlzLml0ZW1zICkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5pdGVtcy5tYXAoIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIGl0ZW0udG9TdHJpbmcoIGVzY2FwZSApO1xuXHRcdH0gKS5qb2luKCAnJyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCR1bmJpbmQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBGcmFnbWVudCR1bmJpbmQoKSB7XG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goIHVuYmluZEl0ZW0gKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kSXRlbSggaXRlbSApIHtcblx0XHRcdGlmICggaXRlbS51bmJpbmQgKSB7XG5cdFx0XHRcdGl0ZW0udW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkdW5yZW5kZXIgPSBmdW5jdGlvbiBGcmFnbWVudCR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHVucmVuZGVyIGEgZnJhZ21lbnQgdGhhdCB3YXMgbm90IHJlbmRlcmVkJyApO1xuXHRcdH1cblx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0cmV0dXJuIGkudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC5qcyAqL1xuXHR2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiggYnViYmxlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgZ2V0Tm9kZSwgZ2V0VmFsdWUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0RnJhZ21lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXROb2RlOiBnZXROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IGdldFZhbHVlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0Y2lyY3VsYXIuRnJhZ21lbnQgPSBGcmFnbWVudDtcblx0XHRyZXR1cm4gRnJhZ21lbnQ7XG5cdH0oIHZpcnR1YWxkb21fRnJhZ21lbnQkYnViYmxlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGRldGFjaCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRBbGwsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGdldE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0VmFsdWUsIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdCwgdmlydHVhbGRvbV9GcmFnbWVudCRyZWJpbmQsIHZpcnR1YWxkb21fRnJhZ21lbnQkcmVuZGVyLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVuYmluZCwgdmlydHVhbGRvbV9GcmFnbWVudCR1bnJlbmRlciwgY2lyY3VsYXIgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXNldC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXNldCA9IGZ1bmN0aW9uKCBydW5sb29wLCBGcmFnbWVudCwgY29uZmlnICkge1xuXG5cdFx0dmFyIHNob3VsZFJlcmVuZGVyID0gW1xuXHRcdFx0J3RlbXBsYXRlJyxcblx0XHRcdCdwYXJ0aWFscycsXG5cdFx0XHQnY29tcG9uZW50cycsXG5cdFx0XHQnZGVjb3JhdG9ycycsXG5cdFx0XHQnZXZlbnRzJ1xuXHRcdF07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXQoIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2UsIHdyYXBwZXIsIGNoYW5nZXMsIGksIHJlcmVuZGVyO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHt9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGhlIHJlc2V0IG1ldGhvZCB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnRzLCBvciBhbiBvYmplY3QgY29udGFpbmluZyBuZXcgZGF0YScgKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZSByb290IG9iamVjdCBpcyB3cmFwcGVkLCB0cnkgYW5kIHVzZSB0aGUgd3JhcHBlcidzIHJlc2V0IHZhbHVlXG5cdFx0XHRpZiAoICggd3JhcHBlciA9IHRoaXMudmlld21vZGVsLndyYXBwZWRbICcnIF0gKSAmJiB3cmFwcGVyLnJlc2V0ICkge1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIucmVzZXQoIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgd2FzIHJlamVjdGVkLCB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIG9iamVjdFxuXHRcdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHR9XG5cdFx0XHQvLyByZXNldCBjb25maWcgaXRlbXMgYW5kIHRyYWNrIGlmIG5lZWQgdG8gcmVyZW5kZXJcblx0XHRcdGNoYW5nZXMgPSBjb25maWcucmVzZXQoIHRoaXMgKTtcblx0XHRcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZFJlcmVuZGVyLmluZGV4T2YoIGNoYW5nZXNbIGkgXSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmVyZW5kZXIgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJlcmVuZGVyICkge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50O1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCAnJyApO1xuXHRcdFx0XHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG5cdFx0XHRcdC8vIGZsYWcsIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBieSBkZWZhdWx0IHRoYXQgYSBwYXJlbnQgbm9kZVxuXHRcdFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcblx0XHRcdFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcblx0XHRcdFx0aWYgKCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51bnJlbmRlcigpO1xuXHRcdFx0XHRpZiAoIGNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHRoZSB0ZW1wbGF0ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIGRlc3Ryb3kgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0XHQvLyBUT0RPIGlmIHdlJ3JlIGhlcmUsIHByZXN1bWFibHkgaXQgZGlkP1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQudGVtcGxhdGUgIT09IHRoaXMudGVtcGxhdGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcblx0XHRcdFx0XHRcdHJvb3Q6IHRoaXMsXG5cdFx0XHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9taXNlID0gdGhpcy5yZW5kZXIoIHRoaXMuZWwsIHRoaXMuYW5jaG9yICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCAnJyApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5maXJlKCAncmVzZXQnLCBkYXRhICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBydW5sb29wLCBGcmFnbWVudCwgY29uZmlnICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmVzZXRUZW1wbGF0ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXNldFRlbXBsYXRlID0gZnVuY3Rpb24oIGNvbmZpZywgRnJhZ21lbnQgKSB7XG5cblx0XHQvLyBUT0RPIHNob3VsZCByZXNldFRlbXBsYXRlIGJlIGFzeW5jaHJvbm91cz8gaS5lLiBzaG91bGQgaXQgYmUgYSBjYXNlXG5cdFx0Ly8gb2Ygb3V0cm8sIHVwZGF0ZSB0ZW1wbGF0ZSwgaW50cm8/IEkgcmVja29uIHByb2JhYmx5IG5vdCwgc2luY2UgdGhhdFxuXHRcdC8vIGNvdWxkIGJlIGFjaGlldmVkIHdpdGggdW5yZW5kZXItcmVzZXRUZW1wbGF0ZS1yZW5kZXIuIEFsc28sIGl0IHNob3VsZFxuXHRcdC8vIGNvbmNlcHR1YWxseSBiZSBzaW1pbGFyIHRvIHJlc2V0UGFydGlhbCwgd2hpY2ggY291bGRuJ3QgYmUgYXN5bmNcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZXNldFRlbXBsYXRlKCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciB0cmFuc2l0aW9uc0VuYWJsZWQsIGNvbXBvbmVudDtcblx0XHRcdGNvbmZpZy50ZW1wbGF0ZS5pbml0KCBudWxsLCB0aGlzLCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZVxuXHRcdFx0fSApO1xuXHRcdFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuXHRcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG5cdFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcblx0XHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG5cdFx0XHRpZiAoIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50ICkge1xuXHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cdFx0XHRpZiAoIGNvbXBvbmVudCApIHtcblx0XHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIHJlbW92ZSBleGlzdGluZyBmcmFnbWVudCBhbmQgY3JlYXRlIG5ldyBvbmVcblx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuXHRcdFx0XHRyb290OiB0aGlzLFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5yZW5kZXIoIHRoaXMuZWwsIHRoaXMuYW5jaG9yICk7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHR9O1xuXHR9KCBjb25maWcsIEZyYWdtZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmV2ZXJzZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXZlcnNlID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdyZXZlcnNlJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zZXQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2V0ID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzT2JqZWN0LCBub3JtYWxpc2VLZXlwYXRoLCBnZXRNYXRjaGluZ0tleXBhdGhzICkge1xuXG5cdFx0dmFyIHdpbGRjYXJkID0gL1xcKi87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkc2V0KCBrZXlwYXRoLCB2YWx1ZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBtYXAsIHByb21pc2U7XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0Ly8gU2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuXHRcdFx0aWYgKCBpc09iamVjdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRtYXAgPSBrZXlwYXRoO1xuXHRcdFx0XHRjYWxsYmFjayA9IHZhbHVlO1xuXHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIG1hcCApIHtcblx0XHRcdFx0XHRpZiAoIG1hcC5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBtYXBbIGtleXBhdGggXTtcblx0XHRcdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKCB0aGlzLCBrZXlwYXRoICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHR0aGlzJDAudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGlzT2JqZWN0LCBub3JtYWxpc2VLZXlwYXRoLCBnZXRNYXRjaGluZ0tleXBhdGhzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hpZnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hpZnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NoaWZ0JyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zb3J0LmpzICovXG5cdHZhciBSYWN0aXZlJHNvcnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NvcnQnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NwbGljZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzcGxpY2UgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NwbGljZScgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc3VidHJhY3QuanMgKi9cblx0dmFyIFJhY3RpdmUkc3VidHJhY3QgPSBmdW5jdGlvbiggYWRkICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkc3VidHJhY3QoIGtleXBhdGgsIGQgKSB7XG5cdFx0XHRyZXR1cm4gYWRkKCB0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAtMSA6IC1kICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfYWRkICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdGVhcmRvd24uanMgKi9cblx0dmFyIFJhY3RpdmUkdGVhcmRvd24gPSBmdW5jdGlvbiggUHJvbWlzZSApIHtcblxuXHRcdC8vIFRlYXJkb3duLiBUaGlzIGdvZXMgdGhyb3VnaCB0aGUgcm9vdCBmcmFnbWVudCBhbmQgYWxsIGl0cyBjaGlsZHJlbiwgcmVtb3Zpbmcgb2JzZXJ2ZXJzXG5cdFx0Ly8gYW5kIGdlbmVyYWxseSBjbGVhbmluZyB1cCBhZnRlciBpdHNlbGZcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR0ZWFyZG93biggY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZTtcblx0XHRcdHRoaXMuZmlyZSggJ3RlYXJkb3duJyApO1xuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdHRoaXMudmlld21vZGVsLnRlYXJkb3duKCk7XG5cdFx0XHRwcm9taXNlID0gdGhpcy5yZW5kZXJlZCA/IHRoaXMudW5yZW5kZXIoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0Ly8gVE9ETyBkZXByZWNhdGUgdGhpcz9cblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIFByb21pc2UgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90b2dnbGUuanMgKi9cblx0dmFyIFJhY3RpdmUkdG9nZ2xlID0gZnVuY3Rpb24oIGxvZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHRvZ2dsZSgga2V5cGF0aCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0bG9nLmVycm9yT25seSgge1xuXHRcdFx0XHRcdGRlYnVnOiB0aGlzLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NzYWdlOiAnYmFkQXJndW1lbnRzJyxcblx0XHRcdFx0XHRhcmc6IHtcblx0XHRcdFx0XHRcdGFyZ3VtZW50czoga2V5cGF0aFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB0aGlzLmdldCgga2V5cGF0aCApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCBrZXlwYXRoLCAhdmFsdWUsIGNhbGxiYWNrICk7XG5cdFx0fTtcblx0fSggbG9nICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdG9IVE1MLmpzICovXG5cdHZhciBSYWN0aXZlJHRvSFRNTCA9IGZ1bmN0aW9uIFJhY3RpdmUkdG9IVE1MKCkge1xuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCB0cnVlICk7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkdW5yZW5kZXIgPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wLCBjc3MgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR1bnJlbmRlcigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHByb21pc2UsIHNob3VsZERlc3Ryb3k7XG5cdFx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdyYWN0aXZlLnVucmVuZGVyKCkgd2FzIGNhbGxlZCBvbiBhIFJhY3RpdmUgaW5zdGFuY2UgdGhhdCB3YXMgbm90IHJlbmRlcmVkJyApO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQsIGFuZCB0aGUgY29tcG9uZW50IGlzbid0IG1hcmtlZCBmb3IgZGVzdHJ1Y3Rpb24sXG5cdFx0XHQvLyBkb24ndCBkZXRhY2ggbm9kZXMgZnJvbSB0aGUgRE9NIHVubmVjZXNzYXJpbHlcblx0XHRcdHNob3VsZERlc3Ryb3kgPSAhdGhpcy5jb21wb25lbnQgfHwgdGhpcy5jb21wb25lbnQuc2hvdWxkRGVzdHJveTtcblx0XHRcdHNob3VsZERlc3Ryb3kgPSBzaG91bGREZXN0cm95IHx8IHRoaXMuc2hvdWxkRGVzdHJveTtcblx0XHRcdGlmICggdGhpcy5jb25zdHJ1Y3Rvci5jc3MgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y3NzLnJlbW92ZSggdGhpcyQwLmNvbnN0cnVjdG9yICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIENhbmNlbCBhbnkgYW5pbWF0aW9ucyBpbiBwcm9ncmVzc1xuXHRcdFx0d2hpbGUgKCB0aGlzLl9hbmltYXRpb25zWyAwIF0gKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbnNbIDAgXS5zdG9wKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG5cdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wLCBnbG9iYWxfY3NzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdW5zaGlmdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1bnNoaWZ0ID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICd1bnNoaWZ0JyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIFJhY3RpdmUkdXBkYXRlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGUoIGtleXBhdGgsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2U7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleXBhdGggPSBrZXlwYXRoIHx8ICcnO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR0aGlzLmZpcmUoICd1cGRhdGUnLCBrZXlwYXRoICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3VwZGF0ZU1vZGVsLmpzICovXG5cdHZhciBSYWN0aXZlJHVwZGF0ZU1vZGVsID0gZnVuY3Rpb24oIGFycmF5Q29udGVudHNNYXRjaCwgaXNFcXVhbCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZU1vZGVsKCBrZXlwYXRoLCBjYXNjYWRlICkge1xuXHRcdFx0dmFyIHZhbHVlcztcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRrZXlwYXRoID0gJyc7XG5cdFx0XHRcdGNhc2NhZGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCB0aGlzLCBrZXlwYXRoLCB2YWx1ZXMgPSB7fSwgY2FzY2FkZSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCB2YWx1ZXMgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCByYWN0aXZlLCBrZXlwYXRoLCB2YWx1ZXMsIGNhc2NhZGUgKSB7XG5cdFx0XHR2YXIgYmluZGluZ3MsIGNoaWxkRGVwcywgaSwgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjaGVja2JveEdyb3VwcyA9IFtdO1xuXHRcdFx0YmluZGluZ3MgPSByYWN0aXZlLl90d293YXlCaW5kaW5nc1sga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBiaW5kaW5ncyAmJiAoIGkgPSBiaW5kaW5ncy5sZW5ndGggKSApIHtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZSBiaW5kaW5nc1xuXHRcdFx0XHRcdGlmICggYmluZGluZy5yYWRpb05hbWUgJiYgIWJpbmRpbmcuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2hlY2tib3ggbmFtZSBiaW5kaW5ncyBjb21lIGluIGdyb3Vwcywgc29cblx0XHRcdFx0XHQvLyB3ZSB3YW50IHRvIGdldCB0aGUgdmFsdWUgb25jZSBhdCBtb3N0XG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmNoZWNrYm94TmFtZSApIHtcblx0XHRcdFx0XHRcdGlmICggIWNoZWNrYm94R3JvdXBzWyBiaW5kaW5nLmtleXBhdGggXSAmJiAhYmluZGluZy5jaGFuZ2VkKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGNoZWNrYm94R3JvdXBzLnB1c2goIGJpbmRpbmcua2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRjaGVja2JveEdyb3Vwc1sgYmluZGluZy5rZXlwYXRoIF0gPSBiaW5kaW5nO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cdFx0XHRcdFx0aWYgKCBhcnJheUNvbnRlbnRzTWF0Y2goIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWlzRXF1YWwoIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0dmFsdWVzWyBrZXlwYXRoIF0gPSBuZXdWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIEhhbmRsZSBncm91cHMgb2YgYDxpbnB1dCB0eXBlPSdjaGVja2JveCcgbmFtZT0ne3tmb299fScgLi4uPmBcblx0XHRcdGlmICggY2hlY2tib3hHcm91cHMubGVuZ3RoICkge1xuXHRcdFx0XHRjaGVja2JveEdyb3Vwcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHR2YXIgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXHRcdFx0XHRcdGJpbmRpbmcgPSBjaGVja2JveEdyb3Vwc1sga2V5cGF0aCBdO1xuXHRcdFx0XHRcdC8vIG9uZSB0byByZXByZXNlbnQgdGhlIGVudGlyZSBncm91cFxuXHRcdFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cdFx0XHRcdFx0aWYgKCAhYXJyYXlDb250ZW50c01hdGNoKCBvbGRWYWx1ZSwgbmV3VmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdHZhbHVlc1sga2V5cGF0aCBdID0gbmV3VmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFjYXNjYWRlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBjYXNjYWRlXG5cdFx0XHRjaGlsZERlcHMgPSByYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwWyAnZGVmYXVsdCcgXVsga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBjaGlsZERlcHMgKSB7XG5cdFx0XHRcdGkgPSBjaGlsZERlcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRjb25zb2xpZGF0ZUNoYW5nZWRWYWx1ZXMoIHJhY3RpdmUsIGNoaWxkRGVwc1sgaSBdLCB2YWx1ZXMsIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSggYXJyYXlDb250ZW50c01hdGNoLCBpc0VxdWFsICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUuanMgKi9cblx0dmFyIHByb3RvdHlwZSA9IGZ1bmN0aW9uKCBhZGQsIGFuaW1hdGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpcmUsIGdldCwgaW5zZXJ0LCBtZXJnZSwgb2JzZXJ2ZSwgb2ZmLCBvbiwgcG9wLCBwdXNoLCByZW5kZXIsIHJlc2V0LCByZXNldFRlbXBsYXRlLCByZXZlcnNlLCBzZXQsIHNoaWZ0LCBzb3J0LCBzcGxpY2UsIHN1YnRyYWN0LCB0ZWFyZG93biwgdG9nZ2xlLCB0b0hUTUwsIHVucmVuZGVyLCB1bnNoaWZ0LCB1cGRhdGUsIHVwZGF0ZU1vZGVsICkge1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZDogYWRkLFxuXHRcdFx0YW5pbWF0ZTogYW5pbWF0ZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmlyZTogZmlyZSxcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0aW5zZXJ0OiBpbnNlcnQsXG5cdFx0XHRtZXJnZTogbWVyZ2UsXG5cdFx0XHRvYnNlcnZlOiBvYnNlcnZlLFxuXHRcdFx0b2ZmOiBvZmYsXG5cdFx0XHRvbjogb24sXG5cdFx0XHRwb3A6IHBvcCxcblx0XHRcdHB1c2g6IHB1c2gsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHJlc2V0OiByZXNldCxcblx0XHRcdHJlc2V0VGVtcGxhdGU6IHJlc2V0VGVtcGxhdGUsXG5cdFx0XHRyZXZlcnNlOiByZXZlcnNlLFxuXHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRzaGlmdDogc2hpZnQsXG5cdFx0XHRzb3J0OiBzb3J0LFxuXHRcdFx0c3BsaWNlOiBzcGxpY2UsXG5cdFx0XHRzdWJ0cmFjdDogc3VidHJhY3QsXG5cdFx0XHR0ZWFyZG93bjogdGVhcmRvd24sXG5cdFx0XHR0b2dnbGU6IHRvZ2dsZSxcblx0XHRcdHRvSFRNTDogdG9IVE1MLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dW5zaGlmdDogdW5zaGlmdCxcblx0XHRcdHVwZGF0ZTogdXBkYXRlLFxuXHRcdFx0dXBkYXRlTW9kZWw6IHVwZGF0ZU1vZGVsXG5cdFx0fTtcblx0fSggUmFjdGl2ZSRhZGQsIFJhY3RpdmUkYW5pbWF0ZSwgUmFjdGl2ZSRkZXRhY2gsIFJhY3RpdmUkZmluZCwgUmFjdGl2ZSRmaW5kQWxsLCBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzLCBSYWN0aXZlJGZpbmRDb21wb25lbnQsIFJhY3RpdmUkZmlyZSwgUmFjdGl2ZSRnZXQsIFJhY3RpdmUkaW5zZXJ0LCBSYWN0aXZlJG1lcmdlLCBSYWN0aXZlJG9ic2VydmUsIFJhY3RpdmUkb2ZmLCBSYWN0aXZlJG9uLCBSYWN0aXZlJHBvcCwgUmFjdGl2ZSRwdXNoLCBSYWN0aXZlJHJlbmRlciwgUmFjdGl2ZSRyZXNldCwgUmFjdGl2ZSRyZXNldFRlbXBsYXRlLCBSYWN0aXZlJHJldmVyc2UsIFJhY3RpdmUkc2V0LCBSYWN0aXZlJHNoaWZ0LCBSYWN0aXZlJHNvcnQsIFJhY3RpdmUkc3BsaWNlLCBSYWN0aXZlJHN1YnRyYWN0LCBSYWN0aXZlJHRlYXJkb3duLCBSYWN0aXZlJHRvZ2dsZSwgUmFjdGl2ZSR0b0hUTUwsIFJhY3RpdmUkdW5yZW5kZXIsIFJhY3RpdmUkdW5zaGlmdCwgUmFjdGl2ZSR1cGRhdGUsIFJhY3RpdmUkdXBkYXRlTW9kZWwgKTtcblxuXHQvKiB1dGlscy9nZXRHdWlkLmpzICovXG5cdHZhciBnZXRHdWlkID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoIC9beHldL2csIGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0dmFyIHIsIHY7XG5cdFx0XHRyID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcblx0XHRcdHYgPSBjID09ICd4JyA/IHIgOiByICYgMyB8IDg7XG5cdFx0XHRyZXR1cm4gdi50b1N0cmluZyggMTYgKTtcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdXRpbHMvZ2V0TmV4dE51bWJlci5qcyAqL1xuXHR2YXIgZ2V0TmV4dE51bWJlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGkgPSAwO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAnci0nICsgaSsrO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IvcHJvY2Vzc1dyYXBwZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3Byb2Nlc3NXcmFwcGVyID0gZnVuY3Rpb24oIHdyYXBwZXIsIGFycmF5LCBtZXRob2ROYW1lLCBzcGxpY2VTdW1tYXJ5ICkge1xuXHRcdHZhciByb290ID0gd3JhcHBlci5yb290LFxuXHRcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblx0XHQvLyBJZiB0aGlzIGlzIGEgc29ydCBvciByZXZlcnNlLCB3ZSBqdXN0IGRvIHJvb3Quc2V0KCkuLi5cblx0XHQvLyBUT0RPIHVzZSBtZXJnZSBsb2dpYz9cblx0XHRpZiAoIG1ldGhvZE5hbWUgPT09ICdzb3J0JyB8fCBtZXRob2ROYW1lID09PSAncmV2ZXJzZScgKSB7XG5cdFx0XHRyb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIGFycmF5ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggIXNwbGljZVN1bW1hcnkgKSB7XG5cdFx0XHQvLyAocHJlc3VtYWJseSB3ZSB0cmllZCB0byBwb3AgZnJvbSBhbiBhcnJheSBvZiB6ZXJvIGxlbmd0aC5cblx0XHRcdC8vIGluIHdoaWNoIGNhc2UgdGhlcmUncyBub3RoaW5nIHRvIGRvKVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRyb290LnZpZXdtb2RlbC5zcGxpY2UoIGtleXBhdGgsIHNwbGljZVN1bW1hcnkgKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IvcGF0Y2guanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3BhdGNoID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGRlZmluZVByb3BlcnR5LCBnZXRTcGxpY2VFcXVpdmFsZW50LCBzdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24sIHByb2Nlc3NXcmFwcGVyICkge1xuXG5cdFx0dmFyIHBhdGNoZWRBcnJheVByb3RvID0gW10sXG5cdFx0XHRtdXRhdG9yTWV0aG9kcyA9IFtcblx0XHRcdFx0J3BvcCcsXG5cdFx0XHRcdCdwdXNoJyxcblx0XHRcdFx0J3JldmVyc2UnLFxuXHRcdFx0XHQnc2hpZnQnLFxuXHRcdFx0XHQnc29ydCcsXG5cdFx0XHRcdCdzcGxpY2UnLFxuXHRcdFx0XHQndW5zaGlmdCdcblx0XHRcdF0sXG5cdFx0XHR0ZXN0T2JqLCBwYXRjaEFycmF5TWV0aG9kcywgdW5wYXRjaEFycmF5TWV0aG9kcztcblx0XHRtdXRhdG9yTWV0aG9kcy5mb3JFYWNoKCBmdW5jdGlvbiggbWV0aG9kTmFtZSApIHtcblx0XHRcdHZhciBtZXRob2QgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNwbGljZUVxdWl2YWxlbnQsIHNwbGljZVN1bW1hcnksIHJlc3VsdCwgd3JhcHBlciwgaTtcblx0XHRcdFx0Ly8gcHVzaCwgcG9wLCBzaGlmdCBhbmQgdW5zaGlmdCBjYW4gYWxsIGJlIHJlcHJlc2VudGVkIGFzIGEgc3BsaWNlIG9wZXJhdGlvbi5cblx0XHRcdFx0Ly8gdGhpcyBtYWtlcyBsaWZlIGVhc2llciBsYXRlclxuXHRcdFx0XHRzcGxpY2VFcXVpdmFsZW50ID0gZ2V0U3BsaWNlRXF1aXZhbGVudCggdGhpcywgbWV0aG9kTmFtZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICk7XG5cdFx0XHRcdHNwbGljZVN1bW1hcnkgPSBzdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24oIHRoaXMsIHNwbGljZUVxdWl2YWxlbnQgKTtcblx0XHRcdFx0Ly8gYXBwbHkgdGhlIHVuZGVybHlpbmcgbWV0aG9kXG5cdFx0XHRcdHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZVsgbWV0aG9kTmFtZSBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0Ly8gdHJpZ2dlciBjaGFuZ2VzXG5cdFx0XHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IHRydWU7XG5cdFx0XHRcdGkgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0d3JhcHBlciA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnNbIGkgXTtcblx0XHRcdFx0XHRydW5sb29wLnN0YXJ0KCB3cmFwcGVyLnJvb3QgKTtcblx0XHRcdFx0XHRwcm9jZXNzV3JhcHBlciggd3JhcHBlciwgdGhpcywgbWV0aG9kTmFtZSwgc3BsaWNlU3VtbWFyeSApO1xuXHRcdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIHBhdGNoZWRBcnJheVByb3RvLCBtZXRob2ROYW1lLCB7XG5cdFx0XHRcdHZhbHVlOiBtZXRob2Rcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdFx0Ly8gY2FuIHdlIHVzZSBwcm90b3R5cGUgY2hhaW4gaW5qZWN0aW9uP1xuXHRcdC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2hvdy1lY21hc2NyaXB0LTUtc3RpbGwtZG9lcy1ub3QtYWxsb3ctdG8tc3ViY2xhc3MtYW4tYXJyYXkvI3dyYXBwZXJzX3Byb3RvdHlwZV9jaGFpbl9pbmplY3Rpb25cblx0XHR0ZXN0T2JqID0ge307XG5cdFx0aWYgKCB0ZXN0T2JqLl9fcHJvdG9fXyApIHtcblx0XHRcdC8vIHllcywgd2UgY2FuXG5cdFx0XHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0YXJyYXkuX19wcm90b19fID0gcGF0Y2hlZEFycmF5UHJvdG87XG5cdFx0XHR9O1xuXHRcdFx0dW5wYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0YXJyYXkuX19wcm90b19fID0gQXJyYXkucHJvdG90eXBlO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbm8sIHdlIGNhbid0XG5cdFx0XHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0dmFyIGksIG1ldGhvZE5hbWU7XG5cdFx0XHRcdGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG1ldGhvZE5hbWUgPSBtdXRhdG9yTWV0aG9kc1sgaSBdO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KCBhcnJheSwgbWV0aG9kTmFtZSwge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHBhdGNoZWRBcnJheVByb3RvWyBtZXRob2ROYW1lIF0sXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGFycmF5WyBtdXRhdG9yTWV0aG9kc1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHBhdGNoQXJyYXlNZXRob2RzLnVucGF0Y2ggPSB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXHRcdHJldHVybiBwYXRjaEFycmF5TWV0aG9kcztcblx0fSggcnVubG9vcCwgZGVmaW5lUHJvcGVydHksIGdldFNwbGljZUVxdWl2YWxlbnQsIHN1bW1hcmlzZVNwbGljZU9wZXJhdGlvbiwgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcHJvY2Vzc1dyYXBwZXIgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnR5LCBpc0FycmF5LCBwYXRjaCApIHtcblxuXHRcdHZhciBhcnJheUFkYXB0b3IsXG5cdFx0XHQvLyBoZWxwZXJzXG5cdFx0XHRBcnJheVdyYXBwZXIsIGVycm9yTWVzc2FnZTtcblx0XHRhcnJheUFkYXB0b3IgPSB7XG5cdFx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cdFx0XHRcdC8vIHdyYXAgdGhlIGFycmF5IGlmIGEpIGIpIGl0J3MgYW4gYXJyYXksIGFuZCBiKSBlaXRoZXIgaXQgaGFzbid0IGJlZW4gd3JhcHBlZCBhbHJlYWR5LFxuXHRcdFx0XHQvLyBvciB0aGUgYXJyYXkgZGlkbid0IHRyaWdnZXIgdGhlIGdldCgpIGl0c2VsZlxuXHRcdFx0XHRyZXR1cm4gaXNBcnJheSggb2JqZWN0ICkgJiYgKCAhb2JqZWN0Ll9yYWN0aXZlIHx8ICFvYmplY3QuX3JhY3RpdmUuc2V0dGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBBcnJheVdyYXBwZXIoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdC8vIGlmIHRoaXMgYXJyYXkgaGFzbid0IGFscmVhZHkgYmVlbiByYWN0aWZpZWQsIHJhY3RpZnkgaXRcblx0XHRcdGlmICggIWFycmF5Ll9yYWN0aXZlICkge1xuXHRcdFx0XHQvLyBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBfcmFjdGl2ZSBwcm9wZXJ0eSB0byBzdG9yZSB0aGUgd3JhcHBlcnNcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoIGFycmF5LCAnX3JhY3RpdmUnLCB7XG5cdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdHdyYXBwZXJzOiBbXSxcblx0XHRcdFx0XHRcdGluc3RhbmNlczogW10sXG5cdFx0XHRcdFx0XHRzZXR0aW5nOiBmYWxzZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cGF0Y2goIGFycmF5ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdG9yZSB0aGUgcmFjdGl2ZSBpbnN0YW5jZSwgc28gd2UgY2FuIGhhbmRsZSB0cmFuc2l0aW9ucyBsYXRlclxuXHRcdFx0aWYgKCAhYXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzWyByYWN0aXZlLl9ndWlkIF0gKSB7XG5cdFx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdID0gMDtcblx0XHRcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzLnB1c2goIHJhY3RpdmUgKTtcblx0XHRcdH1cblx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdICs9IDE7XG5cdFx0XHRhcnJheS5fcmFjdGl2ZS53cmFwcGVycy5wdXNoKCB0aGlzICk7XG5cdFx0fTtcblx0XHRBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXJyYXksIHN0b3JhZ2UsIHdyYXBwZXJzLCBpbnN0YW5jZXMsIGluZGV4O1xuXHRcdFx0XHRhcnJheSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdHN0b3JhZ2UgPSBhcnJheS5fcmFjdGl2ZTtcblx0XHRcdFx0d3JhcHBlcnMgPSBzdG9yYWdlLndyYXBwZXJzO1xuXHRcdFx0XHRpbnN0YW5jZXMgPSBzdG9yYWdlLmluc3RhbmNlcztcblx0XHRcdFx0Ly8gaWYgdGVhcmRvd24oKSB3YXMgaW52b2tlZCBiZWNhdXNlIHdlJ3JlIGNsZWFyaW5nIHRoZSBjYWNoZSBhcyBhIHJlc3VsdCBvZlxuXHRcdFx0XHQvLyBhIGNoYW5nZSB0aGF0IHRoZSBhcnJheSBpdHNlbGYgdHJpZ2dlcmVkLCB3ZSBjYW4gc2F2ZSBvdXJzZWx2ZXMgdGhlIHRlYXJkb3duXG5cdFx0XHRcdC8vIGFuZCBpbW1lZGlhdGUgc2V0dXBcblx0XHRcdFx0aWYgKCBzdG9yYWdlLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdyYXBwZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0Ly8gaWYgbm90aGluZyBlbHNlIGRlcGVuZHMgb24gdGhpcyBhcnJheSwgd2UgY2FuIHJldmVydCBpdCB0byBpdHNcblx0XHRcdFx0Ly8gbmF0dXJhbCBzdGF0ZVxuXHRcdFx0XHRpZiAoICF3cmFwcGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGFycmF5Ll9yYWN0aXZlO1xuXHRcdFx0XHRcdHBhdGNoLnVucGF0Y2goIHRoaXMudmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZW1vdmUgcmFjdGl2ZSBpbnN0YW5jZSBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdGluc3RhbmNlc1sgdGhpcy5yb290Ll9ndWlkIF0gLT0gMTtcblx0XHRcdFx0XHRpZiAoICFpbnN0YW5jZXNbIHRoaXMucm9vdC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBpbnN0YW5jZXMuaW5kZXhPZiggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvck1lc3NhZ2UgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGluc3RhbmNlcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRlcnJvck1lc3NhZ2UgPSAnU29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gYSByYXRoZXIgaW50ZXJlc3Rpbmcgd2F5Jztcblx0XHRyZXR1cm4gYXJyYXlBZGFwdG9yO1xuXHR9KCBkZWZpbmVQcm9wZXJ0eSwgaXNBcnJheSwgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcGF0Y2ggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9tYWdpY0FycmF5QWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9tYWdpY0FycmF5QWRhcHRvciA9IGZ1bmN0aW9uKCBtYWdpY0FkYXB0b3IsIGFycmF5QWRhcHRvciApIHtcblxuXHRcdHZhciBtYWdpY0FycmF5QWRhcHRvciwgTWFnaWNBcnJheVdyYXBwZXI7XG5cdFx0aWYgKCBtYWdpY0FkYXB0b3IgKSB7XG5cdFx0XHRtYWdpY0FycmF5QWRhcHRvciA9IHtcblx0XHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkge1xuXHRcdFx0XHRcdHJldHVybiBtYWdpY0FkYXB0b3IuZmlsdGVyKCBvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUgKSAmJiBhcnJheUFkYXB0b3IuZmlsdGVyKCBvYmplY3QgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JhcDogZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgTWFnaWNBcnJheVdyYXBwZXIoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRNYWdpY0FycmF5V3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXHRcdFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5tYWdpY1dyYXBwZXIgPSBtYWdpY0FkYXB0b3Iud3JhcCggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5hcnJheVdyYXBwZXIgPSBhcnJheUFkYXB0b3Iud3JhcCggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdH07XG5cdFx0XHRNYWdpY0FycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLmFycmF5V3JhcHBlci50ZWFyZG93bigpO1xuXHRcdFx0XHRcdHRoaXMubWFnaWNXcmFwcGVyLnRlYXJkb3duKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubWFnaWNXcmFwcGVyLnJlc2V0KCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gbWFnaWNBcnJheUFkYXB0b3I7XG5cdH0oIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yLCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvciApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvYWRhcHQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhZGFwdCA9IGZ1bmN0aW9uKCBjb25maWcsIGFycmF5QWRhcHRvciwgbWFnaWNBZGFwdG9yLCBtYWdpY0FycmF5QWRhcHRvciApIHtcblxuXHRcdHZhciBwcmVmaXhlcnMgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJGFkYXB0KCBrZXlwYXRoLCB2YWx1ZSApIHtcblx0XHRcdHZhciByYWN0aXZlID0gdGhpcy5yYWN0aXZlLFxuXHRcdFx0XHRsZW4sIGksIGFkYXB0b3IsIHdyYXBwZWQ7XG5cdFx0XHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG5cdFx0XHRsZW4gPSByYWN0aXZlLmFkYXB0Lmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGFkYXB0b3IgPSByYWN0aXZlLmFkYXB0WyBpIF07XG5cdFx0XHRcdC8vIEFkYXB0b3JzIGNhbiBiZSBzcGVjaWZpZWQgYXMgZS5nLiBbICdCYWNrYm9uZS5Nb2RlbCcsICdCYWNrYm9uZS5Db2xsZWN0aW9uJyBdIC1cblx0XHRcdFx0Ly8gd2UgbmVlZCB0byBnZXQgdGhlIGFjdHVhbCBhZGFwdG9yIGlmIHRoYXQncyB0aGUgY2FzZVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBhZGFwdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR2YXIgZm91bmQgPSBjb25maWcucmVnaXN0cmllcy5hZGFwdG9ycy5maW5kKCByYWN0aXZlLCBhZGFwdG9yICk7XG5cdFx0XHRcdFx0aWYgKCAhZm91bmQgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNaXNzaW5nIGFkYXB0b3IgXCInICsgYWRhcHRvciArICdcIicgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YWRhcHRvciA9IHJhY3RpdmUuYWRhcHRbIGkgXSA9IGZvdW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0d3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gYWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCwgZ2V0UHJlZml4ZXIoIGtleXBhdGggKSApO1xuXHRcdFx0XHRcdHdyYXBwZWQudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcmFjdGl2ZS5tYWdpYyApIHtcblx0XHRcdFx0aWYgKCBtYWdpY0FycmF5QWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBtYWdpY0FycmF5QWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYWdpY0FkYXB0b3IuZmlsdGVyKCB2YWx1ZSwga2V5cGF0aCwgcmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gbWFnaWNBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHJhY3RpdmUubW9kaWZ5QXJyYXlzICYmIGFycmF5QWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gYXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByZWZpeEtleXBhdGgoIG9iaiwgcHJlZml4ICkge1xuXHRcdFx0dmFyIHByZWZpeGVkID0ge30sXG5cdFx0XHRcdGtleTtcblx0XHRcdGlmICggIXByZWZpeCApIHtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH1cblx0XHRcdHByZWZpeCArPSAnLic7XG5cdFx0XHRmb3IgKCBrZXkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIG9iai5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0cHJlZml4ZWRbIHByZWZpeCArIGtleSBdID0gb2JqWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZWZpeGVkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFByZWZpeGVyKCByb290S2V5cGF0aCApIHtcblx0XHRcdHZhciByb290RG90O1xuXHRcdFx0aWYgKCAhcHJlZml4ZXJzWyByb290S2V5cGF0aCBdICkge1xuXHRcdFx0XHRyb290RG90ID0gcm9vdEtleXBhdGggPyByb290S2V5cGF0aCArICcuJyA6ICcnO1xuXHRcdFx0XHRwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF0gPSBmdW5jdGlvbiggcmVsYXRpdmVLZXlwYXRoLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgb2JqO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRvYmogPSB7fTtcblx0XHRcdFx0XHRcdG9ialsgcm9vdERvdCArIHJlbGF0aXZlS2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiByZWxhdGl2ZUtleXBhdGggPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRcdFx0Ly8gJ3JlbGF0aXZlS2V5cGF0aCcgaXMgaW4gZmFjdCBhIGhhc2gsIG5vdCBhIGtleXBhdGhcblx0XHRcdFx0XHRcdHJldHVybiByb290RG90ID8gcHJlZml4S2V5cGF0aCggcmVsYXRpdmVLZXlwYXRoLCByb290S2V5cGF0aCApIDogcmVsYXRpdmVLZXlwYXRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF07XG5cdFx0fVxuXHR9KCBjb25maWcsIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yLCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciwgdmlld21vZGVsJGdldF9tYWdpY0FycmF5QWRhcHRvciApO1xuXG5cdC8qIHZpZXdtb2RlbC9oZWxwZXJzL2dldFVwc3RyZWFtQ2hhbmdlcy5qcyAqL1xuXHR2YXIgZ2V0VXBzdHJlYW1DaGFuZ2VzID0gZnVuY3Rpb24gZ2V0VXBzdHJlYW1DaGFuZ2VzKCBjaGFuZ2VzICkge1xuXHRcdHZhciB1cHN0cmVhbUNoYW5nZXMgPSBbICcnIF0sXG5cdFx0XHRpLCBrZXlwYXRoLCBrZXlzLCB1cHN0cmVhbUtleXBhdGg7XG5cdFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0a2V5cGF0aCA9IGNoYW5nZXNbIGkgXTtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHdoaWxlICgga2V5cy5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHR1cHN0cmVhbUtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRpZiAoIHVwc3RyZWFtQ2hhbmdlcy5pbmRleE9mKCB1cHN0cmVhbUtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLnB1c2goIHVwc3RyZWFtS2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1cHN0cmVhbUNoYW5nZXM7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMvZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmpzICovXG5cdHZhciB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN0YXJNYXBzID0ge307XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGtleXBhdGggc3VjaCBhcyAnZm9vLmJhci5iYXonLCBhbmQgcmV0dXJuc1xuXHRcdC8vIGFsbCB0aGUgdmFyaWFudHMgb2YgdGhhdCBrZXlwYXRoIHRoYXQgaW5jbHVkZSBhIHdpbGRjYXJkIGluIHBsYWNlXG5cdFx0Ly8gb2YgYSBrZXksIHN1Y2ggYXMgJ2Zvby5iYXIuKicsICdmb28uKi5iYXonLCAnZm9vLiouKicgYW5kIHNvIG9uLlxuXHRcdC8vIFRoZXNlIGFyZSB0aGVuIGNoZWNrZWQgYWdhaW5zdCB0aGUgZGVwZW5kYW50cyBtYXAgKHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXApXG5cdFx0Ly8gdG8gc2VlIGlmIGFueSBwYXR0ZXJuIG9ic2VydmVycyBhcmUgZG93bnN0cmVhbSBvZiBvbmUgb3IgbW9yZSBvZlxuXHRcdC8vIHRoZXNlIHdpbGRjYXJkIGtleXBhdGhzIChlLmcuICdmb28uYmFyLiouc3RhdHVzJylcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXMsIHN0YXJNYXAsIG1hcHBlciwgcmVzdWx0O1xuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0c3Rhck1hcCA9IGdldFN0YXJNYXAoIGtleXMubGVuZ3RoICk7XG5cdFx0XHRtYXBwZXIgPSBmdW5jdGlvbiggc3RhciwgaSApIHtcblx0XHRcdFx0cmV0dXJuIHN0YXIgPyAnKicgOiBrZXlzWyBpIF07XG5cdFx0XHR9O1xuXHRcdFx0cmVzdWx0ID0gc3Rhck1hcC5tYXAoIGZ1bmN0aW9uKCBtYXNrICkge1xuXHRcdFx0XHRyZXR1cm4gbWFzay5tYXAoIG1hcHBlciApLmpvaW4oICcuJyApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdGhlIHBvc3NpYmxlIHRydWUvZmFsc2UgY29tYmluYXRpb25zIGZvclxuXHRcdC8vIGEgZ2l2ZW4gbnVtYmVyIC0gZS5nLiBmb3IgdHdvLCB0aGUgcG9zc2libGUgY29tYmluYXRpb25zIGFyZVxuXHRcdC8vIFsgdHJ1ZSwgdHJ1ZSBdLCBbIHRydWUsIGZhbHNlIF0sIFsgZmFsc2UsIHRydWUgXSwgWyBmYWxzZSwgZmFsc2UgXS5cblx0XHQvLyBJdCBkb2VzIHNvIGJ5IGdldHRpbmcgYWxsIHRoZSBiaW5hcnkgdmFsdWVzIGJldHdlZW4gMCBhbmQgZS5nLiAxMVxuXHRcdGZ1bmN0aW9uIGdldFN0YXJNYXAoIGxlbmd0aCApIHtcblx0XHRcdHZhciBvbmVzID0gJycsXG5cdFx0XHRcdG1heCwgYmluYXJ5LCBzdGFyTWFwLCBtYXBwZXIsIGk7XG5cdFx0XHRpZiAoICFzdGFyTWFwc1sgbGVuZ3RoIF0gKSB7XG5cdFx0XHRcdHN0YXJNYXAgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBvbmVzLmxlbmd0aCA8IGxlbmd0aCApIHtcblx0XHRcdFx0XHRvbmVzICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4ID0gcGFyc2VJbnQoIG9uZXMsIDIgKTtcblx0XHRcdFx0bWFwcGVyID0gZnVuY3Rpb24oIGRpZ2l0ICkge1xuXHRcdFx0XHRcdHJldHVybiBkaWdpdCA9PT0gJzEnO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8PSBtYXg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRiaW5hcnkgPSBpLnRvU3RyaW5nKCAyICk7XG5cdFx0XHRcdFx0d2hpbGUgKCBiaW5hcnkubGVuZ3RoIDwgbGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0YmluYXJ5ID0gJzAnICsgYmluYXJ5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGFyTWFwWyBpIF0gPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoIGJpbmFyeSwgbWFwcGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3Rhck1hcHNbIGxlbmd0aCBdID0gc3Rhck1hcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdGFyTWFwc1sgbGVuZ3RoIF07XG5cdFx0fVxuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMvbm90aWZ5UGF0dGVybk9ic2VydmVycy5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzID0gZnVuY3Rpb24oIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyApIHtcblxuXHRcdHZhciBsYXN0S2V5ID0gL1teXFwuXSskLztcblx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycztcblxuXHRcdGZ1bmN0aW9uIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwga2V5cGF0aCwgb25seURpcmVjdCApIHtcblx0XHRcdHZhciBwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cdFx0XHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwga2V5cGF0aCApO1xuXHRcdFx0aWYgKCBvbmx5RGlyZWN0ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGtleXBhdGggKTtcblx0XHRcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcy5mb3JFYWNoKCBmdW5jdGlvbiggdXBzdHJlYW1QYXR0ZXJuICkge1xuXHRcdFx0XHRjYXNjYWRlKCB2aWV3bW9kZWwsIHVwc3RyZWFtUGF0dGVybiwga2V5cGF0aCApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhc2NhZGUoIHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGdyb3VwLCBtYXAsIGFjdHVhbENoaWxkS2V5cGF0aDtcblx0XHRcdGdyb3VwID0gdmlld21vZGVsLmRlcHNNYXAucGF0dGVybk9ic2VydmVycztcblx0XHRcdG1hcCA9IGdyb3VwWyB1cHN0cmVhbVBhdHRlcm4gXTtcblx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRtYXAuZm9yRWFjaCggZnVuY3Rpb24oIGNoaWxkS2V5cGF0aCApIHtcblx0XHRcdFx0XHR2YXIga2V5ID0gbGFzdEtleS5leGVjKCBjaGlsZEtleXBhdGggKVsgMCBdO1xuXHRcdFx0XHRcdC8vICdiYXonXG5cdFx0XHRcdFx0YWN0dWFsQ2hpbGRLZXlwYXRoID0ga2V5cGF0aCA/IGtleXBhdGggKyAnLicgKyBrZXkgOiBrZXk7XG5cdFx0XHRcdFx0Ly8gJ2Zvby5iYXIuYmF6J1xuXHRcdFx0XHRcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBhY3R1YWxDaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHRjYXNjYWRlKCB2aWV3bW9kZWwsIGNoaWxkS2V5cGF0aCwgYWN0dWFsQ2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBvYnNlcnZlciApIHtcblx0XHRcdFx0aWYgKCBvYnNlcnZlci5yZWdleC50ZXN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0b2JzZXJ2ZXIudXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdH0oIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhcHBseUNoYW5nZXMgPSBmdW5jdGlvbiggZ2V0VXBzdHJlYW1DaGFuZ2VzLCBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzICkge1xuXG5cdFx0dmFyIGRlcGVuZGFudEdyb3VwcyA9IFtcblx0XHRcdCdvYnNlcnZlcnMnLFxuXHRcdFx0J2RlZmF1bHQnXG5cdFx0XTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJGFwcGx5Q2hhbmdlcygpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRjaGFuZ2VzLCB1cHN0cmVhbUNoYW5nZXMsIGFsbENoYW5nZXMgPSBbXSxcblx0XHRcdFx0Y29tcHV0YXRpb25zLCBhZGRDb21wdXRhdGlvbnMsIGNhc2NhZGUsIGhhc2ggPSB7fTtcblx0XHRcdGlmICggIXRoaXMuY2hhbmdlcy5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIFRPRE8gd2UgZW5kIHVwIGhlcmUgb24gaW5pdGlhbCByZW5kZXIuIFBlcmhhcHMgd2Ugc2hvdWxkbid0P1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRhZGRDb21wdXRhdGlvbnMgPSBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG5ld0NvbXB1dGF0aW9ucztcblx0XHRcdFx0aWYgKCBuZXdDb21wdXRhdGlvbnMgPSBzZWxmLmRlcHMuY29tcHV0ZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRhZGROZXdJdGVtcyggY29tcHV0YXRpb25zLCBuZXdDb21wdXRhdGlvbnMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGNhc2NhZGUgPSBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG1hcDtcblx0XHRcdFx0YWRkQ29tcHV0YXRpb25zKCBrZXlwYXRoICk7XG5cdFx0XHRcdGlmICggbWFwID0gc2VsZi5kZXBzTWFwLmNvbXB1dGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0bWFwLmZvckVhY2goIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdC8vIEZpbmQgY29tcHV0YXRpb25zIGFuZCBldmFsdWF0b3JzIHRoYXQgYXJlIGludmFsaWRhdGVkIGJ5XG5cdFx0XHQvLyB0aGVzZSBjaGFuZ2VzLiBJZiB0aGV5IGhhdmUgY2hhbmdlZCwgYWRkIHRoZW0gdG8gdGhlXG5cdFx0XHQvLyBsaXN0IG9mIGNoYW5nZXMuIExhdGhlciwgcmluc2UgYW5kIHJlcGVhdCB1bnRpbCB0aGVcblx0XHRcdC8vIHN5c3RlbSBpcyBzZXR0bGVkXG5cdFx0XHRkbyB7XG5cdFx0XHRcdGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG5cdFx0XHRcdGFkZE5ld0l0ZW1zKCBhbGxDaGFuZ2VzLCBjaGFuZ2VzICk7XG5cdFx0XHRcdHRoaXMuY2hhbmdlcyA9IFtdO1xuXHRcdFx0XHRjb21wdXRhdGlvbnMgPSBbXTtcblx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzID0gZ2V0VXBzdHJlYW1DaGFuZ2VzKCBjaGFuZ2VzICk7XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBhZGRDb21wdXRhdGlvbnMgKTtcblx0XHRcdFx0Y2hhbmdlcy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHRcdGNvbXB1dGF0aW9ucy5mb3JFYWNoKCB1cGRhdGVDb21wdXRhdGlvbiApO1xuXHRcdFx0fSB3aGlsZSAoIHRoaXMuY2hhbmdlcy5sZW5ndGggKTtcblx0XHRcdHVwc3RyZWFtQ2hhbmdlcyA9IGdldFVwc3RyZWFtQ2hhbmdlcyggYWxsQ2hhbmdlcyApO1xuXHRcdFx0Ly8gUGF0dGVybiBvYnNlcnZlcnMgYXJlIGEgd2VpcmQgc3BlY2lhbCBjYXNlXG5cdFx0XHRpZiAoIHRoaXMucGF0dGVybk9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdGhpcyQwLCBrZXlwYXRoLCB0cnVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0YWxsQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdGhpcyQwLCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlcGVuZGFudEdyb3Vwcy5mb3JFYWNoKCBmdW5jdGlvbiggZ3JvdXAgKSB7XG5cdFx0XHRcdGlmICggIXRoaXMkMC5kZXBzWyBncm91cCBdICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyggdGhpcyQwLCBrZXlwYXRoLCBncm91cCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG5vdGlmeUFsbERlcGVuZGFudHMoIHRoaXMkMCwgYWxsQ2hhbmdlcywgZ3JvdXAgKTtcblx0XHRcdH0gKTtcblx0XHRcdC8vIFJldHVybiBhIGhhc2ggb2Yga2V5cGF0aHMgdG8gdXBkYXRlZCB2YWx1ZXNcblx0XHRcdGFsbENoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdGhhc2hbIGtleXBhdGggXSA9IHRoaXMkMC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlQ29tcHV0YXRpb24oIGNvbXB1dGF0aW9uICkge1xuXHRcdFx0Y29tcHV0YXRpb24udXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBkZXBlbmRhbnRzLCB2YWx1ZTtcblx0XHRcdGlmICggZGVwZW5kYW50cyA9IGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0ZGVwZW5kYW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZC5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdGlmeUFsbERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aHMsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdFx0YWRkS2V5cGF0aHMoIGtleXBhdGhzICk7XG5cdFx0XHRxdWV1ZS5mb3JFYWNoKCBkaXNwYXRjaCApO1xuXG5cdFx0XHRmdW5jdGlvbiBhZGRLZXlwYXRocygga2V5cGF0aHMgKSB7XG5cdFx0XHRcdGtleXBhdGhzLmZvckVhY2goIGFkZEtleXBhdGggKTtcblx0XHRcdFx0a2V5cGF0aHMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhZGRLZXlwYXRoKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgZGVwcyA9IGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApO1xuXHRcdFx0XHRpZiAoIGRlcHMgKSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCgge1xuXHRcdFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aCxcblx0XHRcdFx0XHRcdGRlcHM6IGRlcHNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FzY2FkZSgga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGNoaWxkRGVwcztcblx0XHRcdFx0aWYgKCBjaGlsZERlcHMgPSB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXBOYW1lIF1bIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRhZGRLZXlwYXRocyggY2hpbGREZXBzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZGlzcGF0Y2goIHNldCApIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdmlld21vZGVsLmdldCggc2V0LmtleXBhdGggKTtcblx0XHRcdFx0c2V0LmRlcHMuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5kRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB2aWV3bW9kZWwuZGVwc1sgZ3JvdXBOYW1lIF07XG5cdFx0XHRyZXR1cm4gZ3JvdXAgPyBncm91cFsga2V5cGF0aCBdIDogbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGROZXdJdGVtcyggYXJyLCBpdGVtcyApIHtcblx0XHRcdGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRpZiAoIGFyci5pbmRleE9mKCBpdGVtICkgPT09IC0xICkge1xuXHRcdFx0XHRcdGFyci5wdXNoKCBpdGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdH0oIGdldFVwc3RyZWFtQ2hhbmdlcywgdmlld21vZGVsJGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9jYXB0dXJlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkY2FwdHVyZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRjYXB0dXJlKCkge1xuXHRcdHRoaXMuY2FwdHVyaW5nID0gdHJ1ZTtcblx0XHR0aGlzLmNhcHR1cmVkID0gW107XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9jbGVhckNhY2hlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRjbGVhckNhY2hlKCBrZXlwYXRoLCBkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdHZhciBjYWNoZU1hcCwgd3JhcHBlciwgY29tcHV0YXRpb247XG5cdFx0aWYgKCAhZG9udFRlYXJkb3duV3JhcHBlciApIHtcblx0XHRcdC8vIElzIHRoZXJlIGEgd3JhcHBlZCBwcm9wZXJ0eSBhdCB0aGlzIGtleXBhdGg/XG5cdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0Ly8gRGlkIHdlIHVud3JhcCBpdD9cblx0XHRcdFx0aWYgKCB3cmFwcGVyLnRlYXJkb3duKCkgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNbIGtleXBhdGggXSApIHtcblx0XHRcdGNvbXB1dGF0aW9uLmNvbXB1dGUoKTtcblx0XHR9XG5cdFx0dGhpcy5jYWNoZVsga2V5cGF0aCBdID0gdW5kZWZpbmVkO1xuXHRcdGlmICggY2FjaGVNYXAgPSB0aGlzLmNhY2hlTWFwWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHR3aGlsZSAoIGNhY2hlTWFwLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5jbGVhckNhY2hlKCBjYWNoZU1hcC5wb3AoKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9GQUlMRURfTE9PS1VQLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X0ZBSUxFRF9MT09LVVAgPSB7XG5cdFx0RkFJTEVEX0xPT0tVUDogdHJ1ZVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXksIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHR2YXIgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uKCB2aWV3bW9kZWwsIGtleXBhdGggKSB7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblx0XHRcdHRoaXMucm9vdCA9IHZpZXdtb2RlbC5yYWN0aXZlO1xuXHRcdFx0Ly8gVE9ETyBlbGltaW5hdGUgdGhpc1xuXHRcdFx0dGhpcy5yZWYgPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVtcHR5O1xuXHRcdFx0dmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sga2V5cGF0aCBdID0gdHJ1ZTtcblx0XHRcdHZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucHVzaCggdGhpcyApO1xuXHRcdFx0cnVubG9vcC5hZGRVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0fTtcblx0XHRVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LnByb3RvdHlwZSA9IHtcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCB0aGlzLnJlZiApO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXNbIHRoaXMucmVmIF0gPSBmYWxzZTtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3k7XG5cdH0oIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0ID0gZnVuY3Rpb24oIEZBSUxFRF9MT09LVVAsIFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgKSB7XG5cblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJGdldCgga2V5cGF0aCApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSBlbXB0eTtcblx0XHRcdHZhciByYWN0aXZlID0gdGhpcy5yYWN0aXZlLFxuXHRcdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUsXG5cdFx0XHRcdHZhbHVlLCBjb21wdXRhdGlvbiwgd3JhcHBlZCwgZXZhbHVhdG9yO1xuXHRcdFx0aWYgKCBjYWNoZVsga2V5cGF0aCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIElzIHRoaXMgYSBjb21wdXRlZCBwcm9wZXJ0eT9cblx0XHRcdFx0aWYgKCBjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggd3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGFwdCggJycsIHJhY3RpdmUuZGF0YSApO1xuXHRcdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS5kYXRhO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBldmFsdWF0b3IgPSB0aGlzLmV2YWx1YXRvcnNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGV2YWx1YXRvci52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJldHJpZXZlKCB0aGlzLCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FjaGVbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSBjYWNoZVsga2V5cGF0aCBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLmV2YWx1YXRlV3JhcHBlZCAmJiAoIHdyYXBwZWQgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjYXB0dXJlIHRoZSBrZXlwYXRoLCBpZiB3ZSdyZSBpbnNpZGUgYSBjb21wdXRhdGlvbiBvciBldmFsdWF0b3Jcblx0XHRcdGlmICggb3B0aW9ucy5jYXB0dXJlICYmIHRoaXMuY2FwdHVyaW5nICYmIHRoaXMuY2FwdHVyZWQuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0dGhpcy5jYXB0dXJlZC5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHRcdC8vIGlmIHdlIGNvdWxkbid0IHJlc29sdmUgdGhlIGtleXBhdGgsIHdlIG5lZWQgdG8gbWFrZSBpdCBhcyBhIGZhaWxlZFxuXHRcdFx0XHQvLyBsb29rdXAsIHNvIHRoYXQgdGhlIGV2YWx1YXRvciB1cGRhdGVzIGNvcnJlY3RseSBvbmNlIHdlIENBTlxuXHRcdFx0XHQvLyByZXNvbHZlIHRoZSBrZXlwYXRoXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgJiYgdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXNbIGtleXBhdGggXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRuZXcgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSggdGhpcywga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgPyB2b2lkIDAgOiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmV0cmlldmUoIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHZhciBrZXlzLCBrZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCBjYWNoZU1hcCwgdmFsdWUsIHdyYXBwZWQ7XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRrZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoIHBhcmVudEtleXBhdGggKTtcblx0XHRcdGlmICggd3JhcHBlZCA9IHZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gd3JhcHBlZC5nZXQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyZW50VmFsdWUgPT09IG51bGwgfHwgcGFyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGNhY2hlIG1hcFxuXHRcdFx0aWYgKCAhKCBjYWNoZU1hcCA9IHZpZXdtb2RlbC5jYWNoZU1hcFsgcGFyZW50S2V5cGF0aCBdICkgKSB7XG5cdFx0XHRcdHZpZXdtb2RlbC5jYWNoZU1hcFsgcGFyZW50S2V5cGF0aCBdID0gWyBrZXlwYXRoIF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGNhY2hlTWFwLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0Y2FjaGVNYXAucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIHdlIHJldHVybiBhIHNlbnRpbmVsIHZhbHVlXG5cdFx0XHQvLyBzbyB0aGF0IHdlIGtub3cgdG8gcXVlcnkgcGFyZW50IHNjb3BlIChpZiBzdWNoIHRoZXJlIGJlKVxuXHRcdFx0aWYgKCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdvYmplY3QnICYmICEoIGtleSBpbiBwYXJlbnRWYWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdmlld21vZGVsLmNhY2hlWyBrZXlwYXRoIF0gPSBGQUlMRURfTE9PS1VQO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSBwYXJlbnRWYWx1ZVsga2V5IF07XG5cdFx0XHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG5cdFx0XHR2aWV3bW9kZWwuYWRhcHQoIGtleXBhdGgsIHZhbHVlLCBmYWxzZSApO1xuXHRcdFx0Ly8gVXBkYXRlIGNhY2hlXG5cdFx0XHR2aWV3bW9kZWwuY2FjaGVbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fSggdmlld21vZGVsJGdldF9GQUlMRURfTE9PS1VQLCB2aWV3bW9kZWwkZ2V0X1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL21hcmsuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtYXJrID0gZnVuY3Rpb24gVmlld21vZGVsJG1hcmsoIGtleXBhdGgsIGlzSW1wbGljaXRDaGFuZ2UgKSB7XG5cdFx0Ly8gaW1wbGljaXQgY2hhbmdlcyAoaS5lLiBgZm9vLmxlbmd0aGAgb24gYHJhY3RpdmUucHVzaCgnZm9vJyw0MilgKVxuXHRcdC8vIHNob3VsZCBub3QgYmUgcGlja2VkIHVwIGJ5IHBhdHRlcm4gb2JzZXJ2ZXJzXG5cdFx0aWYgKCBpc0ltcGxpY2l0Q2hhbmdlICkge1xuXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXNbIGtleXBhdGggXSA9IHRydWU7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5jaGFuZ2VzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHR0aGlzLmNoYW5nZXMucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0dGhpcy5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvbWVyZ2UvbWFwT2xkVG9OZXdJbmRleC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJG1lcmdlX21hcE9sZFRvTmV3SW5kZXggPSBmdW5jdGlvbiggb2xkQXJyYXksIG5ld0FycmF5ICkge1xuXHRcdHZhciB1c2VkSW5kaWNlcywgZmlyc3RVbnVzZWRJbmRleCwgbmV3SW5kaWNlcywgY2hhbmdlZDtcblx0XHR1c2VkSW5kaWNlcyA9IHt9O1xuXHRcdGZpcnN0VW51c2VkSW5kZXggPSAwO1xuXHRcdG5ld0luZGljZXMgPSBvbGRBcnJheS5tYXAoIGZ1bmN0aW9uKCBpdGVtLCBpICkge1xuXHRcdFx0dmFyIGluZGV4LCBzdGFydCwgbGVuO1xuXHRcdFx0c3RhcnQgPSBmaXJzdFVudXNlZEluZGV4O1xuXHRcdFx0bGVuID0gbmV3QXJyYXkubGVuZ3RoO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpbmRleCA9IG5ld0FycmF5LmluZGV4T2YoIGl0ZW0sIHN0YXJ0ICk7XG5cdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydCA9IGluZGV4ICsgMTtcblx0XHRcdH0gd2hpbGUgKCB1c2VkSW5kaWNlc1sgaW5kZXggXSAmJiBzdGFydCA8IGxlbiApO1xuXHRcdFx0Ly8ga2VlcCB0cmFjayBvZiB0aGUgZmlyc3QgdW51c2VkIGluZGV4LCBzbyB3ZSBkb24ndCBzZWFyY2hcblx0XHRcdC8vIHRoZSB3aG9sZSBvZiBuZXdBcnJheSBmb3IgZWFjaCBpdGVtIGluIG9sZEFycmF5IHVubmVjZXNzYXJpbHlcblx0XHRcdGlmICggaW5kZXggPT09IGZpcnN0VW51c2VkSW5kZXggKSB7XG5cdFx0XHRcdGZpcnN0VW51c2VkSW5kZXggKz0gMTtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggIT09IGkgKSB7XG5cdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dXNlZEluZGljZXNbIGluZGV4IF0gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH0gKTtcblx0XHRuZXdJbmRpY2VzLnVuY2hhbmdlZCA9ICFjaGFuZ2VkO1xuXHRcdHJldHVybiBuZXdJbmRpY2VzO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvbWVyZ2UuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtZXJnZSA9IGZ1bmN0aW9uKCB0eXBlcywgd2FybiwgbWFwT2xkVG9OZXdJbmRleCApIHtcblxuXHRcdHZhciBjb21wYXJhdG9ycyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkbWVyZ2UoIGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBvbGRBcnJheSwgbmV3QXJyYXksIGNvbXBhcmF0b3IsIG5ld0luZGljZXMsIGRlcGVuZGFudHM7XG5cdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmUgKSB7XG5cdFx0XHRcdGNvbXBhcmF0b3IgPSBnZXRDb21wYXJhdG9yRnVuY3Rpb24oIG9wdGlvbnMuY29tcGFyZSApO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5Lm1hcCggY29tcGFyYXRvciApO1xuXHRcdFx0XHRcdG5ld0FycmF5ID0gYXJyYXkubWFwKCBjb21wYXJhdG9yICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0Ly8gZmFsbGJhY2sgdG8gYW4gaWRlbnRpdHkgY2hlY2sgLSB3b3JzdCBjYXNlIHNjZW5hcmlvIHdlIGhhdmVcblx0XHRcdFx0XHQvLyB0byBkbyBtb3JlIERPTSBtYW5pcHVsYXRpb24gdGhhbiB3ZSB0aG91Z2h0Li4uXG5cdFx0XHRcdFx0Ly8gLi4udW5sZXNzIHdlJ3JlIGluIGRlYnVnIG1vZGUgb2YgY291cnNlXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmRlYnVnICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR3YXJuKCAnTWVyZ2Ugb3BlcmF0aW9uOiBjb21wYXJpc29uIGZhaWxlZC4gRmFsbGluZyBiYWNrIHRvIGlkZW50aXR5IGNoZWNraW5nJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcblx0XHRcdFx0XHRuZXdBcnJheSA9IGFycmF5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcblx0XHRcdFx0bmV3QXJyYXkgPSBhcnJheTtcblx0XHRcdH1cblx0XHRcdC8vIGZpbmQgbmV3IGluZGljZXMgZm9yIG1lbWJlcnMgb2Ygb2xkQXJyYXlcblx0XHRcdG5ld0luZGljZXMgPSBtYXBPbGRUb05ld0luZGV4KCBvbGRBcnJheSwgbmV3QXJyYXkgKTtcblx0XHRcdC8vIEluZGljZXMgdGhhdCBhcmUgYmVpbmcgcmVtb3ZlZCBzaG91bGQgYmUgbWFya2VkIGFzIGRpcnR5XG5cdFx0XHRuZXdJbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uKCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHRoaXMkMC5tYXJrKCBrZXlwYXRoICsgJy4nICsgb2xkSW5kZXggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gVXBkYXRlIHRoZSBtb2RlbFxuXHRcdFx0Ly8gVE9ETyBhbGxvdyBleGlzdGluZyBhcnJheSB0byBiZSB1cGRhdGVkIGluIHBsYWNlLCByYXRoZXIgdGhhbiByZXBsYWNlZD9cblx0XHRcdHRoaXMuc2V0KCBrZXlwYXRoLCBhcnJheSwgdHJ1ZSApO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gdGhpcy5kZXBzWyAnZGVmYXVsdCcgXVsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRkZXBlbmRhbnRzLmZpbHRlciggY2FuTWVyZ2UgKS5mb3JFYWNoKCBmdW5jdGlvbiggZGVwZW5kYW50ICkge1xuXHRcdFx0XHRcdHJldHVybiBkZXBlbmRhbnQubWVyZ2UoIG5ld0luZGljZXMgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBjdXJyZW50QXJyYXkubGVuZ3RoICE9PSBhcnJheS5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCArICcubGVuZ3RoJywgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjYW5NZXJnZSggZGVwZW5kYW50ICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBkZXBlbmRhbnQubWVyZ2UgPT09ICdmdW5jdGlvbicgJiYgKCAhZGVwZW5kYW50LnN1YnR5cGUgfHwgZGVwZW5kYW50LnN1YnR5cGUgPT09IHR5cGVzLlNFQ1RJT05fRUFDSCApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0cmluZ2lmeSggaXRlbSApIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggaXRlbSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvbXBhcmF0b3JGdW5jdGlvbiggY29tcGFyYXRvciApIHtcblx0XHRcdC8vIElmIGBjb21wYXJlYCBpcyBgdHJ1ZWAsIHdlIHVzZSBKU09OLnN0cmluZ2lmeSB0byBjb21wYXJlXG5cdFx0XHQvLyBvYmplY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHNoYXBlLCBidXQgbm9uLWlkZW50aWNhbCAtIGkuZS5cblx0XHRcdC8vIHsgZm9vOiAnYmFyJyB9ICE9PSB7IGZvbzogJ2JhcicgfVxuXHRcdFx0aWYgKCBjb21wYXJhdG9yID09PSB0cnVlICkge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGlmICggIWNvbXBhcmF0b3JzWyBjb21wYXJhdG9yIF0gKSB7XG5cdFx0XHRcdFx0Y29tcGFyYXRvcnNbIGNvbXBhcmF0b3IgXSA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW1bIGNvbXBhcmF0b3IgXTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb21wYXJhdG9yc1sgY29tcGFyYXRvciBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGNvbXBhcmF0b3I7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgYGNvbXBhcmVgIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24sIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBpZGVudGlmeWluZyBmaWVsZCAob3IgYHRydWVgIHRvIHVzZSBKU09OLnN0cmluZ2lmeSknICk7XG5cdFx0fVxuXHR9KCB0eXBlcywgd2Fybiwgdmlld21vZGVsJG1lcmdlX21hcE9sZFRvTmV3SW5kZXggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3JlZ2lzdGVyLmpzICovXG5cdHZhciB2aWV3bW9kZWwkcmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkcmVnaXN0ZXIoIGtleXBhdGgsIGRlcGVuZGFudCApIHtcblx0XHRcdHZhciBncm91cCA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0aWYgKCBncm91cCA9PT0gdm9pZCAwIClcblx0XHRcdFx0Z3JvdXAgPSAnZGVmYXVsdCc7XG5cdFx0XHR2YXIgZGVwc0J5S2V5cGF0aCwgZGVwcywgZXZhbHVhdG9yO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnQuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlcHNCeUtleXBhdGggPSB0aGlzLmRlcHNbIGdyb3VwIF0gfHwgKCB0aGlzLmRlcHNbIGdyb3VwIF0gPSB7fSApO1xuXHRcdFx0ZGVwcyA9IGRlcHNCeUtleXBhdGhbIGtleXBhdGggXSB8fCAoIGRlcHNCeUtleXBhdGhbIGtleXBhdGggXSA9IFtdICk7XG5cdFx0XHRkZXBzLnB1c2goIGRlcGVuZGFudCApO1xuXHRcdFx0aWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBldmFsdWF0b3IgPSB0aGlzLmV2YWx1YXRvcnNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0aWYgKCAhZXZhbHVhdG9yLmRlcGVuZGFudHMgKSB7XG5cdFx0XHRcdFx0ZXZhbHVhdG9yLndha2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRldmFsdWF0b3IuZGVwZW5kYW50cyArPSAxO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlRGVwZW5kYW50c01hcCggdGhpcywga2V5cGF0aCwgZ3JvdXAgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlRGVwZW5kYW50c01hcCggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cCApIHtcblx0XHRcdHZhciBrZXlzLCBwYXJlbnRLZXlwYXRoLCBtYXAsIHBhcmVudDtcblx0XHRcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0a2V5cy5wb3AoKTtcblx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cCBdIHx8ICggdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwIF0gPSB7fSApO1xuXHRcdFx0XHRwYXJlbnQgPSBtYXBbIHBhcmVudEtleXBhdGggXSB8fCAoIG1hcFsgcGFyZW50S2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0aWYgKCBwYXJlbnRbIGtleXBhdGggXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdID0gMDtcblx0XHRcdFx0XHRwYXJlbnQucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdICs9IDE7XG5cdFx0XHRcdGtleXBhdGggPSBwYXJlbnRLZXlwYXRoO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvcmVsZWFzZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHJlbGVhc2UgPSBmdW5jdGlvbiBWaWV3bW9kZWwkcmVsZWFzZSgpIHtcblx0XHR0aGlzLmNhcHR1cmluZyA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzLmNhcHR1cmVkO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvc2V0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkc2V0ID0gZnVuY3Rpb24oIGlzRXF1YWwsIGNyZWF0ZUJyYW5jaCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkc2V0KCBrZXlwYXRoLCB2YWx1ZSwgc2lsZW50ICkge1xuXHRcdFx0dmFyIGtleXMsIGxhc3RLZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCBjb21wdXRhdGlvbiwgd3JhcHBlciwgZXZhbHVhdG9yLCBkb250VGVhcmRvd25XcmFwcGVyO1xuXHRcdFx0aWYgKCBpc0VxdWFsKCB0aGlzLmNhY2hlWyBrZXlwYXRoIF0sIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNbIGtleXBhdGggXTtcblx0XHRcdHdyYXBwZXIgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXTtcblx0XHRcdGV2YWx1YXRvciA9IHRoaXMuZXZhbHVhdG9yc1sga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBjb21wdXRhdGlvbiAmJiAhY29tcHV0YXRpb24uc2V0dGluZyApIHtcblx0XHRcdFx0Y29tcHV0YXRpb24uc2V0KCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHdyYXBwZXIgd2l0aCBhIGByZXNldCgpYCBtZXRob2QsIHdlIHRyeSBhbmQgdXNlIGl0LiBJZiB0aGVcblx0XHRcdC8vIGByZXNldCgpYCBtZXRob2QgcmV0dXJucyBmYWxzZSwgdGhlIHdyYXBwZXIgc2hvdWxkIGJlIHRvcm4gZG93biwgYW5kXG5cdFx0XHQvLyAobW9zdCBsaWtlbHkpIGEgbmV3IG9uZSBzaG91bGQgYmUgY3JlYXRlZCBsYXRlclxuXHRcdFx0aWYgKCB3cmFwcGVyICYmIHdyYXBwZXIucmVzZXQgKSB7XG5cdFx0XHRcdGRvbnRUZWFyZG93bldyYXBwZXIgPSB3cmFwcGVyLnJlc2V0KCB2YWx1ZSApICE9PSBmYWxzZTtcblx0XHRcdFx0aWYgKCBkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gVXBkYXRlIGV2YWx1YXRvciB2YWx1ZS4gVGhpcyBtYXkgYmUgZnJvbSB0aGUgZXZhbHVhdG9yIGl0c2VsZiwgb3Jcblx0XHRcdC8vIGl0IG1heSBiZSBmcm9tIHRoZSB3cmFwcGVyIHRoYXQgd3JhcHMgYW4gZXZhbHVhdG9yJ3MgcmVzdWx0IC0gaXRcblx0XHRcdC8vIGRvZXNuJ3QgbWF0dGVyXG5cdFx0XHRpZiAoIGV2YWx1YXRvciApIHtcblx0XHRcdFx0ZXZhbHVhdG9yLnZhbHVlID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFjb21wdXRhdGlvbiAmJiAhZXZhbHVhdG9yICYmICFkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRcdGxhc3RLZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0d3JhcHBlciA9IHRoaXMud3JhcHBlZFsgcGFyZW50S2V5cGF0aCBdO1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIgJiYgd3JhcHBlci5zZXQgKSB7XG5cdFx0XHRcdFx0d3JhcHBlci5zZXQoIGxhc3RLZXksIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVyID8gd3JhcHBlci5nZXQoKSA6IHRoaXMuZ2V0KCBwYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdFx0aWYgKCAhcGFyZW50VmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRwYXJlbnRWYWx1ZSA9IGNyZWF0ZUJyYW5jaCggbGFzdEtleSApO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXQoIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCB0cnVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudFZhbHVlWyBsYXN0S2V5IF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhc2lsZW50ICkge1xuXHRcdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlJ3JlIHNldHRpbmcgYSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHRhcmdldCBrZXlwYXRoIChpLmUuXG5cdFx0XHRcdC8vIGNyZWF0aW5nIGEgZnJlc2ggYnJhbmNoKSAtIHdlIG5lZWQgdG8gY2xlYXIgdGhlIGNhY2hlLCBidXRcblx0XHRcdFx0Ly8gbm90IG1hcmsgaXQgYXMgYSBjaGFuZ2Vcblx0XHRcdFx0dGhpcy5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNFcXVhbCwgY3JlYXRlQnJhbmNoICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9zcGxpY2UuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRzcGxpY2UgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJHNwbGljZSgga2V5cGF0aCwgc3BsaWNlU3VtbWFyeSApIHtcblx0XHRcdHZhciB2aWV3bW9kZWwgPSB0aGlzLFxuXHRcdFx0XHRpLCBkZXBlbmRhbnRzO1xuXHRcdFx0Ly8gTWFyayBjaGFuZ2VkIGtleXBhdGhzXG5cdFx0XHRmb3IgKCBpID0gc3BsaWNlU3VtbWFyeS5yYW5nZVN0YXJ0OyBpIDwgc3BsaWNlU3VtbWFyeS5yYW5nZUVuZDsgaSArPSAxICkge1xuXHRcdFx0XHR2aWV3bW9kZWwubWFyaygga2V5cGF0aCArICcuJyArIGkgKTtcblx0XHRcdH1cblx0XHRcdGlmICggc3BsaWNlU3VtbWFyeS5iYWxhbmNlICkge1xuXHRcdFx0XHR2aWV3bW9kZWwubWFyaygga2V5cGF0aCArICcubGVuZ3RoJywgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVHJpZ2dlciBzcGxpY2Ugb3BlcmF0aW9uc1xuXHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gdmlld21vZGVsLmRlcHNbICdkZWZhdWx0JyBdWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdGRlcGVuZGFudHMuZmlsdGVyKCBjYW5TcGxpY2UgKS5mb3JFYWNoKCBmdW5jdGlvbiggZGVwZW5kYW50ICkge1xuXHRcdFx0XHRcdHJldHVybiBkZXBlbmRhbnQuc3BsaWNlKCBzcGxpY2VTdW1tYXJ5ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY2FuU3BsaWNlKCBkZXBlbmRhbnQgKSB7XG5cdFx0XHRyZXR1cm4gZGVwZW5kYW50LnR5cGUgPT09IHR5cGVzLlNFQ1RJT04gJiYgKCAhZGVwZW5kYW50LnN1YnR5cGUgfHwgZGVwZW5kYW50LnN1YnR5cGUgPT09IHR5cGVzLlNFQ1RJT05fRUFDSCApICYmIGRlcGVuZGFudC5yZW5kZXJlZDtcblx0XHR9XG5cdH0oIHR5cGVzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS90ZWFyZG93bi5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHRlYXJkb3duID0gZnVuY3Rpb24gVmlld21vZGVsJHRlYXJkb3duKCkge1xuXHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdHZhciB1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5O1xuXHRcdC8vIENsZWFyIGVudGlyZSBjYWNoZSAtIHRoaXMgaGFzIHRoZSBkZXNpcmVkIHNpZGUtZWZmZWN0XG5cdFx0Ly8gb2YgdW53cmFwcGluZyBhZGFwdGVkIHZhbHVlcyAoZS5nLiBhcnJheXMpXG5cdFx0T2JqZWN0LmtleXMoIHRoaXMuY2FjaGUgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiB0aGlzJDAuY2xlYXJDYWNoZSgga2V5cGF0aCApO1xuXHRcdH0gKTtcblx0XHQvLyBUZWFyZG93biBhbnkgZmFpbGVkIGxvb2t1cHMgLSB3ZSBkb24ndCBuZWVkIHRoZW0gdG8gcmVzb2x2ZSBhbnkgbW9yZVxuXHRcdHdoaWxlICggdW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzLnBvcCgpICkge1xuXHRcdFx0dW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS50ZWFyZG93bigpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3VucmVnaXN0ZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCR1bnJlZ2lzdGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJHVucmVnaXN0ZXIoIGtleXBhdGgsIGRlcGVuZGFudCApIHtcblx0XHRcdHZhciBncm91cCA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0aWYgKCBncm91cCA9PT0gdm9pZCAwIClcblx0XHRcdFx0Z3JvdXAgPSAnZGVmYXVsdCc7XG5cdFx0XHR2YXIgZGVwcywgaW5kZXgsIGV2YWx1YXRvcjtcblx0XHRcdGlmICggZGVwZW5kYW50LmlzU3RhdGljICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRkZXBzID0gdGhpcy5kZXBzWyBncm91cCBdWyBrZXlwYXRoIF07XG5cdFx0XHRpbmRleCA9IGRlcHMuaW5kZXhPZiggZGVwZW5kYW50ICk7XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHJlbW92ZSBhIGRlcGVuZGFudCB0aGF0IHdhcyBubyBsb25nZXIgcmVnaXN0ZXJlZCEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBidWcgaW4gZGV2ZWxvcG1lbnQgcGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MnICk7XG5cdFx0XHR9XG5cdFx0XHRkZXBzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggZXZhbHVhdG9yID0gdGhpcy5ldmFsdWF0b3JzWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdGV2YWx1YXRvci5kZXBlbmRhbnRzIC09IDE7XG5cdFx0XHRcdGlmICggIWV2YWx1YXRvci5kZXBlbmRhbnRzICkge1xuXHRcdFx0XHRcdGV2YWx1YXRvci5zbGVlcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVEZXBlbmRhbnRzTWFwKCB0aGlzLCBrZXlwYXRoLCBncm91cCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVEZXBlbmRhbnRzTWFwKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwICkge1xuXHRcdFx0dmFyIGtleXMsIHBhcmVudEtleXBhdGgsIG1hcCwgcGFyZW50O1xuXHRcdFx0Ly8gdXBkYXRlIGRlcGVuZGFudHMgbWFwXG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHR3aGlsZSAoIGtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0bWFwID0gdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwIF07XG5cdFx0XHRcdHBhcmVudCA9IG1hcFsgcGFyZW50S2V5cGF0aCBdO1xuXHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSAtPSAxO1xuXHRcdFx0XHRpZiAoICFwYXJlbnRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHQvLyByZW1vdmUgZnJvbSBwYXJlbnQgZGVwcyBtYXBcblx0XHRcdFx0XHRwYXJlbnQuc3BsaWNlKCBwYXJlbnQuaW5kZXhPZigga2V5cGF0aCApLCAxICk7XG5cdFx0XHRcdFx0cGFyZW50WyBrZXlwYXRoIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5cGF0aCA9IHBhcmVudEtleXBhdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL0NvbXB1dGF0aW9uL2dldENvbXB1dGF0aW9uU2lnbmF0dXJlLmpzICovXG5cdHZhciBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHBhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzaWduYXR1cmUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Z2V0OiBzaWduYXR1cmVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Z2V0OiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZSApXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0c2lnbmF0dXJlID0ge1xuXHRcdFx0XHRcdGdldDogY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKCBzaWduYXR1cmUuZ2V0ICksXG5cdFx0XHRcdFx0c2V0OiBzaWduYXR1cmUuc2V0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2lnbmF0dXJlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZSApIHtcblx0XHRcdHZhciBmdW5jdGlvbkJvZHkgPSAndmFyIF9fcmFjdGl2ZT10aGlzO3JldHVybignICsgc2lnbmF0dXJlLnJlcGxhY2UoIHBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwga2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuICdfX3JhY3RpdmUuZ2V0KFwiJyArIGtleXBhdGggKyAnXCIpJztcblx0XHRcdH0gKSArICcpJztcblx0XHRcdHJldHVybiBuZXcgRnVuY3Rpb24oIGZ1bmN0aW9uQm9keSApO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9Db21wdXRhdGlvbi9Db21wdXRhdGlvbi5qcyAqL1xuXHR2YXIgQ29tcHV0YXRpb24gPSBmdW5jdGlvbiggbG9nLCBpc0VxdWFsLCBkaWZmICkge1xuXG5cdFx0dmFyIENvbXB1dGF0aW9uID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlICkge1xuXHRcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMudmlld21vZGVsID0gcmFjdGl2ZS52aWV3bW9kZWw7XG5cdFx0XHR0aGlzLmtleSA9IGtleTtcblx0XHRcdHRoaXMuZ2V0dGVyID0gc2lnbmF0dXJlLmdldDtcblx0XHRcdHRoaXMuc2V0dGVyID0gc2lnbmF0dXJlLnNldDtcblx0XHRcdHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cdFx0Q29tcHV0YXRpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zZXR0aW5nICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhdGhpcy5zZXR0ZXIgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ29tcHV0ZWQgcHJvcGVydGllcyB3aXRob3V0IHNldHRlcnMgYXJlIHJlYWQtb25seS4gKFRoaXMgbWF5IGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUhKScgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNldHRlci5jYWxsKCB0aGlzLnJhY3RpdmUsIHZhbHVlICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gcmV0dXJucyBgZmFsc2VgIGlmIHRoZSBjb21wdXRhdGlvbiBlcnJvcnNcblx0XHRcdGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmFjdGl2ZSwgZXJyb3JlZCwgbmV3RGVwZW5kZW5jaWVzO1xuXHRcdFx0XHRyYWN0aXZlID0gdGhpcy5yYWN0aXZlO1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5jYXB0dXJlKCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwoIHJhY3RpdmUgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiAnZmFpbGVkQ29tcHV0YXRpb24nLFxuXHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRrZXk6IHRoaXMua2V5LFxuXHRcdFx0XHRcdFx0XHRlcnI6IGVyci5tZXNzYWdlIHx8IGVyclxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRlcnJvcmVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXdEZXBlbmRlbmNpZXMgPSByYWN0aXZlLnZpZXdtb2RlbC5yZWxlYXNlKCk7XG5cdFx0XHRcdGRpZmYoIHRoaXMsIHRoaXMuZGVwZW5kZW5jaWVzLCBuZXdEZXBlbmRlbmNpZXMgKTtcblx0XHRcdFx0cmV0dXJuIGVycm9yZWQgPyBmYWxzZSA6IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0aWYgKCB0aGlzLmNvbXB1dGUoKSAmJiAhaXNFcXVhbCggdGhpcy52YWx1ZSwgb2xkVmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLm1hcmsoIHRoaXMua2V5ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBDb21wdXRhdGlvbjtcblx0fSggbG9nLCBpc0VxdWFsLCBkaWZmICk7XG5cblx0Lyogdmlld21vZGVsL0NvbXB1dGF0aW9uL2NyZWF0ZUNvbXB1dGF0aW9ucy5qcyAqL1xuXHR2YXIgY3JlYXRlQ29tcHV0YXRpb25zID0gZnVuY3Rpb24oIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlLCBDb21wdXRhdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21wdXRhdGlvbnMoIHJhY3RpdmUsIGNvbXB1dGVkICkge1xuXHRcdFx0dmFyIGtleSwgc2lnbmF0dXJlO1xuXHRcdFx0Zm9yICgga2V5IGluIGNvbXB1dGVkICkge1xuXHRcdFx0XHRzaWduYXR1cmUgPSBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSggY29tcHV0ZWRbIGtleSBdICk7XG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGF0aW9uc1sga2V5IF0gPSBuZXcgQ29tcHV0YXRpb24oIHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUsIENvbXB1dGF0aW9uICk7XG5cblx0Lyogdmlld21vZGVsL2FkYXB0Q29uZmlnLmpzICovXG5cdHZhciBhZGFwdENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gc2hvdWxkIHRoaXMgYmUgY29tYmluZWQgd2l0aCBwcm90b3R5cGUvYWRhcHQuanM/XG5cdFx0dmFyIGNvbmZpZ3VyZSA9IHtcblx0XHRcdGxvb2t1cDogZnVuY3Rpb24oIHRhcmdldCwgYWRhcHRvcnMgKSB7XG5cdFx0XHRcdHZhciBpLCBhZGFwdCA9IHRhcmdldC5hZGFwdDtcblx0XHRcdFx0aWYgKCAhYWRhcHQgfHwgIWFkYXB0Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhZGFwdG9ycyAmJiBPYmplY3Qua2V5cyggYWRhcHRvcnMgKS5sZW5ndGggJiYgKCBpID0gYWRhcHQubGVuZ3RoICkgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHR2YXIgYWRhcHRvciA9IGFkYXB0WyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBhZGFwdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdFx0YWRhcHRbIGkgXSA9IGFkYXB0b3JzWyBhZGFwdG9yIF0gfHwgYWRhcHRvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdFx0fSxcblx0XHRcdGNvbWJpbmU6IGZ1bmN0aW9uKCBwYXJlbnQsIGFkYXB0ICkge1xuXHRcdFx0XHQvLyBub3JtYWxpemUgJ0ZvbycgdG8gWyAnRm9vJyBdXG5cdFx0XHRcdHBhcmVudCA9IGFycmF5SWZTdHJpbmcoIHBhcmVudCApO1xuXHRcdFx0XHRhZGFwdCA9IGFycmF5SWZTdHJpbmcoIGFkYXB0ICk7XG5cdFx0XHRcdC8vIG5vIHBhcmVudD8gcmV0dXJuIGFkYXB0XG5cdFx0XHRcdGlmICggIXBhcmVudCB8fCAhcGFyZW50Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbm8gYWRhcHQ/IHJldHVybiAnY29weScgb2YgcGFyZW50XG5cdFx0XHRcdGlmICggIWFkYXB0IHx8ICFhZGFwdC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5zbGljZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFkZCBwYXJlbnQgYWRhcHRvcnMgdG8gb3B0aW9uc1xuXHRcdFx0XHRwYXJlbnQuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgcHV0IGluIGR1cGxpY2F0ZXNcblx0XHRcdFx0XHRpZiAoIGFkYXB0LmluZGV4T2YoIGEgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRhZGFwdC5wdXNoKCBhICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYXJyYXlJZlN0cmluZyggYWRhcHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBhZGFwdCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGFkYXB0ID0gWyBhZGFwdCBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdH1cblx0XHRyZXR1cm4gY29uZmlndXJlO1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL1ZpZXdtb2RlbC5qcyAqL1xuXHR2YXIgVmlld21vZGVsID0gZnVuY3Rpb24oIGNyZWF0ZSwgYWRhcHQsIGFwcGx5Q2hhbmdlcywgY2FwdHVyZSwgY2xlYXJDYWNoZSwgZ2V0LCBtYXJrLCBtZXJnZSwgcmVnaXN0ZXIsIHJlbGVhc2UsIHNldCwgc3BsaWNlLCB0ZWFyZG93biwgdW5yZWdpc3RlciwgY3JlYXRlQ29tcHV0YXRpb25zLCBhZGFwdENvbmZpZyApIHtcblxuXHRcdC8vIFRPRE86IGZpeCBvdXIgRVM2IG1vZHVsZXMgc28gd2UgY2FuIGhhdmUgbXVsdGlwbGUgZXhwb3J0c1xuXHRcdC8vIHRoZW4gdGhpcyBtYWdpYyBjaGVjayBjYW4gYmUgcmV1c2VkIGJ5IG1hZ2ljQWRhcHRvclxuXHRcdHZhciBub01hZ2ljO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0bm9NYWdpYyA9IHRydWU7XG5cdFx0fVxuXHRcdHZhciBWaWV3bW9kZWwgPSBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cdFx0XHQvLyBUT0RPIGV2ZW50dWFsbHksIHdlIHNob3VsZG4ndCBuZWVkIHRoaXMgcmVmZXJlbmNlXG5cdFx0XHRWaWV3bW9kZWwuZXh0ZW5kKCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlICk7XG5cdFx0XHQvL3RoaXMucmFjdGl2ZS5kYXRhXG5cdFx0XHR0aGlzLmNhY2hlID0ge307XG5cdFx0XHQvLyB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gdXNlIGhhc093blByb3BlcnR5LCBzbyBjYW4ndCBpbmhlcml0IGZyb20gbnVsbFxuXHRcdFx0dGhpcy5jYWNoZU1hcCA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5kZXBzID0ge1xuXHRcdFx0XHRjb21wdXRlZDoge30sXG5cdFx0XHRcdCdkZWZhdWx0Jzoge31cblx0XHRcdH07XG5cdFx0XHR0aGlzLmRlcHNNYXAgPSB7XG5cdFx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdFx0J2RlZmF1bHQnOiB7fVxuXHRcdFx0fTtcblx0XHRcdHRoaXMucGF0dGVybk9ic2VydmVycyA9IFtdO1xuXHRcdFx0dGhpcy53cmFwcGVkID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHQvLyBUT0RPIHRoZXNlIGFyZSBjb25jZXB0dWFsbHkgdmVyeSBzaW1pbGFyLiBDYW4gdGhleSBiZSBtZXJnZWQgc29tZWhvdz9cblx0XHRcdHRoaXMuZXZhbHVhdG9ycyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5jb21wdXRhdGlvbnMgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdHRoaXMuY2FwdHVyZWQgPSBudWxsO1xuXHRcdFx0dGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMgPSBbXTtcblx0XHRcdHRoaXMuY2hhbmdlcyA9IFtdO1xuXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcblx0XHR9O1xuXHRcdFZpZXdtb2RlbC5leHRlbmQgPSBmdW5jdGlvbiggUGFyZW50LCBpbnN0YW5jZSApIHtcblx0XHRcdGlmICggaW5zdGFuY2UubWFnaWMgJiYgbm9NYWdpYyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnR2V0dGVycyBhbmQgc2V0dGVycyAobWFnaWMgbW9kZSkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyApO1xuXHRcdFx0fVxuXHRcdFx0aW5zdGFuY2UuYWRhcHQgPSBhZGFwdENvbmZpZy5jb21iaW5lKCBQYXJlbnQucHJvdG90eXBlLmFkYXB0LCBpbnN0YW5jZS5hZGFwdCApIHx8IFtdO1xuXHRcdFx0aW5zdGFuY2UuYWRhcHQgPSBhZGFwdENvbmZpZy5sb29rdXAoIGluc3RhbmNlLCBpbnN0YW5jZS5hZGFwdG9ycyApO1xuXHRcdH07XG5cdFx0Vmlld21vZGVsLnByb3RvdHlwZSA9IHtcblx0XHRcdGFkYXB0OiBhZGFwdCxcblx0XHRcdGFwcGx5Q2hhbmdlczogYXBwbHlDaGFuZ2VzLFxuXHRcdFx0Y2FwdHVyZTogY2FwdHVyZSxcblx0XHRcdGNsZWFyQ2FjaGU6IGNsZWFyQ2FjaGUsXG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdG1hcms6IG1hcmssXG5cdFx0XHRtZXJnZTogbWVyZ2UsXG5cdFx0XHRyZWdpc3RlcjogcmVnaXN0ZXIsXG5cdFx0XHRyZWxlYXNlOiByZWxlYXNlLFxuXHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRzcGxpY2U6IHNwbGljZSxcblx0XHRcdHRlYXJkb3duOiB0ZWFyZG93bixcblx0XHRcdHVucmVnaXN0ZXI6IHVucmVnaXN0ZXIsXG5cdFx0XHQvLyBjcmVhdGVDb21wdXRhdGlvbnMsIGluIHRoZSBjb21wdXRhdGlvbnMsIG1heSBjYWxsIGJhY2sgdGhyb3VnaCBnZXQgb3Igc2V0XG5cdFx0XHQvLyBvZiByYWN0aXZlLiBTbywgZm9yIG5vdywgd2UgZGVsYXkgY3JlYXRpb24gb2YgY29tcHV0ZWQgZnJvbSBjb25zdHJ1Y3Rvci5cblx0XHRcdC8vIG9uIG9wdGlvbiB3b3VsZCBiZSB0byBoYXZlIHRoZSBDb21wdXRlZCBjbGFzcyBiZSBsYXp5IGFib3V0IHVzaW5nIC51cGRhdGUoKVxuXHRcdFx0Y29tcHV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNyZWF0ZUNvbXB1dGF0aW9ucyggdGhpcy5yYWN0aXZlLCB0aGlzLnJhY3RpdmUuY29tcHV0ZWQgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBWaWV3bW9kZWw7XG5cdH0oIGNyZWF0ZSwgdmlld21vZGVsJGFkYXB0LCB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzLCB2aWV3bW9kZWwkY2FwdHVyZSwgdmlld21vZGVsJGNsZWFyQ2FjaGUsIHZpZXdtb2RlbCRnZXQsIHZpZXdtb2RlbCRtYXJrLCB2aWV3bW9kZWwkbWVyZ2UsIHZpZXdtb2RlbCRyZWdpc3Rlciwgdmlld21vZGVsJHJlbGVhc2UsIHZpZXdtb2RlbCRzZXQsIHZpZXdtb2RlbCRzcGxpY2UsIHZpZXdtb2RlbCR0ZWFyZG93biwgdmlld21vZGVsJHVucmVnaXN0ZXIsIGNyZWF0ZUNvbXB1dGF0aW9ucywgYWRhcHRDb25maWcgKTtcblxuXHQvKiBSYWN0aXZlL2luaXRpYWxpc2UuanMgKi9cblx0dmFyIFJhY3RpdmVfaW5pdGlhbGlzZSA9IGZ1bmN0aW9uKCBjb25maWcsIGNyZWF0ZSwgZ2V0RWxlbWVudCwgZ2V0TmV4dE51bWJlciwgVmlld21vZGVsLCBGcmFnbWVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlKCByYWN0aXZlICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0aW5pdGlhbGlzZVByb3BlcnRpZXMoIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHRcdC8vIGluaXQgY29uZmlnIGZyb20gUGFyZW50IGFuZCBvcHRpb25zXG5cdFx0XHRjb25maWcuaW5pdCggcmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0Ly8gVEVNUE9SQVJZLiBUaGlzIGlzIHNvIHdlIGNhbiBpbXBsZW1lbnQgVmlld21vZGVsIGdyYWR1YWxseVxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwgPSBuZXcgVmlld21vZGVsKCByYWN0aXZlICk7XG5cdFx0XHQvLyBoYWNreSBjaXJjdWxhciBwcm9ibGVtIHVudGlsIHdlIGdldCB0aGlzIHNvcnRlZCBvdXRcblx0XHRcdC8vIGlmIHZpZXdtb2RlbCBpbW1lZGlhdGVseSBwcm9jZXNzZXMgY29tcHV0ZWQgcHJvcGVydGllcyxcblx0XHRcdC8vIHRoZXkgbWF5IGNhbGwgcmFjdGl2ZS5nZXQsIHdoaWNoIGNhbGxzIHJhY3RpdmUudmlld21vZGVsLFxuXHRcdFx0Ly8gd2hpY2ggaGFzbid0IGJlZW4gc2V0IHRpbGwgbGluZSBhYm92ZSBmaW5pc2hlcy5cblx0XHRcdHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGUoKTtcblx0XHRcdC8vIFJlbmRlciBvdXIgKnJvb3QgZnJhZ21lbnQqXG5cdFx0XHRpZiAoIHJhY3RpdmUudGVtcGxhdGUgKSB7XG5cdFx0XHRcdHJhY3RpdmUuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogcmFjdGl2ZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiByYWN0aXZlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJhY3RpdmUudmlld21vZGVsLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0Ly8gcmVuZGVyIGF1dG9tYXRpY2FsbHkgKCBpZiBgZWxgIGlzIHNwZWNpZmllZCApXG5cdFx0XHR0cnlSZW5kZXIoIHJhY3RpdmUgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdHJ5UmVuZGVyKCByYWN0aXZlICkge1xuXHRcdFx0dmFyIGVsO1xuXHRcdFx0aWYgKCBlbCA9IGdldEVsZW1lbnQoIHJhY3RpdmUuZWwgKSApIHtcblx0XHRcdFx0dmFyIHdhc0VuYWJsZWQgPSByYWN0aXZlLnRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdFx0Ly8gVGVtcG9yYXJpbHkgZGlzYWJsZSB0cmFuc2l0aW9ucywgaWYgYG5vSW50cm9gIGZsYWcgaXMgc2V0XG5cdFx0XHRcdGlmICggcmFjdGl2ZS5ub0ludHJvICkge1xuXHRcdFx0XHRcdHJhY3RpdmUudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgdGhlIHRhcmdldCBjb250YWlucyBjb250ZW50LCBhbmQgYGFwcGVuZGAgaXMgZmFsc3ksIGNsZWFyIGl0XG5cdFx0XHRcdGlmICggZWwgJiYgIXJhY3RpdmUuYXBwZW5kICkge1xuXHRcdFx0XHRcdC8vIFRlYXIgZG93biBhbnkgZXhpc3RpbmcgaW5zdGFuY2VzIG9uIHRoaXMgZWxlbWVudFxuXHRcdFx0XHRcdGlmICggZWwuX19yYWN0aXZlX2luc3RhbmNlc19fICkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0ZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLnNwbGljZSggMCwgZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLmxlbmd0aCApLmZvckVhY2goIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByLnRlYXJkb3duKCk7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbC5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0XHRyYWN0aXZlLnJlbmRlciggZWwsIHJhY3RpdmUuYXBwZW5kICk7XG5cdFx0XHRcdC8vIHJlc2V0IHRyYW5zaXRpb25zRW5hYmxlZFxuXHRcdFx0XHRyYWN0aXZlLnRyYW5zaXRpb25zRW5hYmxlZCA9IHdhc0VuYWJsZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5pdGlhbGlzZVByb3BlcnRpZXMoIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHQvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLCBmb3IgcGxhY2VzIHdoZXJlIHlvdSdkIHVzZSBhIHdlYWsgbWFwIGlmIGl0XG5cdFx0XHQvLyBleGlzdGVkXG5cdFx0XHRyYWN0aXZlLl9ndWlkID0gZ2V0TmV4dE51bWJlcigpO1xuXHRcdFx0Ly8gZXZlbnRzXG5cdFx0XHRyYWN0aXZlLl9zdWJzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHQvLyBzdG9yYWdlIGZvciBpdGVtIGNvbmZpZ3VyYXRpb24gZnJvbSBpbnN0YW50aWF0aW9uIHRvIHJlc2V0LFxuXHRcdFx0Ly8gbGlrZSBkeW5hbWljIGZ1bmN0aW9ucyBvciBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHJhY3RpdmUuX2NvbmZpZyA9IHt9O1xuXHRcdFx0Ly8gdHdvLXdheSBiaW5kaW5nc1xuXHRcdFx0cmFjdGl2ZS5fdHdvd2F5QmluZGluZ3MgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdC8vIGFuaW1hdGlvbnMgKHNvIHdlIGNhbiBzdG9wIGFueSBpbiBwcm9ncmVzcyBhdCB0ZWFyZG93bilcblx0XHRcdHJhY3RpdmUuX2FuaW1hdGlvbnMgPSBbXTtcblx0XHRcdC8vIG5vZGVzIHJlZ2lzdHJ5XG5cdFx0XHRyYWN0aXZlLm5vZGVzID0ge307XG5cdFx0XHQvLyBsaXZlIHF1ZXJpZXNcblx0XHRcdHJhY3RpdmUuX2xpdmVRdWVyaWVzID0gW107XG5cdFx0XHRyYWN0aXZlLl9saXZlQ29tcG9uZW50UXVlcmllcyA9IFtdO1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudFxuXHRcdFx0aWYgKCBvcHRpb25zLl9wYXJlbnQgJiYgb3B0aW9ucy5fY29tcG9uZW50ICkge1xuXHRcdFx0XHRyYWN0aXZlLl9wYXJlbnQgPSBvcHRpb25zLl9wYXJlbnQ7XG5cdFx0XHRcdHJhY3RpdmUuY29tcG9uZW50ID0gb3B0aW9ucy5fY29tcG9uZW50O1xuXHRcdFx0XHQvLyBBbmQgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9uIHRoZSBjb21wb25lbnRcblx0XHRcdFx0b3B0aW9ucy5fY29tcG9uZW50Lmluc3RhbmNlID0gcmFjdGl2ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0oIGNvbmZpZywgY3JlYXRlLCBnZXRFbGVtZW50LCBnZXROZXh0TnVtYmVyLCBWaWV3bW9kZWwsIEZyYWdtZW50ICk7XG5cblx0LyogZXh0ZW5kL2luaXRDaGlsZEluc3RhbmNlLmpzICovXG5cdHZhciBpbml0Q2hpbGRJbnN0YW5jZSA9IGZ1bmN0aW9uKCBpbml0aWFsaXNlICkge1xuXG5cdFx0Ly8gVGhlIENoaWxkIGNvbnN0cnVjdG9yIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGluaXQgb3B0aW9ucyBmb3IgdGhpcyBjbGFzc1xuXHRcdHJldHVybiBmdW5jdGlvbiBpbml0Q2hpbGRJbnN0YW5jZSggY2hpbGQsIENoaWxkLCBvcHRpb25zICkge1xuXHRcdFx0aWYgKCBjaGlsZC5iZWZvcmVJbml0ICkge1xuXHRcdFx0XHRjaGlsZC5iZWZvcmVJbml0KCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsaXNlKCBjaGlsZCwgb3B0aW9ucyApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmVfaW5pdGlhbGlzZSApO1xuXG5cdC8qIGV4dGVuZC9jaGlsZE9wdGlvbnMuanMgKi9cblx0dmFyIGNoaWxkT3B0aW9ucyA9IGZ1bmN0aW9uKCB3cmFwUHJvdG90eXBlLCB3cmFwLCBjb25maWcsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFJhY3RpdmUsXG5cdFx0XHQvLyB3b3VsZCBiZSBuaWNlIHRvIG5vdCBoYXZlIHRoZXNlIGhlcmUsXG5cdFx0XHQvLyB0aGV5IGdldCBhZGRlZCBkdXJpbmcgaW5pdGlhbGlzZSwgc28gZm9yIG5vdyB3ZSBoYXZlXG5cdFx0XHQvLyB0byBtYWtlIHN1cmUgbm90IHRvIHRyeSBhbmQgZXh0ZW5kIHRoZW0uXG5cdFx0XHQvLyBQb3NzaWJseSwgd2UgY291bGQgcmUtb3JkZXIgYW5kIG5vdCBhZGQgdGlsbCBsYXRlclxuXHRcdFx0Ly8gaW4gcHJvY2Vzcy5cblx0XHRcdGJsYWNrbGlzdGVkID0ge1xuXHRcdFx0XHQnX3BhcmVudCc6IHRydWUsXG5cdFx0XHRcdCdfY29tcG9uZW50JzogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdGNoaWxkT3B0aW9ucyA9IHtcblx0XHRcdFx0dG9Qcm90b3R5cGU6IHRvUHJvdG90eXBlLFxuXHRcdFx0XHR0b09wdGlvbnM6IHRvT3B0aW9uc1xuXHRcdFx0fSxcblx0XHRcdHJlZ2lzdHJpZXMgPSBjb25maWcucmVnaXN0cmllcztcblx0XHRjb25maWcua2V5cy5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuIGJsYWNrbGlzdGVkWyBrZXkgXSA9IHRydWU7XG5cdFx0fSApO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0UmFjdGl2ZSA9IGNpcmN1bGFyLlJhY3RpdmU7XG5cdFx0fSApO1xuXHRcdHJldHVybiBjaGlsZE9wdGlvbnM7XG5cblx0XHRmdW5jdGlvbiB0b1Byb3RvdHlwZSggcGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCAhKCBrZXkgaW4gYmxhY2tsaXN0ZWQgKSAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR2YXIgbWVtYmVyID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCB0aGF0IG92ZXJ3cml0ZXMgYSBtZXRob2QsIHdyYXAgaXQ6XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgbWVtYmVyID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0bWVtYmVyID0gd3JhcFByb3RvdHlwZSggcGFyZW50LCBrZXksIG1lbWJlciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcm90b1sga2V5IF0gPSBtZW1iZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0b09wdGlvbnMoIENoaWxkICkge1xuXHRcdFx0aWYgKCAhKCBDaGlsZC5wcm90b3R5cGUgaW5zdGFuY2VvZiBSYWN0aXZlICkgKSB7XG5cdFx0XHRcdHJldHVybiBDaGlsZDtcblx0XHRcdH1cblx0XHRcdHZhciBvcHRpb25zID0ge307XG5cdFx0XHR3aGlsZSAoIENoaWxkICkge1xuXHRcdFx0XHRyZWdpc3RyaWVzLmZvckVhY2goIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdGFkZFJlZ2lzdHJ5KCByLnVzZURlZmF1bHRzID8gQ2hpbGQucHJvdG90eXBlIDogQ2hpbGQsIG9wdGlvbnMsIHIubmFtZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdE9iamVjdC5rZXlzKCBDaGlsZC5wcm90b3R5cGUgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdGlmICgga2V5ID09PSAnY29tcHV0ZWQnICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBDaGlsZC5wcm90b3R5cGVbIGtleSBdO1xuXHRcdFx0XHRcdGlmICggISgga2V5IGluIG9wdGlvbnMgKSApIHtcblx0XHRcdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gdmFsdWUuX21ldGhvZCA/IHZhbHVlLl9tZXRob2QgOiB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9uc1sga2V5IF0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnNbIGtleSBdLl9tZXRob2QgKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0LCBuZWVkc1N1cGVyID0gdmFsdWUuX21ldGhvZDtcblx0XHRcdFx0XHRcdGlmICggbmVlZHNTdXBlciApIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5fbWV0aG9kO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gcmV3cmFwIGJvdW5kIGRpcmVjdGx5IHRvIHBhcmVudCBmblxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gd3JhcCggb3B0aW9uc1sga2V5IF0uX21ldGhvZCwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGlmICggbmVlZHNTdXBlciApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0Ll9tZXRob2QgPSByZXN1bHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCBDaGlsZC5fcGFyZW50ICE9PSBSYWN0aXZlICkge1xuXHRcdFx0XHRcdENoaWxkID0gQ2hpbGQuX3BhcmVudDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRDaGlsZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3B0aW9ucztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRSZWdpc3RyeSggdGFyZ2V0LCBvcHRpb25zLCBuYW1lICkge1xuXHRcdFx0dmFyIHJlZ2lzdHJ5LCBrZXlzID0gT2JqZWN0LmtleXMoIHRhcmdldFsgbmFtZSBdICk7XG5cdFx0XHRpZiAoICFrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhKCByZWdpc3RyeSA9IG9wdGlvbnNbIG5hbWUgXSApICkge1xuXHRcdFx0XHRyZWdpc3RyeSA9IG9wdGlvbnNbIG5hbWUgXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0a2V5cy5maWx0ZXIoIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBrZXkgaW4gcmVnaXN0cnkgKTtcblx0XHRcdH0gKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVnaXN0cnlbIGtleSBdID0gdGFyZ2V0WyBuYW1lIF1bIGtleSBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fSggd3JhcFByb3RvdHlwZU1ldGhvZCwgd3JhcE1ldGhvZCwgY29uZmlnLCBjaXJjdWxhciApO1xuXG5cdC8qIGV4dGVuZC9fZXh0ZW5kLmpzICovXG5cdHZhciBSYWN0aXZlX2V4dGVuZCA9IGZ1bmN0aW9uKCBjcmVhdGUsIGRlZmluZVByb3BlcnRpZXMsIGdldEd1aWQsIGNvbmZpZywgaW5pdENoaWxkSW5zdGFuY2UsIFZpZXdtb2RlbCwgY2hpbGRPcHRpb25zICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAwIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRDaGlsZCwgcHJvdG8sIHN0YXRpY1Byb3BlcnRpZXM7XG5cdFx0XHQvLyBpZiB3ZSdyZSBleHRlbmRpbmcgd2l0aCBhbm90aGVyIFJhY3RpdmUgaW5zdGFuY2UsIGluaGVyaXQgaXRzXG5cdFx0XHQvLyBwcm90b3R5cGUgbWV0aG9kcyBhbmQgZGVmYXVsdCBvcHRpb25zIGFzIHdlbGxcblx0XHRcdG9wdGlvbnMgPSBjaGlsZE9wdGlvbnMudG9PcHRpb25zKCBvcHRpb25zICk7XG5cdFx0XHQvLyBjcmVhdGUgQ2hpbGQgY29uc3RydWN0b3Jcblx0XHRcdENoaWxkID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGluaXRDaGlsZEluc3RhbmNlKCB0aGlzLCBDaGlsZCwgb3B0aW9ucyApO1xuXHRcdFx0fTtcblx0XHRcdHByb3RvID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRwcm90by5jb25zdHJ1Y3RvciA9IENoaWxkO1xuXHRcdFx0c3RhdGljUHJvcGVydGllcyA9IHtcblx0XHRcdFx0Ly8gZWFjaCBjb21wb25lbnQgbmVlZHMgYSBndWlkLCBmb3IgbWFuYWdpbmcgQ1NTIGV0Y1xuXHRcdFx0XHRfZ3VpZDoge1xuXHRcdFx0XHRcdHZhbHVlOiBnZXRHdWlkKClcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG5cdFx0XHRcdGRlZmF1bHRzOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByb3RvXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIGV4dGVuZGFibGVcblx0XHRcdFx0ZXh0ZW5kOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGV4dGVuZCxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gUGFyZW50IC0gZm9yIElFOCwgY2FuJ3QgdXNlIE9iamVjdC5nZXRQcm90b3R5cGVPZlxuXHRcdFx0XHRfcGFyZW50OiB7XG5cdFx0XHRcdFx0dmFsdWU6IFBhcmVudFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyggQ2hpbGQsIHN0YXRpY1Byb3BlcnRpZXMgKTtcblx0XHRcdC8vIGV4dGVuZCBjb25maWd1cmF0aW9uXG5cdFx0XHRjb25maWcuZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0XHRWaWV3bW9kZWwuZXh0ZW5kKCBQYXJlbnQsIHByb3RvICk7XG5cdFx0XHQvLyBhbmQgYW55IG90aGVyIHByb3BlcnRpZXMgb3IgbWV0aG9kcyBvbiBvcHRpb25zLi4uXG5cdFx0XHRjaGlsZE9wdGlvbnMudG9Qcm90b3R5cGUoIFBhcmVudC5wcm90b3R5cGUsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUgPSBwcm90bztcblx0XHRcdHJldHVybiBDaGlsZDtcblx0XHR9O1xuXHR9KCBjcmVhdGUsIGRlZmluZVByb3BlcnRpZXMsIGdldEd1aWQsIGNvbmZpZywgaW5pdENoaWxkSW5zdGFuY2UsIFZpZXdtb2RlbCwgY2hpbGRPcHRpb25zICk7XG5cblx0LyogUmFjdGl2ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSA9IGZ1bmN0aW9uKCBkZWZhdWx0cywgZWFzaW5nLCBpbnRlcnBvbGF0b3JzLCBzdmcsIG1hZ2ljLCBkZWZpbmVQcm9wZXJ0aWVzLCBwcm90bywgUHJvbWlzZSwgZXh0ZW5kT2JqLCBleHRlbmQsIHBhcnNlLCBpbml0aWFsaXNlLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBSYWN0aXZlLCBwcm9wZXJ0aWVzO1xuXHRcdC8vIE1haW4gUmFjdGl2ZSByZXF1aXJlZCBvYmplY3Rcblx0XHRSYWN0aXZlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRpbml0aWFsaXNlKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHQvLyBSYWN0aXZlIHByb3BlcnRpZXNcblx0XHRwcm9wZXJ0aWVzID0ge1xuXHRcdFx0Ly8gc3RhdGljIG1ldGhvZHM6XG5cdFx0XHRleHRlbmQ6IHtcblx0XHRcdFx0dmFsdWU6IGV4dGVuZFxuXHRcdFx0fSxcblx0XHRcdHBhcnNlOiB7XG5cdFx0XHRcdHZhbHVlOiBwYXJzZVxuXHRcdFx0fSxcblx0XHRcdC8vIE5hbWVzcGFjZWQgY29uc3RydWN0b3JzXG5cdFx0XHRQcm9taXNlOiB7XG5cdFx0XHRcdHZhbHVlOiBQcm9taXNlXG5cdFx0XHR9LFxuXHRcdFx0Ly8gc3VwcG9ydFxuXHRcdFx0c3ZnOiB7XG5cdFx0XHRcdHZhbHVlOiBzdmdcblx0XHRcdH0sXG5cdFx0XHRtYWdpYzoge1xuXHRcdFx0XHR2YWx1ZTogbWFnaWNcblx0XHRcdH0sXG5cdFx0XHQvLyB2ZXJzaW9uXG5cdFx0XHRWRVJTSU9OOiB7XG5cdFx0XHRcdHZhbHVlOiAnMC41LjUnXG5cdFx0XHR9LFxuXHRcdFx0Ly8gUGx1Z2luc1xuXHRcdFx0YWRhcHRvcnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGNvbXBvbmVudHM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGRlY29yYXRvcnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGVhc2luZzoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IGVhc2luZ1xuXHRcdFx0fSxcblx0XHRcdGV2ZW50czoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJwb2xhdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IGludGVycG9sYXRvcnNcblx0XHRcdH0sXG5cdFx0XHRwYXJ0aWFsczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNpdGlvbnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0Ly8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG5cdFx0ZGVmaW5lUHJvcGVydGllcyggUmFjdGl2ZSwgcHJvcGVydGllcyApO1xuXHRcdFJhY3RpdmUucHJvdG90eXBlID0gZXh0ZW5kT2JqKCBwcm90bywgZGVmYXVsdHMgKTtcblx0XHRSYWN0aXZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhY3RpdmU7XG5cdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG5cdFx0UmFjdGl2ZS5kZWZhdWx0cyA9IFJhY3RpdmUucHJvdG90eXBlO1xuXHRcdC8vIENlcnRhaW4gbW9kdWxlcyBoYXZlIGNpcmN1bGFyIGRlcGVuZGVuY2llcy4gSWYgd2Ugd2VyZSBidW5kbGluZyBhXG5cdFx0Ly8gbW9kdWxlIGxvYWRlciwgZS5nLiBhbG1vbmQuanMsIHRoaXMgd291bGRuJ3QgYmUgYSBwcm9ibGVtLCBidXQgd2UncmVcblx0XHQvLyBub3QgLSB3ZSdyZSB1c2luZyBhbWRjbGVhbiBhcyBwYXJ0IG9mIHRoZSBidWlsZCBwcm9jZXNzLiBCZWNhdXNlIG9mXG5cdFx0Ly8gdGhpcywgd2UgbmVlZCB0byB3YWl0IHVudGlsIGFsbCBtb2R1bGVzIGhhdmUgbG9hZGVkIGJlZm9yZSB0aG9zZVxuXHRcdC8vIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBjYW4gYmUgcmVxdWlyZWQuXG5cdFx0Y2lyY3VsYXIuUmFjdGl2ZSA9IFJhY3RpdmU7XG5cdFx0d2hpbGUgKCBjaXJjdWxhci5sZW5ndGggKSB7XG5cdFx0XHRjaXJjdWxhci5wb3AoKSgpO1xuXHRcdH1cblx0XHQvLyBSYWN0aXZlLmpzIG1ha2VzIGxpYmVyYWwgdXNlIG9mIHRoaW5ncyBsaWtlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLiBJblxuXHRcdC8vIG9sZGVyIGJyb3dzZXJzLCB0aGVzZSBhcmUgbWFkZSBhdmFpbGFibGUgdmlhIGEgc2hpbSAtIGhlcmUsIHdlIGRvIGEgcXVpY2tcblx0XHQvLyBwcmUtZmxpZ2h0IGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IGVpdGhlciBhKSB3ZSdyZSBub3QgaW4gYSBzaGl0IGJyb3dzZXIsXG5cdFx0Ly8gb3IgYikgd2UncmUgdXNpbmcgYSBSYWN0aXZlLWxlZ2FjeS5qcyBidWlsZFxuXHRcdHZhciBGVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cdFx0aWYgKCB0eXBlb2YgRGF0ZS5ub3cgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBPYmplY3Qua2V5cyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUubWFwICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbHRlciAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBGVU5DVElPTiApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgUmFjdGl2ZS5qcyBpbiBhbiBvbGRlciBicm93c2VyLiBZb3VcXCdsbCBuZWVkIHRvIHVzZSBvbmUgb2YgdGhlIFxcJ2xlZ2FjeSBidWlsZHNcXCcgaW4gb3JkZXIgdG8gY29udGludWUgLSBzZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbGVnYWN5LWJ1aWxkcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nICk7XG5cdFx0fVxuXHRcdHJldHVybiBSYWN0aXZlO1xuXHR9KCBvcHRpb25zLCBlYXNpbmcsIGludGVycG9sYXRvcnMsIHN2ZywgbWFnaWMsIGRlZmluZVByb3BlcnRpZXMsIHByb3RvdHlwZSwgUHJvbWlzZSwgZXh0ZW5kLCBSYWN0aXZlX2V4dGVuZCwgcGFyc2UsIFJhY3RpdmVfaW5pdGlhbGlzZSwgY2lyY3VsYXIgKTtcblxuXG5cdC8vIGV4cG9ydCBhcyBDb21tb24gSlMgbW9kdWxlLi4uXG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyApIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFJhY3RpdmU7XG5cdH1cblxuXHQvLyAuLi4gb3IgYXMgQU1EIG1vZHVsZVxuXHRlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBSYWN0aXZlO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIC4uLiBvciBhcyBicm93c2VyIGdsb2JhbFxuXHRnbG9iYWwuUmFjdGl2ZSA9IFJhY3RpdmU7XG5cblx0UmFjdGl2ZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0Z2xvYmFsLlJhY3RpdmUgPSBub0NvbmZsaWN0O1xuXHRcdHJldHVybiBSYWN0aXZlO1xuXHR9O1xuXG59KCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMgKSApO1xuIl19;
